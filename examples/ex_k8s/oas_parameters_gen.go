// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
)

// ListAdmissionregistrationV1MutatingWebhookConfigurationParams is parameters of listAdmissionregistrationV1MutatingWebhookConfiguration operation.
type ListAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params ListAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAdmissionregistrationV1MutatingWebhookConfigurationParams(args [0]string, r *http.Request) (params ListAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAdmissionregistrationV1ValidatingWebhookConfigurationParams is parameters of listAdmissionregistrationV1ValidatingWebhookConfiguration operation.
type ListAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params ListAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [0]string, r *http.Request) (params ListAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListApiextensionsV1CustomResourceDefinitionParams is parameters of listApiextensionsV1CustomResourceDefinition operation.
type ListApiextensionsV1CustomResourceDefinitionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params ListApiextensionsV1CustomResourceDefinitionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListApiextensionsV1CustomResourceDefinitionParams(args [0]string, r *http.Request) (params ListApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListApiregistrationV1APIServiceParams is parameters of listApiregistrationV1APIService operation.
type ListApiregistrationV1APIServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListApiregistrationV1APIServiceParams(packed map[string]any) (params ListApiregistrationV1APIServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListApiregistrationV1APIServiceParams(args [0]string, r *http.Request) (params ListApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1ControllerRevisionForAllNamespacesParams is parameters of listAppsV1ControllerRevisionForAllNamespaces operation.
type ListAppsV1ControllerRevisionForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAppsV1ControllerRevisionForAllNamespacesParams(packed map[string]any) (params ListAppsV1ControllerRevisionForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1ControllerRevisionForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1ControllerRevisionForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1DaemonSetForAllNamespacesParams is parameters of listAppsV1DaemonSetForAllNamespaces operation.
type ListAppsV1DaemonSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAppsV1DaemonSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1DaemonSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1DaemonSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1DaemonSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1DeploymentForAllNamespacesParams is parameters of listAppsV1DeploymentForAllNamespaces operation.
type ListAppsV1DeploymentForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAppsV1DeploymentForAllNamespacesParams(packed map[string]any) (params ListAppsV1DeploymentForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1DeploymentForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1DeploymentForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1NamespacedControllerRevisionParams is parameters of listAppsV1NamespacedControllerRevision operation.
type ListAppsV1NamespacedControllerRevisionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params ListAppsV1NamespacedControllerRevisionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedControllerRevisionParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1NamespacedDaemonSetParams is parameters of listAppsV1NamespacedDaemonSet operation.
type ListAppsV1NamespacedDaemonSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAppsV1NamespacedDaemonSetParams(packed map[string]any) (params ListAppsV1NamespacedDaemonSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedDaemonSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1NamespacedDeploymentParams is parameters of listAppsV1NamespacedDeployment operation.
type ListAppsV1NamespacedDeploymentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAppsV1NamespacedDeploymentParams(packed map[string]any) (params ListAppsV1NamespacedDeploymentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedDeploymentParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1NamespacedReplicaSetParams is parameters of listAppsV1NamespacedReplicaSet operation.
type ListAppsV1NamespacedReplicaSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAppsV1NamespacedReplicaSetParams(packed map[string]any) (params ListAppsV1NamespacedReplicaSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedReplicaSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1NamespacedStatefulSetParams is parameters of listAppsV1NamespacedStatefulSet operation.
type ListAppsV1NamespacedStatefulSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAppsV1NamespacedStatefulSetParams(packed map[string]any) (params ListAppsV1NamespacedStatefulSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAppsV1NamespacedStatefulSetParams(args [1]string, r *http.Request) (params ListAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1ReplicaSetForAllNamespacesParams is parameters of listAppsV1ReplicaSetForAllNamespaces operation.
type ListAppsV1ReplicaSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAppsV1ReplicaSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1ReplicaSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1ReplicaSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1ReplicaSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAppsV1StatefulSetForAllNamespacesParams is parameters of listAppsV1StatefulSetForAllNamespaces operation.
type ListAppsV1StatefulSetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAppsV1StatefulSetForAllNamespacesParams(packed map[string]any) (params ListAppsV1StatefulSetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAppsV1StatefulSetForAllNamespacesParams(args [0]string, r *http.Request) (params ListAppsV1StatefulSetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams is parameters of listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces operation.
type ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams is parameters of listAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
type ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams is parameters of listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces operation.
type ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams is parameters of listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
type ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams is parameters of listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces operation.
type ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(packed map[string]any) (params ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(args [0]string, r *http.Request) (params ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams is parameters of listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
type ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [1]string, r *http.Request) (params ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1CronJobForAllNamespacesParams is parameters of listBatchV1CronJobForAllNamespaces operation.
type ListBatchV1CronJobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListBatchV1CronJobForAllNamespacesParams(packed map[string]any) (params ListBatchV1CronJobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1CronJobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1CronJobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1JobForAllNamespacesParams is parameters of listBatchV1JobForAllNamespaces operation.
type ListBatchV1JobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListBatchV1JobForAllNamespacesParams(packed map[string]any) (params ListBatchV1JobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1JobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1JobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1NamespacedCronJobParams is parameters of listBatchV1NamespacedCronJob operation.
type ListBatchV1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListBatchV1NamespacedCronJobParams(packed map[string]any) (params ListBatchV1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1NamespacedCronJobParams(args [1]string, r *http.Request) (params ListBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1NamespacedJobParams is parameters of listBatchV1NamespacedJob operation.
type ListBatchV1NamespacedJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListBatchV1NamespacedJobParams(packed map[string]any) (params ListBatchV1NamespacedJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1NamespacedJobParams(args [1]string, r *http.Request) (params ListBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1beta1CronJobForAllNamespacesParams is parameters of listBatchV1beta1CronJobForAllNamespaces operation.
type ListBatchV1beta1CronJobForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListBatchV1beta1CronJobForAllNamespacesParams(packed map[string]any) (params ListBatchV1beta1CronJobForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListBatchV1beta1CronJobForAllNamespacesParams(args [0]string, r *http.Request) (params ListBatchV1beta1CronJobForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListBatchV1beta1NamespacedCronJobParams is parameters of listBatchV1beta1NamespacedCronJob operation.
type ListBatchV1beta1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params ListBatchV1beta1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListBatchV1beta1NamespacedCronJobParams(args [1]string, r *http.Request) (params ListBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCertificatesV1CertificateSigningRequestParams is parameters of listCertificatesV1CertificateSigningRequest operation.
type ListCertificatesV1CertificateSigningRequestParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params ListCertificatesV1CertificateSigningRequestParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCertificatesV1CertificateSigningRequestParams(args [0]string, r *http.Request) (params ListCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoordinationV1LeaseForAllNamespacesParams is parameters of listCoordinationV1LeaseForAllNamespaces operation.
type ListCoordinationV1LeaseForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoordinationV1LeaseForAllNamespacesParams(packed map[string]any) (params ListCoordinationV1LeaseForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoordinationV1LeaseForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoordinationV1LeaseForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoordinationV1NamespacedLeaseParams is parameters of listCoordinationV1NamespacedLease operation.
type ListCoordinationV1NamespacedLeaseParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoordinationV1NamespacedLeaseParams(packed map[string]any) (params ListCoordinationV1NamespacedLeaseParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoordinationV1NamespacedLeaseParams(args [1]string, r *http.Request) (params ListCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ComponentStatusParams is parameters of listCoreV1ComponentStatus operation.
type ListCoreV1ComponentStatusParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ComponentStatusParams(packed map[string]any) (params ListCoreV1ComponentStatusParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ComponentStatusParams(args [0]string, r *http.Request) (params ListCoreV1ComponentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ConfigMapForAllNamespacesParams is parameters of listCoreV1ConfigMapForAllNamespaces operation.
type ListCoreV1ConfigMapForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ConfigMapForAllNamespacesParams(packed map[string]any) (params ListCoreV1ConfigMapForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ConfigMapForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ConfigMapForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1EndpointsForAllNamespacesParams is parameters of listCoreV1EndpointsForAllNamespaces operation.
type ListCoreV1EndpointsForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1EndpointsForAllNamespacesParams(packed map[string]any) (params ListCoreV1EndpointsForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1EndpointsForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1EndpointsForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1EventForAllNamespacesParams is parameters of listCoreV1EventForAllNamespaces operation.
type ListCoreV1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1EventForAllNamespacesParams(packed map[string]any) (params ListCoreV1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1LimitRangeForAllNamespacesParams is parameters of listCoreV1LimitRangeForAllNamespaces operation.
type ListCoreV1LimitRangeForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1LimitRangeForAllNamespacesParams(packed map[string]any) (params ListCoreV1LimitRangeForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1LimitRangeForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1LimitRangeForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespaceParams is parameters of listCoreV1Namespace operation.
type ListCoreV1NamespaceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespaceParams(packed map[string]any) (params ListCoreV1NamespaceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespaceParams(args [0]string, r *http.Request) (params ListCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedConfigMapParams is parameters of listCoreV1NamespacedConfigMap operation.
type ListCoreV1NamespacedConfigMapParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedConfigMapParams(packed map[string]any) (params ListCoreV1NamespacedConfigMapParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedConfigMapParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedEndpointsParams is parameters of listCoreV1NamespacedEndpoints operation.
type ListCoreV1NamespacedEndpointsParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedEndpointsParams(packed map[string]any) (params ListCoreV1NamespacedEndpointsParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedEndpointsParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedEventParams is parameters of listCoreV1NamespacedEvent operation.
type ListCoreV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedEventParams(packed map[string]any) (params ListCoreV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedEventParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedLimitRangeParams is parameters of listCoreV1NamespacedLimitRange operation.
type ListCoreV1NamespacedLimitRangeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedLimitRangeParams(packed map[string]any) (params ListCoreV1NamespacedLimitRangeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedLimitRangeParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedPersistentVolumeClaimParams is parameters of listCoreV1NamespacedPersistentVolumeClaim operation.
type ListCoreV1NamespacedPersistentVolumeClaimParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params ListCoreV1NamespacedPersistentVolumeClaimParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPersistentVolumeClaimParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedPodParams is parameters of listCoreV1NamespacedPod operation.
type ListCoreV1NamespacedPodParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedPodParams(packed map[string]any) (params ListCoreV1NamespacedPodParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPodParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedPodTemplateParams is parameters of listCoreV1NamespacedPodTemplate operation.
type ListCoreV1NamespacedPodTemplateParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedPodTemplateParams(packed map[string]any) (params ListCoreV1NamespacedPodTemplateParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedPodTemplateParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedReplicationControllerParams is parameters of listCoreV1NamespacedReplicationController operation.
type ListCoreV1NamespacedReplicationControllerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params ListCoreV1NamespacedReplicationControllerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedReplicationControllerParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedResourceQuotaParams is parameters of listCoreV1NamespacedResourceQuota operation.
type ListCoreV1NamespacedResourceQuotaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params ListCoreV1NamespacedResourceQuotaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedResourceQuotaParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedSecretParams is parameters of listCoreV1NamespacedSecret operation.
type ListCoreV1NamespacedSecretParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedSecretParams(packed map[string]any) (params ListCoreV1NamespacedSecretParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedSecretParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedServiceParams is parameters of listCoreV1NamespacedService operation.
type ListCoreV1NamespacedServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedServiceParams(packed map[string]any) (params ListCoreV1NamespacedServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedServiceParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NamespacedServiceAccountParams is parameters of listCoreV1NamespacedServiceAccount operation.
type ListCoreV1NamespacedServiceAccountParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NamespacedServiceAccountParams(packed map[string]any) (params ListCoreV1NamespacedServiceAccountParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NamespacedServiceAccountParams(args [1]string, r *http.Request) (params ListCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1NodeParams is parameters of listCoreV1Node operation.
type ListCoreV1NodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1NodeParams(packed map[string]any) (params ListCoreV1NodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1NodeParams(args [0]string, r *http.Request) (params ListCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1PersistentVolumeParams is parameters of listCoreV1PersistentVolume operation.
type ListCoreV1PersistentVolumeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListCoreV1PersistentVolumeParams(packed map[string]any) (params ListCoreV1PersistentVolumeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListCoreV1PersistentVolumeParams(args [0]string, r *http.Request) (params ListCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1PersistentVolumeClaimForAllNamespacesParams is parameters of listCoreV1PersistentVolumeClaimForAllNamespaces operation.
type ListCoreV1PersistentVolumeClaimForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1PersistentVolumeClaimForAllNamespacesParams(packed map[string]any) (params ListCoreV1PersistentVolumeClaimForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PersistentVolumeClaimForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PersistentVolumeClaimForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1PodForAllNamespacesParams is parameters of listCoreV1PodForAllNamespaces operation.
type ListCoreV1PodForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1PodForAllNamespacesParams(packed map[string]any) (params ListCoreV1PodForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PodForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PodForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1PodTemplateForAllNamespacesParams is parameters of listCoreV1PodTemplateForAllNamespaces operation.
type ListCoreV1PodTemplateForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1PodTemplateForAllNamespacesParams(packed map[string]any) (params ListCoreV1PodTemplateForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1PodTemplateForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1PodTemplateForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ReplicationControllerForAllNamespacesParams is parameters of listCoreV1ReplicationControllerForAllNamespaces operation.
type ListCoreV1ReplicationControllerForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ReplicationControllerForAllNamespacesParams(packed map[string]any) (params ListCoreV1ReplicationControllerForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ReplicationControllerForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ReplicationControllerForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ResourceQuotaForAllNamespacesParams is parameters of listCoreV1ResourceQuotaForAllNamespaces operation.
type ListCoreV1ResourceQuotaForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ResourceQuotaForAllNamespacesParams(packed map[string]any) (params ListCoreV1ResourceQuotaForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ResourceQuotaForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ResourceQuotaForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1SecretForAllNamespacesParams is parameters of listCoreV1SecretForAllNamespaces operation.
type ListCoreV1SecretForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1SecretForAllNamespacesParams(packed map[string]any) (params ListCoreV1SecretForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1SecretForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1SecretForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ServiceAccountForAllNamespacesParams is parameters of listCoreV1ServiceAccountForAllNamespaces operation.
type ListCoreV1ServiceAccountForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ServiceAccountForAllNamespacesParams(packed map[string]any) (params ListCoreV1ServiceAccountForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ServiceAccountForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ServiceAccountForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListCoreV1ServiceForAllNamespacesParams is parameters of listCoreV1ServiceForAllNamespaces operation.
type ListCoreV1ServiceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListCoreV1ServiceForAllNamespacesParams(packed map[string]any) (params ListCoreV1ServiceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListCoreV1ServiceForAllNamespacesParams(args [0]string, r *http.Request) (params ListCoreV1ServiceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListDiscoveryV1EndpointSliceForAllNamespacesParams is parameters of listDiscoveryV1EndpointSliceForAllNamespaces operation.
type ListDiscoveryV1EndpointSliceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListDiscoveryV1EndpointSliceForAllNamespacesParams(packed map[string]any) (params ListDiscoveryV1EndpointSliceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListDiscoveryV1EndpointSliceForAllNamespacesParams(args [0]string, r *http.Request) (params ListDiscoveryV1EndpointSliceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListDiscoveryV1NamespacedEndpointSliceParams is parameters of listDiscoveryV1NamespacedEndpointSlice operation.
type ListDiscoveryV1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params ListDiscoveryV1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListDiscoveryV1NamespacedEndpointSliceParams(args [1]string, r *http.Request) (params ListDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams is parameters of listDiscoveryV1beta1EndpointSliceForAllNamespaces operation.
type ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(packed map[string]any) (params ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(args [0]string, r *http.Request) (params ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListDiscoveryV1beta1NamespacedEndpointSliceParams is parameters of listDiscoveryV1beta1NamespacedEndpointSlice operation.
type ListDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params ListDiscoveryV1beta1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListDiscoveryV1beta1NamespacedEndpointSliceParams(args [1]string, r *http.Request) (params ListDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListEventsV1EventForAllNamespacesParams is parameters of listEventsV1EventForAllNamespaces operation.
type ListEventsV1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListEventsV1EventForAllNamespacesParams(packed map[string]any) (params ListEventsV1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListEventsV1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListEventsV1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListEventsV1NamespacedEventParams is parameters of listEventsV1NamespacedEvent operation.
type ListEventsV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListEventsV1NamespacedEventParams(packed map[string]any) (params ListEventsV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListEventsV1NamespacedEventParams(args [1]string, r *http.Request) (params ListEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListEventsV1beta1EventForAllNamespacesParams is parameters of listEventsV1beta1EventForAllNamespaces operation.
type ListEventsV1beta1EventForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListEventsV1beta1EventForAllNamespacesParams(packed map[string]any) (params ListEventsV1beta1EventForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListEventsV1beta1EventForAllNamespacesParams(args [0]string, r *http.Request) (params ListEventsV1beta1EventForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListEventsV1beta1NamespacedEventParams is parameters of listEventsV1beta1NamespacedEvent operation.
type ListEventsV1beta1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListEventsV1beta1NamespacedEventParams(packed map[string]any) (params ListEventsV1beta1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListEventsV1beta1NamespacedEventParams(args [1]string, r *http.Request) (params ListEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListFlowcontrolApiserverV1beta1FlowSchemaParams is parameters of listFlowcontrolApiserverV1beta1FlowSchema operation.
type ListFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta1FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta1FlowSchemaParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams is parameters of listFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
type ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListFlowcontrolApiserverV1beta2FlowSchemaParams is parameters of listFlowcontrolApiserverV1beta2FlowSchema operation.
type ListFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta2FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta2FlowSchemaParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams is parameters of listFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
type ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [0]string, r *http.Request) (params ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListInternalApiserverV1alpha1StorageVersionParams is parameters of listInternalApiserverV1alpha1StorageVersion operation.
type ListInternalApiserverV1alpha1StorageVersionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params ListInternalApiserverV1alpha1StorageVersionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListInternalApiserverV1alpha1StorageVersionParams(args [0]string, r *http.Request) (params ListInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNetworkingV1IngressClassParams is parameters of listNetworkingV1IngressClass operation.
type ListNetworkingV1IngressClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNetworkingV1IngressClassParams(packed map[string]any) (params ListNetworkingV1IngressClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1IngressClassParams(args [0]string, r *http.Request) (params ListNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNetworkingV1IngressForAllNamespacesParams is parameters of listNetworkingV1IngressForAllNamespaces operation.
type ListNetworkingV1IngressForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListNetworkingV1IngressForAllNamespacesParams(packed map[string]any) (params ListNetworkingV1IngressForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListNetworkingV1IngressForAllNamespacesParams(args [0]string, r *http.Request) (params ListNetworkingV1IngressForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListNetworkingV1NamespacedIngressParams is parameters of listNetworkingV1NamespacedIngress operation.
type ListNetworkingV1NamespacedIngressParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNetworkingV1NamespacedIngressParams(packed map[string]any) (params ListNetworkingV1NamespacedIngressParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1NamespacedIngressParams(args [1]string, r *http.Request) (params ListNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNetworkingV1NamespacedNetworkPolicyParams is parameters of listNetworkingV1NamespacedNetworkPolicy operation.
type ListNetworkingV1NamespacedNetworkPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params ListNetworkingV1NamespacedNetworkPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNetworkingV1NamespacedNetworkPolicyParams(args [1]string, r *http.Request) (params ListNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNetworkingV1NetworkPolicyForAllNamespacesParams is parameters of listNetworkingV1NetworkPolicyForAllNamespaces operation.
type ListNetworkingV1NetworkPolicyForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListNetworkingV1NetworkPolicyForAllNamespacesParams(packed map[string]any) (params ListNetworkingV1NetworkPolicyForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListNetworkingV1NetworkPolicyForAllNamespacesParams(args [0]string, r *http.Request) (params ListNetworkingV1NetworkPolicyForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListNodeV1RuntimeClassParams is parameters of listNodeV1RuntimeClass operation.
type ListNodeV1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNodeV1RuntimeClassParams(packed map[string]any) (params ListNodeV1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNodeV1alpha1RuntimeClassParams is parameters of listNodeV1alpha1RuntimeClass operation.
type ListNodeV1alpha1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNodeV1alpha1RuntimeClassParams(packed map[string]any) (params ListNodeV1alpha1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1alpha1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListNodeV1beta1RuntimeClassParams is parameters of listNodeV1beta1RuntimeClass operation.
type ListNodeV1beta1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListNodeV1beta1RuntimeClassParams(packed map[string]any) (params ListNodeV1beta1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListNodeV1beta1RuntimeClassParams(args [0]string, r *http.Request) (params ListNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListPolicyV1NamespacedPodDisruptionBudgetParams is parameters of listPolicyV1NamespacedPodDisruptionBudget operation.
type ListPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ListPolicyV1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1NamespacedPodDisruptionBudgetParams(args [1]string, r *http.Request) (params ListPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListPolicyV1PodDisruptionBudgetForAllNamespacesParams is parameters of listPolicyV1PodDisruptionBudgetForAllNamespaces operation.
type ListPolicyV1PodDisruptionBudgetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListPolicyV1PodDisruptionBudgetForAllNamespacesParams(packed map[string]any) (params ListPolicyV1PodDisruptionBudgetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListPolicyV1PodDisruptionBudgetForAllNamespacesParams(args [0]string, r *http.Request) (params ListPolicyV1PodDisruptionBudgetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListPolicyV1beta1NamespacedPodDisruptionBudgetParams is parameters of listPolicyV1beta1NamespacedPodDisruptionBudget operation.
type ListPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ListPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [1]string, r *http.Request) (params ListPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams is parameters of listPolicyV1beta1PodDisruptionBudgetForAllNamespaces operation.
type ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(packed map[string]any) (params ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(args [0]string, r *http.Request) (params ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListPolicyV1beta1PodSecurityPolicyParams is parameters of listPolicyV1beta1PodSecurityPolicy operation.
type ListPolicyV1beta1PodSecurityPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params ListPolicyV1beta1PodSecurityPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListPolicyV1beta1PodSecurityPolicyParams(args [0]string, r *http.Request) (params ListPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1ClusterRoleParams is parameters of listRbacAuthorizationV1ClusterRole operation.
type ListRbacAuthorizationV1ClusterRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params ListRbacAuthorizationV1ClusterRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1ClusterRoleParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1ClusterRoleBindingParams is parameters of listRbacAuthorizationV1ClusterRoleBinding operation.
type ListRbacAuthorizationV1ClusterRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params ListRbacAuthorizationV1ClusterRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1ClusterRoleBindingParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1NamespacedRoleParams is parameters of listRbacAuthorizationV1NamespacedRole operation.
type ListRbacAuthorizationV1NamespacedRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params ListRbacAuthorizationV1NamespacedRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1NamespacedRoleParams(args [1]string, r *http.Request) (params ListRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1NamespacedRoleBindingParams is parameters of listRbacAuthorizationV1NamespacedRoleBinding operation.
type ListRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params ListRbacAuthorizationV1NamespacedRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListRbacAuthorizationV1NamespacedRoleBindingParams(args [1]string, r *http.Request) (params ListRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1RoleBindingForAllNamespacesParams is parameters of listRbacAuthorizationV1RoleBindingForAllNamespaces operation.
type ListRbacAuthorizationV1RoleBindingForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListRbacAuthorizationV1RoleBindingForAllNamespacesParams(packed map[string]any) (params ListRbacAuthorizationV1RoleBindingForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListRbacAuthorizationV1RoleBindingForAllNamespacesParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1RoleBindingForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListRbacAuthorizationV1RoleForAllNamespacesParams is parameters of listRbacAuthorizationV1RoleForAllNamespaces operation.
type ListRbacAuthorizationV1RoleForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListRbacAuthorizationV1RoleForAllNamespacesParams(packed map[string]any) (params ListRbacAuthorizationV1RoleForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListRbacAuthorizationV1RoleForAllNamespacesParams(args [0]string, r *http.Request) (params ListRbacAuthorizationV1RoleForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListSchedulingV1PriorityClassParams is parameters of listSchedulingV1PriorityClass operation.
type ListSchedulingV1PriorityClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListSchedulingV1PriorityClassParams(packed map[string]any) (params ListSchedulingV1PriorityClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListSchedulingV1PriorityClassParams(args [0]string, r *http.Request) (params ListSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1CSIDriverParams is parameters of listStorageV1CSIDriver operation.
type ListStorageV1CSIDriverParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1CSIDriverParams(packed map[string]any) (params ListStorageV1CSIDriverParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1CSIDriverParams(args [0]string, r *http.Request) (params ListStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1CSINodeParams is parameters of listStorageV1CSINode operation.
type ListStorageV1CSINodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1CSINodeParams(packed map[string]any) (params ListStorageV1CSINodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1CSINodeParams(args [0]string, r *http.Request) (params ListStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1StorageClassParams is parameters of listStorageV1StorageClass operation.
type ListStorageV1StorageClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1StorageClassParams(packed map[string]any) (params ListStorageV1StorageClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1StorageClassParams(args [0]string, r *http.Request) (params ListStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1VolumeAttachmentParams is parameters of listStorageV1VolumeAttachment operation.
type ListStorageV1VolumeAttachmentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1VolumeAttachmentParams(packed map[string]any) (params ListStorageV1VolumeAttachmentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1VolumeAttachmentParams(args [0]string, r *http.Request) (params ListStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams is parameters of listStorageV1alpha1CSIStorageCapacityForAllNamespaces operation.
type ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(packed map[string]any) (params ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(args [0]string, r *http.Request) (params ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1alpha1NamespacedCSIStorageCapacityParams is parameters of listStorageV1alpha1NamespacedCSIStorageCapacity operation.
type ListStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ListStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1alpha1NamespacedCSIStorageCapacityParams(args [1]string, r *http.Request) (params ListStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams is parameters of listStorageV1beta1CSIStorageCapacityForAllNamespaces operation.
type ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(packed map[string]any) (params ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(args [0]string, r *http.Request) (params ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// ListStorageV1beta1NamespacedCSIStorageCapacityParams is parameters of listStorageV1beta1NamespacedCSIStorageCapacity operation.
type ListStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackListStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ListStorageV1beta1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeListStorageV1beta1NamespacedCSIStorageCapacityParams(args [1]string, r *http.Request) (params ListStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// LogFileHandlerParams is parameters of logFileHandler operation.
type LogFileHandlerParams struct {
	// Path to the log.
	Logpath string
}

func unpackLogFileHandlerParams(packed map[string]any) (params LogFileHandlerParams) {
	params.Logpath = packed["logpath"].(string)
	return params
}

func decodeLogFileHandlerParams(args [1]string, r *http.Request) (params LogFileHandlerParams, _ error) {
	// Decode path: logpath.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "logpath",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Logpath = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: logpath: parse")
			}
		} else {
			return params, errors.New("path: logpath: not specified")
		}
	}
	return params, nil
}

// ReadAdmissionregistrationV1MutatingWebhookConfigurationParams is parameters of readAdmissionregistrationV1MutatingWebhookConfiguration operation.
type ReadAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// Name of the MutatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params ReadAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAdmissionregistrationV1MutatingWebhookConfigurationParams(args [1]string, r *http.Request) (params ReadAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams is parameters of readAdmissionregistrationV1ValidatingWebhookConfiguration operation.
type ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// Name of the ValidatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [1]string, r *http.Request) (params ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadApiextensionsV1CustomResourceDefinitionParams is parameters of readApiextensionsV1CustomResourceDefinition operation.
type ReadApiextensionsV1CustomResourceDefinitionParams struct {
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params ReadApiextensionsV1CustomResourceDefinitionParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiextensionsV1CustomResourceDefinitionParams(args [1]string, r *http.Request) (params ReadApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadApiextensionsV1CustomResourceDefinitionStatusParams is parameters of readApiextensionsV1CustomResourceDefinitionStatus operation.
type ReadApiextensionsV1CustomResourceDefinitionStatusParams struct {
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadApiextensionsV1CustomResourceDefinitionStatusParams(packed map[string]any) (params ReadApiextensionsV1CustomResourceDefinitionStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiextensionsV1CustomResourceDefinitionStatusParams(args [1]string, r *http.Request) (params ReadApiextensionsV1CustomResourceDefinitionStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadApiregistrationV1APIServiceParams is parameters of readApiregistrationV1APIService operation.
type ReadApiregistrationV1APIServiceParams struct {
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadApiregistrationV1APIServiceParams(packed map[string]any) (params ReadApiregistrationV1APIServiceParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiregistrationV1APIServiceParams(args [1]string, r *http.Request) (params ReadApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadApiregistrationV1APIServiceStatusParams is parameters of readApiregistrationV1APIServiceStatus operation.
type ReadApiregistrationV1APIServiceStatusParams struct {
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadApiregistrationV1APIServiceStatusParams(packed map[string]any) (params ReadApiregistrationV1APIServiceStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadApiregistrationV1APIServiceStatusParams(args [1]string, r *http.Request) (params ReadApiregistrationV1APIServiceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedControllerRevisionParams is parameters of readAppsV1NamespacedControllerRevision operation.
type ReadAppsV1NamespacedControllerRevisionParams struct {
	// Name of the ControllerRevision.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params ReadAppsV1NamespacedControllerRevisionParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedControllerRevisionParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedDaemonSetParams is parameters of readAppsV1NamespacedDaemonSet operation.
type ReadAppsV1NamespacedDaemonSetParams struct {
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedDaemonSetParams(packed map[string]any) (params ReadAppsV1NamespacedDaemonSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDaemonSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedDaemonSetStatusParams is parameters of readAppsV1NamespacedDaemonSetStatus operation.
type ReadAppsV1NamespacedDaemonSetStatusParams struct {
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedDaemonSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedDaemonSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDaemonSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDaemonSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedDeploymentParams is parameters of readAppsV1NamespacedDeployment operation.
type ReadAppsV1NamespacedDeploymentParams struct {
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedDeploymentParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedDeploymentScaleParams is parameters of readAppsV1NamespacedDeploymentScale operation.
type ReadAppsV1NamespacedDeploymentScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedDeploymentScaleParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedDeploymentStatusParams is parameters of readAppsV1NamespacedDeploymentStatus operation.
type ReadAppsV1NamespacedDeploymentStatusParams struct {
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedDeploymentStatusParams(packed map[string]any) (params ReadAppsV1NamespacedDeploymentStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedDeploymentStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedDeploymentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedReplicaSetParams is parameters of readAppsV1NamespacedReplicaSet operation.
type ReadAppsV1NamespacedReplicaSetParams struct {
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedReplicaSetParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedReplicaSetScaleParams is parameters of readAppsV1NamespacedReplicaSetScale operation.
type ReadAppsV1NamespacedReplicaSetScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedReplicaSetScaleParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedReplicaSetStatusParams is parameters of readAppsV1NamespacedReplicaSetStatus operation.
type ReadAppsV1NamespacedReplicaSetStatusParams struct {
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedReplicaSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedReplicaSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedReplicaSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedReplicaSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedStatefulSetParams is parameters of readAppsV1NamespacedStatefulSet operation.
type ReadAppsV1NamespacedStatefulSetParams struct {
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedStatefulSetParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedStatefulSetScaleParams is parameters of readAppsV1NamespacedStatefulSetScale operation.
type ReadAppsV1NamespacedStatefulSetScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedStatefulSetScaleParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetScaleParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAppsV1NamespacedStatefulSetStatusParams is parameters of readAppsV1NamespacedStatefulSetStatus operation.
type ReadAppsV1NamespacedStatefulSetStatusParams struct {
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAppsV1NamespacedStatefulSetStatusParams(packed map[string]any) (params ReadAppsV1NamespacedStatefulSetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAppsV1NamespacedStatefulSetStatusParams(args [2]string, r *http.Request) (params ReadAppsV1NamespacedStatefulSetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams is parameters of readAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
type ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams is parameters of readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus operation.
type ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams is parameters of readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
type ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams is parameters of readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus operation.
type ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams is parameters of readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
type ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams is parameters of readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus operation.
type ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams struct {
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(packed map[string]any) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(args [2]string, r *http.Request) (params ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1NamespacedCronJobParams is parameters of readBatchV1NamespacedCronJob operation.
type ReadBatchV1NamespacedCronJobParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1NamespacedCronJobParams(packed map[string]any) (params ReadBatchV1NamespacedCronJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedCronJobParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1NamespacedCronJobStatusParams is parameters of readBatchV1NamespacedCronJobStatus operation.
type ReadBatchV1NamespacedCronJobStatusParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1NamespacedCronJobStatusParams(packed map[string]any) (params ReadBatchV1NamespacedCronJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedCronJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedCronJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1NamespacedJobParams is parameters of readBatchV1NamespacedJob operation.
type ReadBatchV1NamespacedJobParams struct {
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1NamespacedJobParams(packed map[string]any) (params ReadBatchV1NamespacedJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedJobParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1NamespacedJobStatusParams is parameters of readBatchV1NamespacedJobStatus operation.
type ReadBatchV1NamespacedJobStatusParams struct {
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1NamespacedJobStatusParams(packed map[string]any) (params ReadBatchV1NamespacedJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1NamespacedJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1NamespacedJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1beta1NamespacedCronJobParams is parameters of readBatchV1beta1NamespacedCronJob operation.
type ReadBatchV1beta1NamespacedCronJobParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params ReadBatchV1beta1NamespacedCronJobParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1beta1NamespacedCronJobParams(args [2]string, r *http.Request) (params ReadBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadBatchV1beta1NamespacedCronJobStatusParams is parameters of readBatchV1beta1NamespacedCronJobStatus operation.
type ReadBatchV1beta1NamespacedCronJobStatusParams struct {
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadBatchV1beta1NamespacedCronJobStatusParams(packed map[string]any) (params ReadBatchV1beta1NamespacedCronJobStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadBatchV1beta1NamespacedCronJobStatusParams(args [2]string, r *http.Request) (params ReadBatchV1beta1NamespacedCronJobStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCertificatesV1CertificateSigningRequestParams is parameters of readCertificatesV1CertificateSigningRequest operation.
type ReadCertificatesV1CertificateSigningRequestParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCertificatesV1CertificateSigningRequestApprovalParams is parameters of readCertificatesV1CertificateSigningRequestApproval operation.
type ReadCertificatesV1CertificateSigningRequestApprovalParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCertificatesV1CertificateSigningRequestApprovalParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestApprovalParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestApprovalParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestApprovalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCertificatesV1CertificateSigningRequestStatusParams is parameters of readCertificatesV1CertificateSigningRequestStatus operation.
type ReadCertificatesV1CertificateSigningRequestStatusParams struct {
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCertificatesV1CertificateSigningRequestStatusParams(packed map[string]any) (params ReadCertificatesV1CertificateSigningRequestStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCertificatesV1CertificateSigningRequestStatusParams(args [1]string, r *http.Request) (params ReadCertificatesV1CertificateSigningRequestStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoordinationV1NamespacedLeaseParams is parameters of readCoordinationV1NamespacedLease operation.
type ReadCoordinationV1NamespacedLeaseParams struct {
	// Name of the Lease.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoordinationV1NamespacedLeaseParams(packed map[string]any) (params ReadCoordinationV1NamespacedLeaseParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoordinationV1NamespacedLeaseParams(args [2]string, r *http.Request) (params ReadCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1ComponentStatusParams is parameters of readCoreV1ComponentStatus operation.
type ReadCoreV1ComponentStatusParams struct {
	// Name of the ComponentStatus.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1ComponentStatusParams(packed map[string]any) (params ReadCoreV1ComponentStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1ComponentStatusParams(args [1]string, r *http.Request) (params ReadCoreV1ComponentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespaceParams is parameters of readCoreV1Namespace operation.
type ReadCoreV1NamespaceParams struct {
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespaceParams(packed map[string]any) (params ReadCoreV1NamespaceParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespaceParams(args [1]string, r *http.Request) (params ReadCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespaceStatusParams is parameters of readCoreV1NamespaceStatus operation.
type ReadCoreV1NamespaceStatusParams struct {
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespaceStatusParams(packed map[string]any) (params ReadCoreV1NamespaceStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespaceStatusParams(args [1]string, r *http.Request) (params ReadCoreV1NamespaceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedConfigMapParams is parameters of readCoreV1NamespacedConfigMap operation.
type ReadCoreV1NamespacedConfigMapParams struct {
	// Name of the ConfigMap.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedConfigMapParams(packed map[string]any) (params ReadCoreV1NamespacedConfigMapParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedConfigMapParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedEndpointsParams is parameters of readCoreV1NamespacedEndpoints operation.
type ReadCoreV1NamespacedEndpointsParams struct {
	// Name of the Endpoints.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedEndpointsParams(packed map[string]any) (params ReadCoreV1NamespacedEndpointsParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedEndpointsParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedEventParams is parameters of readCoreV1NamespacedEvent operation.
type ReadCoreV1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedEventParams(packed map[string]any) (params ReadCoreV1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedEventParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedLimitRangeParams is parameters of readCoreV1NamespacedLimitRange operation.
type ReadCoreV1NamespacedLimitRangeParams struct {
	// Name of the LimitRange.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedLimitRangeParams(packed map[string]any) (params ReadCoreV1NamespacedLimitRangeParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedLimitRangeParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPersistentVolumeClaimParams is parameters of readCoreV1NamespacedPersistentVolumeClaim operation.
type ReadCoreV1NamespacedPersistentVolumeClaimParams struct {
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params ReadCoreV1NamespacedPersistentVolumeClaimParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPersistentVolumeClaimParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPersistentVolumeClaimStatusParams is parameters of readCoreV1NamespacedPersistentVolumeClaimStatus operation.
type ReadCoreV1NamespacedPersistentVolumeClaimStatusParams struct {
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPersistentVolumeClaimStatusParams(packed map[string]any) (params ReadCoreV1NamespacedPersistentVolumeClaimStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPersistentVolumeClaimStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPersistentVolumeClaimStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPodParams is parameters of readCoreV1NamespacedPod operation.
type ReadCoreV1NamespacedPodParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPodParams(packed map[string]any) (params ReadCoreV1NamespacedPodParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPodEphemeralcontainersParams is parameters of readCoreV1NamespacedPodEphemeralcontainers operation.
type ReadCoreV1NamespacedPodEphemeralcontainersParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPodEphemeralcontainersParams(packed map[string]any) (params ReadCoreV1NamespacedPodEphemeralcontainersParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodEphemeralcontainersParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodEphemeralcontainersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPodLogParams is parameters of readCoreV1NamespacedPodLog operation.
type ReadCoreV1NamespacedPodLogParams struct {
	// The container for which to stream logs. Defaults to only container if there is one container in
	// the pod.
	Container OptString `json:",omitempty"`
	// Follow the log stream of the pod. Defaults to false.
	Follow OptBool `json:",omitempty"`
	// InsecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
	// serving certificate of the backend it is connecting to.  This will make the HTTPS connection
	// between the apiserver and the backend insecure. This means the apiserver cannot verify the log
	// data it is receiving came from the real kubelet.  If the kubelet is configured to verify the
	// apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to
	// a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from
	// the real kubelet).
	InsecureSkipTLSVerifyBackend OptBool `json:",omitempty"`
	// If set, the number of bytes to read from the server before terminating the log output. This may
	// not display a complete final line of logging, and may return slightly more or slightly less than
	// the specified limit.
	LimitBytes OptInt `json:",omitempty"`
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// Return previous terminated container logs. Defaults to false.
	Previous OptBool `json:",omitempty"`
	// A relative time in seconds before the current time from which to show logs. If this value precedes
	// the time a pod was started, only logs since the pod start will be returned. If this value is in
	// the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
	SinceSeconds OptInt `json:",omitempty"`
	// If set, the number of lines from the end of the logs to show. If not specified, logs are shown
	// from the creation of the container or sinceSeconds or sinceTime.
	TailLines OptInt `json:",omitempty"`
	// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output.
	// Defaults to false.
	Timestamps OptBool `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPodLogParams(packed map[string]any) (params ReadCoreV1NamespacedPodLogParams) {
	if v, ok := packed["container"]; ok {
		params.Container = v.(OptString)
	}
	if v, ok := packed["follow"]; ok {
		params.Follow = v.(OptBool)
	}
	if v, ok := packed["insecureSkipTLSVerifyBackend"]; ok {
		params.InsecureSkipTLSVerifyBackend = v.(OptBool)
	}
	if v, ok := packed["limitBytes"]; ok {
		params.LimitBytes = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["previous"]; ok {
		params.Previous = v.(OptBool)
	}
	if v, ok := packed["sinceSeconds"]; ok {
		params.SinceSeconds = v.(OptInt)
	}
	if v, ok := packed["tailLines"]; ok {
		params.TailLines = v.(OptInt)
	}
	if v, ok := packed["timestamps"]; ok {
		params.Timestamps = v.(OptBool)
	}
	return params
}

func decodeReadCoreV1NamespacedPodLogParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: container.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "container",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContainerVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContainerVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Container.SetTo(paramsDotContainerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: container: parse")
			}
		}
	}
	// Decode query: follow.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "follow",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFollowVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFollowVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Follow.SetTo(paramsDotFollowVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: follow: parse")
			}
		}
	}
	// Decode query: insecureSkipTLSVerifyBackend.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "insecureSkipTLSVerifyBackend",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotInsecureSkipTLSVerifyBackendVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotInsecureSkipTLSVerifyBackendVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.InsecureSkipTLSVerifyBackend.SetTo(paramsDotInsecureSkipTLSVerifyBackendVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: insecureSkipTLSVerifyBackend: parse")
			}
		}
	}
	// Decode query: limitBytes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limitBytes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitBytesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitBytesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LimitBytes.SetTo(paramsDotLimitBytesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limitBytes: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: previous.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "previous",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPreviousVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotPreviousVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Previous.SetTo(paramsDotPreviousVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: previous: parse")
			}
		}
	}
	// Decode query: sinceSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sinceSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SinceSeconds.SetTo(paramsDotSinceSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sinceSeconds: parse")
			}
		}
	}
	// Decode query: tailLines.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tailLines",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTailLinesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTailLinesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TailLines.SetTo(paramsDotTailLinesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tailLines: parse")
			}
		}
	}
	// Decode query: timestamps.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamps",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotTimestampsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamps.SetTo(paramsDotTimestampsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timestamps: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPodStatusParams is parameters of readCoreV1NamespacedPodStatus operation.
type ReadCoreV1NamespacedPodStatusParams struct {
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPodStatusParams(packed map[string]any) (params ReadCoreV1NamespacedPodStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedPodTemplateParams is parameters of readCoreV1NamespacedPodTemplate operation.
type ReadCoreV1NamespacedPodTemplateParams struct {
	// Name of the PodTemplate.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedPodTemplateParams(packed map[string]any) (params ReadCoreV1NamespacedPodTemplateParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedPodTemplateParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedReplicationControllerParams is parameters of readCoreV1NamespacedReplicationController operation.
type ReadCoreV1NamespacedReplicationControllerParams struct {
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedReplicationControllerScaleParams is parameters of readCoreV1NamespacedReplicationControllerScale operation.
type ReadCoreV1NamespacedReplicationControllerScaleParams struct {
	// Name of the Scale.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedReplicationControllerScaleParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerScaleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerScaleParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerScaleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedReplicationControllerStatusParams is parameters of readCoreV1NamespacedReplicationControllerStatus operation.
type ReadCoreV1NamespacedReplicationControllerStatusParams struct {
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedReplicationControllerStatusParams(packed map[string]any) (params ReadCoreV1NamespacedReplicationControllerStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedReplicationControllerStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedReplicationControllerStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedResourceQuotaParams is parameters of readCoreV1NamespacedResourceQuota operation.
type ReadCoreV1NamespacedResourceQuotaParams struct {
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params ReadCoreV1NamespacedResourceQuotaParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedResourceQuotaParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedResourceQuotaStatusParams is parameters of readCoreV1NamespacedResourceQuotaStatus operation.
type ReadCoreV1NamespacedResourceQuotaStatusParams struct {
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedResourceQuotaStatusParams(packed map[string]any) (params ReadCoreV1NamespacedResourceQuotaStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedResourceQuotaStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedResourceQuotaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedSecretParams is parameters of readCoreV1NamespacedSecret operation.
type ReadCoreV1NamespacedSecretParams struct {
	// Name of the Secret.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedSecretParams(packed map[string]any) (params ReadCoreV1NamespacedSecretParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedSecretParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedServiceParams is parameters of readCoreV1NamespacedService operation.
type ReadCoreV1NamespacedServiceParams struct {
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedServiceParams(packed map[string]any) (params ReadCoreV1NamespacedServiceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedServiceAccountParams is parameters of readCoreV1NamespacedServiceAccount operation.
type ReadCoreV1NamespacedServiceAccountParams struct {
	// Name of the ServiceAccount.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedServiceAccountParams(packed map[string]any) (params ReadCoreV1NamespacedServiceAccountParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceAccountParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NamespacedServiceStatusParams is parameters of readCoreV1NamespacedServiceStatus operation.
type ReadCoreV1NamespacedServiceStatusParams struct {
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NamespacedServiceStatusParams(packed map[string]any) (params ReadCoreV1NamespacedServiceStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NamespacedServiceStatusParams(args [2]string, r *http.Request) (params ReadCoreV1NamespacedServiceStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NodeParams is parameters of readCoreV1Node operation.
type ReadCoreV1NodeParams struct {
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NodeParams(packed map[string]any) (params ReadCoreV1NodeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NodeParams(args [1]string, r *http.Request) (params ReadCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1NodeStatusParams is parameters of readCoreV1NodeStatus operation.
type ReadCoreV1NodeStatusParams struct {
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1NodeStatusParams(packed map[string]any) (params ReadCoreV1NodeStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1NodeStatusParams(args [1]string, r *http.Request) (params ReadCoreV1NodeStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1PersistentVolumeParams is parameters of readCoreV1PersistentVolume operation.
type ReadCoreV1PersistentVolumeParams struct {
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1PersistentVolumeParams(packed map[string]any) (params ReadCoreV1PersistentVolumeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1PersistentVolumeParams(args [1]string, r *http.Request) (params ReadCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadCoreV1PersistentVolumeStatusParams is parameters of readCoreV1PersistentVolumeStatus operation.
type ReadCoreV1PersistentVolumeStatusParams struct {
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadCoreV1PersistentVolumeStatusParams(packed map[string]any) (params ReadCoreV1PersistentVolumeStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadCoreV1PersistentVolumeStatusParams(args [1]string, r *http.Request) (params ReadCoreV1PersistentVolumeStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadDiscoveryV1NamespacedEndpointSliceParams is parameters of readDiscoveryV1NamespacedEndpointSlice operation.
type ReadDiscoveryV1NamespacedEndpointSliceParams struct {
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params ReadDiscoveryV1NamespacedEndpointSliceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadDiscoveryV1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params ReadDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadDiscoveryV1beta1NamespacedEndpointSliceParams is parameters of readDiscoveryV1beta1NamespacedEndpointSlice operation.
type ReadDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params ReadDiscoveryV1beta1NamespacedEndpointSliceParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadDiscoveryV1beta1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params ReadDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadEventsV1NamespacedEventParams is parameters of readEventsV1NamespacedEvent operation.
type ReadEventsV1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadEventsV1NamespacedEventParams(packed map[string]any) (params ReadEventsV1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadEventsV1NamespacedEventParams(args [2]string, r *http.Request) (params ReadEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadEventsV1beta1NamespacedEventParams is parameters of readEventsV1beta1NamespacedEvent operation.
type ReadEventsV1beta1NamespacedEventParams struct {
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadEventsV1beta1NamespacedEventParams(packed map[string]any) (params ReadEventsV1beta1NamespacedEventParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadEventsV1beta1NamespacedEventParams(args [2]string, r *http.Request) (params ReadEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta1FlowSchemaParams is parameters of readFlowcontrolApiserverV1beta1FlowSchema operation.
type ReadFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1FlowSchemaParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1FlowSchemaParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams is parameters of readFlowcontrolApiserverV1beta1FlowSchemaStatus operation.
type ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams is parameters of readFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
type ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams is parameters of readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus operation.
type ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta2FlowSchemaParams is parameters of readFlowcontrolApiserverV1beta2FlowSchema operation.
type ReadFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2FlowSchemaParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2FlowSchemaParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams is parameters of readFlowcontrolApiserverV1beta2FlowSchemaStatus operation.
type ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams struct {
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams is parameters of readFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
type ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams is parameters of readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus operation.
type ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams struct {
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(packed map[string]any) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(args [1]string, r *http.Request) (params ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadInternalApiserverV1alpha1StorageVersionParams is parameters of readInternalApiserverV1alpha1StorageVersion operation.
type ReadInternalApiserverV1alpha1StorageVersionParams struct {
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params ReadInternalApiserverV1alpha1StorageVersionParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadInternalApiserverV1alpha1StorageVersionParams(args [1]string, r *http.Request) (params ReadInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadInternalApiserverV1alpha1StorageVersionStatusParams is parameters of readInternalApiserverV1alpha1StorageVersionStatus operation.
type ReadInternalApiserverV1alpha1StorageVersionStatusParams struct {
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadInternalApiserverV1alpha1StorageVersionStatusParams(packed map[string]any) (params ReadInternalApiserverV1alpha1StorageVersionStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadInternalApiserverV1alpha1StorageVersionStatusParams(args [1]string, r *http.Request) (params ReadInternalApiserverV1alpha1StorageVersionStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNetworkingV1IngressClassParams is parameters of readNetworkingV1IngressClass operation.
type ReadNetworkingV1IngressClassParams struct {
	// Name of the IngressClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNetworkingV1IngressClassParams(packed map[string]any) (params ReadNetworkingV1IngressClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1IngressClassParams(args [1]string, r *http.Request) (params ReadNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNetworkingV1NamespacedIngressParams is parameters of readNetworkingV1NamespacedIngress operation.
type ReadNetworkingV1NamespacedIngressParams struct {
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNetworkingV1NamespacedIngressParams(packed map[string]any) (params ReadNetworkingV1NamespacedIngressParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedIngressParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNetworkingV1NamespacedIngressStatusParams is parameters of readNetworkingV1NamespacedIngressStatus operation.
type ReadNetworkingV1NamespacedIngressStatusParams struct {
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNetworkingV1NamespacedIngressStatusParams(packed map[string]any) (params ReadNetworkingV1NamespacedIngressStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedIngressStatusParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedIngressStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNetworkingV1NamespacedNetworkPolicyParams is parameters of readNetworkingV1NamespacedNetworkPolicy operation.
type ReadNetworkingV1NamespacedNetworkPolicyParams struct {
	// Name of the NetworkPolicy.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params ReadNetworkingV1NamespacedNetworkPolicyParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNetworkingV1NamespacedNetworkPolicyParams(args [2]string, r *http.Request) (params ReadNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNodeV1RuntimeClassParams is parameters of readNodeV1RuntimeClass operation.
type ReadNodeV1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNodeV1RuntimeClassParams(packed map[string]any) (params ReadNodeV1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNodeV1alpha1RuntimeClassParams is parameters of readNodeV1alpha1RuntimeClass operation.
type ReadNodeV1alpha1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNodeV1alpha1RuntimeClassParams(packed map[string]any) (params ReadNodeV1alpha1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1alpha1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadNodeV1beta1RuntimeClassParams is parameters of readNodeV1beta1RuntimeClass operation.
type ReadNodeV1beta1RuntimeClassParams struct {
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadNodeV1beta1RuntimeClassParams(packed map[string]any) (params ReadNodeV1beta1RuntimeClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadNodeV1beta1RuntimeClassParams(args [1]string, r *http.Request) (params ReadNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadPolicyV1NamespacedPodDisruptionBudgetParams is parameters of readPolicyV1NamespacedPodDisruptionBudget operation.
type ReadPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ReadPolicyV1NamespacedPodDisruptionBudgetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params ReadPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams is parameters of readPolicyV1NamespacedPodDisruptionBudgetStatus operation.
type ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(packed map[string]any) (params ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(args [2]string, r *http.Request) (params ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams is parameters of readPolicyV1beta1NamespacedPodDisruptionBudget operation.
type ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams is parameters of readPolicyV1beta1NamespacedPodDisruptionBudgetStatus operation.
type ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams struct {
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(packed map[string]any) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(args [2]string, r *http.Request) (params ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadPolicyV1beta1PodSecurityPolicyParams is parameters of readPolicyV1beta1PodSecurityPolicy operation.
type ReadPolicyV1beta1PodSecurityPolicyParams struct {
	// Name of the PodSecurityPolicy.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params ReadPolicyV1beta1PodSecurityPolicyParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadPolicyV1beta1PodSecurityPolicyParams(args [1]string, r *http.Request) (params ReadPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadRbacAuthorizationV1ClusterRoleParams is parameters of readRbacAuthorizationV1ClusterRole operation.
type ReadRbacAuthorizationV1ClusterRoleParams struct {
	// Name of the ClusterRole.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params ReadRbacAuthorizationV1ClusterRoleParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1ClusterRoleParams(args [1]string, r *http.Request) (params ReadRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadRbacAuthorizationV1ClusterRoleBindingParams is parameters of readRbacAuthorizationV1ClusterRoleBinding operation.
type ReadRbacAuthorizationV1ClusterRoleBindingParams struct {
	// Name of the ClusterRoleBinding.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params ReadRbacAuthorizationV1ClusterRoleBindingParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1ClusterRoleBindingParams(args [1]string, r *http.Request) (params ReadRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadRbacAuthorizationV1NamespacedRoleParams is parameters of readRbacAuthorizationV1NamespacedRole operation.
type ReadRbacAuthorizationV1NamespacedRoleParams struct {
	// Name of the Role.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params ReadRbacAuthorizationV1NamespacedRoleParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1NamespacedRoleParams(args [2]string, r *http.Request) (params ReadRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadRbacAuthorizationV1NamespacedRoleBindingParams is parameters of readRbacAuthorizationV1NamespacedRoleBinding operation.
type ReadRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// Name of the RoleBinding.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params ReadRbacAuthorizationV1NamespacedRoleBindingParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadRbacAuthorizationV1NamespacedRoleBindingParams(args [2]string, r *http.Request) (params ReadRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadSchedulingV1PriorityClassParams is parameters of readSchedulingV1PriorityClass operation.
type ReadSchedulingV1PriorityClassParams struct {
	// Name of the PriorityClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadSchedulingV1PriorityClassParams(packed map[string]any) (params ReadSchedulingV1PriorityClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadSchedulingV1PriorityClassParams(args [1]string, r *http.Request) (params ReadSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1CSIDriverParams is parameters of readStorageV1CSIDriver operation.
type ReadStorageV1CSIDriverParams struct {
	// Name of the CSIDriver.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1CSIDriverParams(packed map[string]any) (params ReadStorageV1CSIDriverParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1CSIDriverParams(args [1]string, r *http.Request) (params ReadStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1CSINodeParams is parameters of readStorageV1CSINode operation.
type ReadStorageV1CSINodeParams struct {
	// Name of the CSINode.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1CSINodeParams(packed map[string]any) (params ReadStorageV1CSINodeParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1CSINodeParams(args [1]string, r *http.Request) (params ReadStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1StorageClassParams is parameters of readStorageV1StorageClass operation.
type ReadStorageV1StorageClassParams struct {
	// Name of the StorageClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1StorageClassParams(packed map[string]any) (params ReadStorageV1StorageClassParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1StorageClassParams(args [1]string, r *http.Request) (params ReadStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1VolumeAttachmentParams is parameters of readStorageV1VolumeAttachment operation.
type ReadStorageV1VolumeAttachmentParams struct {
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1VolumeAttachmentParams(packed map[string]any) (params ReadStorageV1VolumeAttachmentParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1VolumeAttachmentParams(args [1]string, r *http.Request) (params ReadStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1VolumeAttachmentStatusParams is parameters of readStorageV1VolumeAttachmentStatus operation.
type ReadStorageV1VolumeAttachmentStatusParams struct {
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1VolumeAttachmentStatusParams(packed map[string]any) (params ReadStorageV1VolumeAttachmentStatusParams) {
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1VolumeAttachmentStatusParams(args [1]string, r *http.Request) (params ReadStorageV1VolumeAttachmentStatusParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1alpha1NamespacedCSIStorageCapacityParams is parameters of readStorageV1alpha1NamespacedCSIStorageCapacity operation.
type ReadStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ReadStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1alpha1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params ReadStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// ReadStorageV1beta1NamespacedCSIStorageCapacityParams is parameters of readStorageV1beta1NamespacedCSIStorageCapacity operation.
type ReadStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
}

func unpackReadStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params ReadStorageV1beta1NamespacedCSIStorageCapacityParams) {
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	return params
}

func decodeReadStorageV1beta1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params ReadStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	return params, nil
}

// WatchAdmissionregistrationV1MutatingWebhookConfigurationParams is parameters of watchAdmissionregistrationV1MutatingWebhookConfiguration operation.
type WatchAdmissionregistrationV1MutatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the MutatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(packed map[string]any) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(args [1]string, r *http.Request) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams is parameters of watchAdmissionregistrationV1MutatingWebhookConfigurationList operation.
type WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(packed map[string]any) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(args [0]string, r *http.Request) (params WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams is parameters of watchAdmissionregistrationV1ValidatingWebhookConfiguration operation.
type WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ValidatingWebhookConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(packed map[string]any) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(args [1]string, r *http.Request) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams is parameters of watchAdmissionregistrationV1ValidatingWebhookConfigurationList operation.
type WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(packed map[string]any) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(args [0]string, r *http.Request) (params WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchApiextensionsV1CustomResourceDefinitionParams is parameters of watchApiextensionsV1CustomResourceDefinition operation.
type WatchApiextensionsV1CustomResourceDefinitionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CustomResourceDefinition.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchApiextensionsV1CustomResourceDefinitionParams(packed map[string]any) (params WatchApiextensionsV1CustomResourceDefinitionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiextensionsV1CustomResourceDefinitionParams(args [1]string, r *http.Request) (params WatchApiextensionsV1CustomResourceDefinitionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchApiextensionsV1CustomResourceDefinitionListParams is parameters of watchApiextensionsV1CustomResourceDefinitionList operation.
type WatchApiextensionsV1CustomResourceDefinitionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchApiextensionsV1CustomResourceDefinitionListParams(packed map[string]any) (params WatchApiextensionsV1CustomResourceDefinitionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiextensionsV1CustomResourceDefinitionListParams(args [0]string, r *http.Request) (params WatchApiextensionsV1CustomResourceDefinitionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchApiregistrationV1APIServiceParams is parameters of watchApiregistrationV1APIService operation.
type WatchApiregistrationV1APIServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the APIService.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchApiregistrationV1APIServiceParams(packed map[string]any) (params WatchApiregistrationV1APIServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiregistrationV1APIServiceParams(args [1]string, r *http.Request) (params WatchApiregistrationV1APIServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchApiregistrationV1APIServiceListParams is parameters of watchApiregistrationV1APIServiceList operation.
type WatchApiregistrationV1APIServiceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchApiregistrationV1APIServiceListParams(packed map[string]any) (params WatchApiregistrationV1APIServiceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchApiregistrationV1APIServiceListParams(args [0]string, r *http.Request) (params WatchApiregistrationV1APIServiceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1ControllerRevisionListForAllNamespacesParams is parameters of watchAppsV1ControllerRevisionListForAllNamespaces operation.
type WatchAppsV1ControllerRevisionListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1ControllerRevisionListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1ControllerRevisionListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1ControllerRevisionListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1ControllerRevisionListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1DaemonSetListForAllNamespacesParams is parameters of watchAppsV1DaemonSetListForAllNamespaces operation.
type WatchAppsV1DaemonSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1DaemonSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1DaemonSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1DaemonSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1DaemonSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1DeploymentListForAllNamespacesParams is parameters of watchAppsV1DeploymentListForAllNamespaces operation.
type WatchAppsV1DeploymentListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1DeploymentListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1DeploymentListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1DeploymentListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1DeploymentListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedControllerRevisionParams is parameters of watchAppsV1NamespacedControllerRevision operation.
type WatchAppsV1NamespacedControllerRevisionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ControllerRevision.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedControllerRevisionParams(packed map[string]any) (params WatchAppsV1NamespacedControllerRevisionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedControllerRevisionParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedControllerRevisionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedControllerRevisionListParams is parameters of watchAppsV1NamespacedControllerRevisionList operation.
type WatchAppsV1NamespacedControllerRevisionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedControllerRevisionListParams(packed map[string]any) (params WatchAppsV1NamespacedControllerRevisionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedControllerRevisionListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedControllerRevisionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedDaemonSetParams is parameters of watchAppsV1NamespacedDaemonSet operation.
type WatchAppsV1NamespacedDaemonSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the DaemonSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedDaemonSetParams(packed map[string]any) (params WatchAppsV1NamespacedDaemonSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDaemonSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedDaemonSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedDaemonSetListParams is parameters of watchAppsV1NamespacedDaemonSetList operation.
type WatchAppsV1NamespacedDaemonSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedDaemonSetListParams(packed map[string]any) (params WatchAppsV1NamespacedDaemonSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDaemonSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedDaemonSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedDeploymentParams is parameters of watchAppsV1NamespacedDeployment operation.
type WatchAppsV1NamespacedDeploymentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Deployment.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedDeploymentParams(packed map[string]any) (params WatchAppsV1NamespacedDeploymentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDeploymentParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedDeploymentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedDeploymentListParams is parameters of watchAppsV1NamespacedDeploymentList operation.
type WatchAppsV1NamespacedDeploymentListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedDeploymentListParams(packed map[string]any) (params WatchAppsV1NamespacedDeploymentListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedDeploymentListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedDeploymentListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedReplicaSetParams is parameters of watchAppsV1NamespacedReplicaSet operation.
type WatchAppsV1NamespacedReplicaSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ReplicaSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedReplicaSetParams(packed map[string]any) (params WatchAppsV1NamespacedReplicaSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedReplicaSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedReplicaSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedReplicaSetListParams is parameters of watchAppsV1NamespacedReplicaSetList operation.
type WatchAppsV1NamespacedReplicaSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedReplicaSetListParams(packed map[string]any) (params WatchAppsV1NamespacedReplicaSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedReplicaSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedReplicaSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedStatefulSetParams is parameters of watchAppsV1NamespacedStatefulSet operation.
type WatchAppsV1NamespacedStatefulSetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the StatefulSet.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedStatefulSetParams(packed map[string]any) (params WatchAppsV1NamespacedStatefulSetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedStatefulSetParams(args [2]string, r *http.Request) (params WatchAppsV1NamespacedStatefulSetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1NamespacedStatefulSetListParams is parameters of watchAppsV1NamespacedStatefulSetList operation.
type WatchAppsV1NamespacedStatefulSetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1NamespacedStatefulSetListParams(packed map[string]any) (params WatchAppsV1NamespacedStatefulSetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1NamespacedStatefulSetListParams(args [1]string, r *http.Request) (params WatchAppsV1NamespacedStatefulSetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1ReplicaSetListForAllNamespacesParams is parameters of watchAppsV1ReplicaSetListForAllNamespaces operation.
type WatchAppsV1ReplicaSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1ReplicaSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1ReplicaSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1ReplicaSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1ReplicaSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAppsV1StatefulSetListForAllNamespacesParams is parameters of watchAppsV1StatefulSetListForAllNamespaces operation.
type WatchAppsV1StatefulSetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAppsV1StatefulSetListForAllNamespacesParams(packed map[string]any) (params WatchAppsV1StatefulSetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAppsV1StatefulSetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAppsV1StatefulSetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams is parameters of watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces operation.
type WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams is parameters of watchAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
type WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams is parameters of watchAutoscalingV1NamespacedHorizontalPodAutoscalerList operation.
type WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams is parameters of watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces operation.
type WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams is parameters of watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
type WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams is parameters of watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList operation.
type WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams is parameters of watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces operation.
type WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(packed map[string]any) (params WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams is parameters of watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
type WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the HorizontalPodAutoscaler.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(packed map[string]any) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args [2]string, r *http.Request) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams is parameters of watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList operation.
type WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(packed map[string]any) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(args [1]string, r *http.Request) (params WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1CronJobListForAllNamespacesParams is parameters of watchBatchV1CronJobListForAllNamespaces operation.
type WatchBatchV1CronJobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1CronJobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1CronJobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1CronJobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1CronJobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1JobListForAllNamespacesParams is parameters of watchBatchV1JobListForAllNamespaces operation.
type WatchBatchV1JobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1JobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1JobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1JobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1JobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1NamespacedCronJobParams is parameters of watchBatchV1NamespacedCronJob operation.
type WatchBatchV1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1NamespacedCronJobParams(packed map[string]any) (params WatchBatchV1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedCronJobParams(args [2]string, r *http.Request) (params WatchBatchV1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1NamespacedCronJobListParams is parameters of watchBatchV1NamespacedCronJobList operation.
type WatchBatchV1NamespacedCronJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1NamespacedCronJobListParams(packed map[string]any) (params WatchBatchV1NamespacedCronJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedCronJobListParams(args [1]string, r *http.Request) (params WatchBatchV1NamespacedCronJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1NamespacedJobParams is parameters of watchBatchV1NamespacedJob operation.
type WatchBatchV1NamespacedJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Job.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1NamespacedJobParams(packed map[string]any) (params WatchBatchV1NamespacedJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedJobParams(args [2]string, r *http.Request) (params WatchBatchV1NamespacedJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1NamespacedJobListParams is parameters of watchBatchV1NamespacedJobList operation.
type WatchBatchV1NamespacedJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1NamespacedJobListParams(packed map[string]any) (params WatchBatchV1NamespacedJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1NamespacedJobListParams(args [1]string, r *http.Request) (params WatchBatchV1NamespacedJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1beta1CronJobListForAllNamespacesParams is parameters of watchBatchV1beta1CronJobListForAllNamespaces operation.
type WatchBatchV1beta1CronJobListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1beta1CronJobListForAllNamespacesParams(packed map[string]any) (params WatchBatchV1beta1CronJobListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1CronJobListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchBatchV1beta1CronJobListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1beta1NamespacedCronJobParams is parameters of watchBatchV1beta1NamespacedCronJob operation.
type WatchBatchV1beta1NamespacedCronJobParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CronJob.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1beta1NamespacedCronJobParams(packed map[string]any) (params WatchBatchV1beta1NamespacedCronJobParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1NamespacedCronJobParams(args [2]string, r *http.Request) (params WatchBatchV1beta1NamespacedCronJobParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchBatchV1beta1NamespacedCronJobListParams is parameters of watchBatchV1beta1NamespacedCronJobList operation.
type WatchBatchV1beta1NamespacedCronJobListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchBatchV1beta1NamespacedCronJobListParams(packed map[string]any) (params WatchBatchV1beta1NamespacedCronJobListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchBatchV1beta1NamespacedCronJobListParams(args [1]string, r *http.Request) (params WatchBatchV1beta1NamespacedCronJobListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCertificatesV1CertificateSigningRequestParams is parameters of watchCertificatesV1CertificateSigningRequest operation.
type WatchCertificatesV1CertificateSigningRequestParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CertificateSigningRequest.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCertificatesV1CertificateSigningRequestParams(packed map[string]any) (params WatchCertificatesV1CertificateSigningRequestParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCertificatesV1CertificateSigningRequestParams(args [1]string, r *http.Request) (params WatchCertificatesV1CertificateSigningRequestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCertificatesV1CertificateSigningRequestListParams is parameters of watchCertificatesV1CertificateSigningRequestList operation.
type WatchCertificatesV1CertificateSigningRequestListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCertificatesV1CertificateSigningRequestListParams(packed map[string]any) (params WatchCertificatesV1CertificateSigningRequestListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCertificatesV1CertificateSigningRequestListParams(args [0]string, r *http.Request) (params WatchCertificatesV1CertificateSigningRequestListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoordinationV1LeaseListForAllNamespacesParams is parameters of watchCoordinationV1LeaseListForAllNamespaces operation.
type WatchCoordinationV1LeaseListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoordinationV1LeaseListForAllNamespacesParams(packed map[string]any) (params WatchCoordinationV1LeaseListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1LeaseListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoordinationV1LeaseListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoordinationV1NamespacedLeaseParams is parameters of watchCoordinationV1NamespacedLease operation.
type WatchCoordinationV1NamespacedLeaseParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Lease.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoordinationV1NamespacedLeaseParams(packed map[string]any) (params WatchCoordinationV1NamespacedLeaseParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1NamespacedLeaseParams(args [2]string, r *http.Request) (params WatchCoordinationV1NamespacedLeaseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoordinationV1NamespacedLeaseListParams is parameters of watchCoordinationV1NamespacedLeaseList operation.
type WatchCoordinationV1NamespacedLeaseListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoordinationV1NamespacedLeaseListParams(packed map[string]any) (params WatchCoordinationV1NamespacedLeaseListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoordinationV1NamespacedLeaseListParams(args [1]string, r *http.Request) (params WatchCoordinationV1NamespacedLeaseListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1ConfigMapListForAllNamespacesParams is parameters of watchCoreV1ConfigMapListForAllNamespaces operation.
type WatchCoreV1ConfigMapListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1ConfigMapListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ConfigMapListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ConfigMapListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ConfigMapListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1EndpointsListForAllNamespacesParams is parameters of watchCoreV1EndpointsListForAllNamespaces operation.
type WatchCoreV1EndpointsListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1EndpointsListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1EndpointsListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1EndpointsListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1EndpointsListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1EventListForAllNamespacesParams is parameters of watchCoreV1EventListForAllNamespaces operation.
type WatchCoreV1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1EventListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1LimitRangeListForAllNamespacesParams is parameters of watchCoreV1LimitRangeListForAllNamespaces operation.
type WatchCoreV1LimitRangeListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1LimitRangeListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1LimitRangeListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1LimitRangeListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1LimitRangeListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespaceParams is parameters of watchCoreV1Namespace operation.
type WatchCoreV1NamespaceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Namespace.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespaceParams(packed map[string]any) (params WatchCoreV1NamespaceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespaceParams(args [1]string, r *http.Request) (params WatchCoreV1NamespaceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespaceListParams is parameters of watchCoreV1NamespaceList operation.
type WatchCoreV1NamespaceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespaceListParams(packed map[string]any) (params WatchCoreV1NamespaceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespaceListParams(args [0]string, r *http.Request) (params WatchCoreV1NamespaceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedConfigMapParams is parameters of watchCoreV1NamespacedConfigMap operation.
type WatchCoreV1NamespacedConfigMapParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ConfigMap.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedConfigMapParams(packed map[string]any) (params WatchCoreV1NamespacedConfigMapParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedConfigMapParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedConfigMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedConfigMapListParams is parameters of watchCoreV1NamespacedConfigMapList operation.
type WatchCoreV1NamespacedConfigMapListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedConfigMapListParams(packed map[string]any) (params WatchCoreV1NamespacedConfigMapListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedConfigMapListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedConfigMapListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedEndpointsParams is parameters of watchCoreV1NamespacedEndpoints operation.
type WatchCoreV1NamespacedEndpointsParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Endpoints.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedEndpointsParams(packed map[string]any) (params WatchCoreV1NamespacedEndpointsParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEndpointsParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedEndpointsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedEndpointsListParams is parameters of watchCoreV1NamespacedEndpointsList operation.
type WatchCoreV1NamespacedEndpointsListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedEndpointsListParams(packed map[string]any) (params WatchCoreV1NamespacedEndpointsListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEndpointsListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedEndpointsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedEventParams is parameters of watchCoreV1NamespacedEvent operation.
type WatchCoreV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedEventParams(packed map[string]any) (params WatchCoreV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEventParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedEventListParams is parameters of watchCoreV1NamespacedEventList operation.
type WatchCoreV1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedEventListParams(packed map[string]any) (params WatchCoreV1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedLimitRangeParams is parameters of watchCoreV1NamespacedLimitRange operation.
type WatchCoreV1NamespacedLimitRangeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the LimitRange.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedLimitRangeParams(packed map[string]any) (params WatchCoreV1NamespacedLimitRangeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedLimitRangeParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedLimitRangeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedLimitRangeListParams is parameters of watchCoreV1NamespacedLimitRangeList operation.
type WatchCoreV1NamespacedLimitRangeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedLimitRangeListParams(packed map[string]any) (params WatchCoreV1NamespacedLimitRangeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedLimitRangeListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedLimitRangeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPersistentVolumeClaimParams is parameters of watchCoreV1NamespacedPersistentVolumeClaim operation.
type WatchCoreV1NamespacedPersistentVolumeClaimParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PersistentVolumeClaim.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPersistentVolumeClaimParams(packed map[string]any) (params WatchCoreV1NamespacedPersistentVolumeClaimParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPersistentVolumeClaimParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPersistentVolumeClaimParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPersistentVolumeClaimListParams is parameters of watchCoreV1NamespacedPersistentVolumeClaimList operation.
type WatchCoreV1NamespacedPersistentVolumeClaimListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPersistentVolumeClaimListParams(packed map[string]any) (params WatchCoreV1NamespacedPersistentVolumeClaimListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPersistentVolumeClaimListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPersistentVolumeClaimListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPodParams is parameters of watchCoreV1NamespacedPod operation.
type WatchCoreV1NamespacedPodParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Pod.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPodParams(packed map[string]any) (params WatchCoreV1NamespacedPodParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPodParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPodListParams is parameters of watchCoreV1NamespacedPodList operation.
type WatchCoreV1NamespacedPodListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPodListParams(packed map[string]any) (params WatchCoreV1NamespacedPodListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPodListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPodTemplateParams is parameters of watchCoreV1NamespacedPodTemplate operation.
type WatchCoreV1NamespacedPodTemplateParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PodTemplate.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPodTemplateParams(packed map[string]any) (params WatchCoreV1NamespacedPodTemplateParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodTemplateParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedPodTemplateParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedPodTemplateListParams is parameters of watchCoreV1NamespacedPodTemplateList operation.
type WatchCoreV1NamespacedPodTemplateListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedPodTemplateListParams(packed map[string]any) (params WatchCoreV1NamespacedPodTemplateListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedPodTemplateListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedPodTemplateListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedReplicationControllerParams is parameters of watchCoreV1NamespacedReplicationController operation.
type WatchCoreV1NamespacedReplicationControllerParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ReplicationController.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedReplicationControllerParams(packed map[string]any) (params WatchCoreV1NamespacedReplicationControllerParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedReplicationControllerParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedReplicationControllerParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedReplicationControllerListParams is parameters of watchCoreV1NamespacedReplicationControllerList operation.
type WatchCoreV1NamespacedReplicationControllerListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedReplicationControllerListParams(packed map[string]any) (params WatchCoreV1NamespacedReplicationControllerListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedReplicationControllerListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedReplicationControllerListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedResourceQuotaParams is parameters of watchCoreV1NamespacedResourceQuota operation.
type WatchCoreV1NamespacedResourceQuotaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ResourceQuota.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedResourceQuotaParams(packed map[string]any) (params WatchCoreV1NamespacedResourceQuotaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedResourceQuotaParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedResourceQuotaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedResourceQuotaListParams is parameters of watchCoreV1NamespacedResourceQuotaList operation.
type WatchCoreV1NamespacedResourceQuotaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedResourceQuotaListParams(packed map[string]any) (params WatchCoreV1NamespacedResourceQuotaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedResourceQuotaListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedResourceQuotaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedSecretParams is parameters of watchCoreV1NamespacedSecret operation.
type WatchCoreV1NamespacedSecretParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Secret.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedSecretParams(packed map[string]any) (params WatchCoreV1NamespacedSecretParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedSecretParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedSecretListParams is parameters of watchCoreV1NamespacedSecretList operation.
type WatchCoreV1NamespacedSecretListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedSecretListParams(packed map[string]any) (params WatchCoreV1NamespacedSecretListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedSecretListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedSecretListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedServiceParams is parameters of watchCoreV1NamespacedService operation.
type WatchCoreV1NamespacedServiceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Service.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedServiceParams(packed map[string]any) (params WatchCoreV1NamespacedServiceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedServiceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedServiceAccountParams is parameters of watchCoreV1NamespacedServiceAccount operation.
type WatchCoreV1NamespacedServiceAccountParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ServiceAccount.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedServiceAccountParams(packed map[string]any) (params WatchCoreV1NamespacedServiceAccountParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceAccountParams(args [2]string, r *http.Request) (params WatchCoreV1NamespacedServiceAccountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedServiceAccountListParams is parameters of watchCoreV1NamespacedServiceAccountList operation.
type WatchCoreV1NamespacedServiceAccountListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedServiceAccountListParams(packed map[string]any) (params WatchCoreV1NamespacedServiceAccountListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceAccountListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedServiceAccountListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NamespacedServiceListParams is parameters of watchCoreV1NamespacedServiceList operation.
type WatchCoreV1NamespacedServiceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NamespacedServiceListParams(packed map[string]any) (params WatchCoreV1NamespacedServiceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NamespacedServiceListParams(args [1]string, r *http.Request) (params WatchCoreV1NamespacedServiceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NodeParams is parameters of watchCoreV1Node operation.
type WatchCoreV1NodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Node.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NodeParams(packed map[string]any) (params WatchCoreV1NodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NodeParams(args [1]string, r *http.Request) (params WatchCoreV1NodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1NodeListParams is parameters of watchCoreV1NodeList operation.
type WatchCoreV1NodeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1NodeListParams(packed map[string]any) (params WatchCoreV1NodeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1NodeListParams(args [0]string, r *http.Request) (params WatchCoreV1NodeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1PersistentVolumeParams is parameters of watchCoreV1PersistentVolume operation.
type WatchCoreV1PersistentVolumeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PersistentVolume.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1PersistentVolumeParams(packed map[string]any) (params WatchCoreV1PersistentVolumeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeParams(args [1]string, r *http.Request) (params WatchCoreV1PersistentVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams is parameters of watchCoreV1PersistentVolumeClaimListForAllNamespaces operation.
type WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1PersistentVolumeListParams is parameters of watchCoreV1PersistentVolumeList operation.
type WatchCoreV1PersistentVolumeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1PersistentVolumeListParams(packed map[string]any) (params WatchCoreV1PersistentVolumeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PersistentVolumeListParams(args [0]string, r *http.Request) (params WatchCoreV1PersistentVolumeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1PodListForAllNamespacesParams is parameters of watchCoreV1PodListForAllNamespaces operation.
type WatchCoreV1PodListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1PodListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PodListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PodListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PodListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1PodTemplateListForAllNamespacesParams is parameters of watchCoreV1PodTemplateListForAllNamespaces operation.
type WatchCoreV1PodTemplateListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1PodTemplateListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1PodTemplateListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1PodTemplateListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1PodTemplateListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1ReplicationControllerListForAllNamespacesParams is parameters of watchCoreV1ReplicationControllerListForAllNamespaces operation.
type WatchCoreV1ReplicationControllerListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1ReplicationControllerListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ReplicationControllerListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ReplicationControllerListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ReplicationControllerListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1ResourceQuotaListForAllNamespacesParams is parameters of watchCoreV1ResourceQuotaListForAllNamespaces operation.
type WatchCoreV1ResourceQuotaListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1ResourceQuotaListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ResourceQuotaListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ResourceQuotaListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ResourceQuotaListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1SecretListForAllNamespacesParams is parameters of watchCoreV1SecretListForAllNamespaces operation.
type WatchCoreV1SecretListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1SecretListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1SecretListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1SecretListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1SecretListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1ServiceAccountListForAllNamespacesParams is parameters of watchCoreV1ServiceAccountListForAllNamespaces operation.
type WatchCoreV1ServiceAccountListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1ServiceAccountListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ServiceAccountListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ServiceAccountListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ServiceAccountListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchCoreV1ServiceListForAllNamespacesParams is parameters of watchCoreV1ServiceListForAllNamespaces operation.
type WatchCoreV1ServiceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchCoreV1ServiceListForAllNamespacesParams(packed map[string]any) (params WatchCoreV1ServiceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchCoreV1ServiceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchCoreV1ServiceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1EndpointSliceListForAllNamespacesParams is parameters of watchDiscoveryV1EndpointSliceListForAllNamespaces operation.
type WatchDiscoveryV1EndpointSliceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(packed map[string]any) (params WatchDiscoveryV1EndpointSliceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchDiscoveryV1EndpointSliceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1NamespacedEndpointSliceParams is parameters of watchDiscoveryV1NamespacedEndpointSlice operation.
type WatchDiscoveryV1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1NamespacedEndpointSliceParams(packed map[string]any) (params WatchDiscoveryV1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params WatchDiscoveryV1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1NamespacedEndpointSliceListParams is parameters of watchDiscoveryV1NamespacedEndpointSliceList operation.
type WatchDiscoveryV1NamespacedEndpointSliceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1NamespacedEndpointSliceListParams(packed map[string]any) (params WatchDiscoveryV1NamespacedEndpointSliceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1NamespacedEndpointSliceListParams(args [1]string, r *http.Request) (params WatchDiscoveryV1NamespacedEndpointSliceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams is parameters of watchDiscoveryV1beta1EndpointSliceListForAllNamespaces operation.
type WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(packed map[string]any) (params WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1beta1NamespacedEndpointSliceParams is parameters of watchDiscoveryV1beta1NamespacedEndpointSlice operation.
type WatchDiscoveryV1beta1NamespacedEndpointSliceParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the EndpointSlice.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1beta1NamespacedEndpointSliceParams(packed map[string]any) (params WatchDiscoveryV1beta1NamespacedEndpointSliceParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1NamespacedEndpointSliceParams(args [2]string, r *http.Request) (params WatchDiscoveryV1beta1NamespacedEndpointSliceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchDiscoveryV1beta1NamespacedEndpointSliceListParams is parameters of watchDiscoveryV1beta1NamespacedEndpointSliceList operation.
type WatchDiscoveryV1beta1NamespacedEndpointSliceListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(packed map[string]any) (params WatchDiscoveryV1beta1NamespacedEndpointSliceListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(args [1]string, r *http.Request) (params WatchDiscoveryV1beta1NamespacedEndpointSliceListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1EventListForAllNamespacesParams is parameters of watchEventsV1EventListForAllNamespaces operation.
type WatchEventsV1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1EventListForAllNamespacesParams(packed map[string]any) (params WatchEventsV1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchEventsV1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1NamespacedEventParams is parameters of watchEventsV1NamespacedEvent operation.
type WatchEventsV1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1NamespacedEventParams(packed map[string]any) (params WatchEventsV1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1NamespacedEventParams(args [2]string, r *http.Request) (params WatchEventsV1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1NamespacedEventListParams is parameters of watchEventsV1NamespacedEventList operation.
type WatchEventsV1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1NamespacedEventListParams(packed map[string]any) (params WatchEventsV1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchEventsV1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1beta1EventListForAllNamespacesParams is parameters of watchEventsV1beta1EventListForAllNamespaces operation.
type WatchEventsV1beta1EventListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1beta1EventListForAllNamespacesParams(packed map[string]any) (params WatchEventsV1beta1EventListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1EventListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchEventsV1beta1EventListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1beta1NamespacedEventParams is parameters of watchEventsV1beta1NamespacedEvent operation.
type WatchEventsV1beta1NamespacedEventParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Event.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1beta1NamespacedEventParams(packed map[string]any) (params WatchEventsV1beta1NamespacedEventParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1NamespacedEventParams(args [2]string, r *http.Request) (params WatchEventsV1beta1NamespacedEventParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchEventsV1beta1NamespacedEventListParams is parameters of watchEventsV1beta1NamespacedEventList operation.
type WatchEventsV1beta1NamespacedEventListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchEventsV1beta1NamespacedEventListParams(packed map[string]any) (params WatchEventsV1beta1NamespacedEventListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchEventsV1beta1NamespacedEventListParams(args [1]string, r *http.Request) (params WatchEventsV1beta1NamespacedEventListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta1FlowSchemaParams is parameters of watchFlowcontrolApiserverV1beta1FlowSchema operation.
type WatchFlowcontrolApiserverV1beta1FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta1FlowSchemaParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1FlowSchemaParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta1FlowSchemaListParams is parameters of watchFlowcontrolApiserverV1beta1FlowSchemaList operation.
type WatchFlowcontrolApiserverV1beta1FlowSchemaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1FlowSchemaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1FlowSchemaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams is parameters of watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
type WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams is parameters of watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList operation.
type WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta2FlowSchemaParams is parameters of watchFlowcontrolApiserverV1beta2FlowSchema operation.
type WatchFlowcontrolApiserverV1beta2FlowSchemaParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the FlowSchema.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta2FlowSchemaParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2FlowSchemaParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2FlowSchemaParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2FlowSchemaParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta2FlowSchemaListParams is parameters of watchFlowcontrolApiserverV1beta2FlowSchemaList operation.
type WatchFlowcontrolApiserverV1beta2FlowSchemaListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2FlowSchemaListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2FlowSchemaListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams is parameters of watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
type WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PriorityLevelConfiguration.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args [1]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams is parameters of watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList operation.
type WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(packed map[string]any) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(args [0]string, r *http.Request) (params WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchInternalApiserverV1alpha1StorageVersionParams is parameters of watchInternalApiserverV1alpha1StorageVersion operation.
type WatchInternalApiserverV1alpha1StorageVersionParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the StorageVersion.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchInternalApiserverV1alpha1StorageVersionParams(packed map[string]any) (params WatchInternalApiserverV1alpha1StorageVersionParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchInternalApiserverV1alpha1StorageVersionParams(args [1]string, r *http.Request) (params WatchInternalApiserverV1alpha1StorageVersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchInternalApiserverV1alpha1StorageVersionListParams is parameters of watchInternalApiserverV1alpha1StorageVersionList operation.
type WatchInternalApiserverV1alpha1StorageVersionListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchInternalApiserverV1alpha1StorageVersionListParams(packed map[string]any) (params WatchInternalApiserverV1alpha1StorageVersionListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchInternalApiserverV1alpha1StorageVersionListParams(args [0]string, r *http.Request) (params WatchInternalApiserverV1alpha1StorageVersionListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1IngressClassParams is parameters of watchNetworkingV1IngressClass operation.
type WatchNetworkingV1IngressClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the IngressClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1IngressClassParams(packed map[string]any) (params WatchNetworkingV1IngressClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressClassParams(args [1]string, r *http.Request) (params WatchNetworkingV1IngressClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1IngressClassListParams is parameters of watchNetworkingV1IngressClassList operation.
type WatchNetworkingV1IngressClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1IngressClassListParams(packed map[string]any) (params WatchNetworkingV1IngressClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressClassListParams(args [0]string, r *http.Request) (params WatchNetworkingV1IngressClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1IngressListForAllNamespacesParams is parameters of watchNetworkingV1IngressListForAllNamespaces operation.
type WatchNetworkingV1IngressListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1IngressListForAllNamespacesParams(packed map[string]any) (params WatchNetworkingV1IngressListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1IngressListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchNetworkingV1IngressListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1NamespacedIngressParams is parameters of watchNetworkingV1NamespacedIngress operation.
type WatchNetworkingV1NamespacedIngressParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Ingress.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1NamespacedIngressParams(packed map[string]any) (params WatchNetworkingV1NamespacedIngressParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedIngressParams(args [2]string, r *http.Request) (params WatchNetworkingV1NamespacedIngressParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1NamespacedIngressListParams is parameters of watchNetworkingV1NamespacedIngressList operation.
type WatchNetworkingV1NamespacedIngressListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1NamespacedIngressListParams(packed map[string]any) (params WatchNetworkingV1NamespacedIngressListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedIngressListParams(args [1]string, r *http.Request) (params WatchNetworkingV1NamespacedIngressListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1NamespacedNetworkPolicyParams is parameters of watchNetworkingV1NamespacedNetworkPolicy operation.
type WatchNetworkingV1NamespacedNetworkPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the NetworkPolicy.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1NamespacedNetworkPolicyParams(packed map[string]any) (params WatchNetworkingV1NamespacedNetworkPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedNetworkPolicyParams(args [2]string, r *http.Request) (params WatchNetworkingV1NamespacedNetworkPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1NamespacedNetworkPolicyListParams is parameters of watchNetworkingV1NamespacedNetworkPolicyList operation.
type WatchNetworkingV1NamespacedNetworkPolicyListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1NamespacedNetworkPolicyListParams(packed map[string]any) (params WatchNetworkingV1NamespacedNetworkPolicyListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NamespacedNetworkPolicyListParams(args [1]string, r *http.Request) (params WatchNetworkingV1NamespacedNetworkPolicyListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNetworkingV1NetworkPolicyListForAllNamespacesParams is parameters of watchNetworkingV1NetworkPolicyListForAllNamespaces operation.
type WatchNetworkingV1NetworkPolicyListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(packed map[string]any) (params WatchNetworkingV1NetworkPolicyListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchNetworkingV1NetworkPolicyListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1RuntimeClassParams is parameters of watchNodeV1RuntimeClass operation.
type WatchNodeV1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1RuntimeClassParams(packed map[string]any) (params WatchNodeV1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1RuntimeClassListParams is parameters of watchNodeV1RuntimeClassList operation.
type WatchNodeV1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1alpha1RuntimeClassParams is parameters of watchNodeV1alpha1RuntimeClass operation.
type WatchNodeV1alpha1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1alpha1RuntimeClassParams(packed map[string]any) (params WatchNodeV1alpha1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1alpha1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1alpha1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1alpha1RuntimeClassListParams is parameters of watchNodeV1alpha1RuntimeClassList operation.
type WatchNodeV1alpha1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1alpha1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1alpha1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1alpha1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1alpha1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1beta1RuntimeClassParams is parameters of watchNodeV1beta1RuntimeClass operation.
type WatchNodeV1beta1RuntimeClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the RuntimeClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1beta1RuntimeClassParams(packed map[string]any) (params WatchNodeV1beta1RuntimeClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1beta1RuntimeClassParams(args [1]string, r *http.Request) (params WatchNodeV1beta1RuntimeClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchNodeV1beta1RuntimeClassListParams is parameters of watchNodeV1beta1RuntimeClassList operation.
type WatchNodeV1beta1RuntimeClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchNodeV1beta1RuntimeClassListParams(packed map[string]any) (params WatchNodeV1beta1RuntimeClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchNodeV1beta1RuntimeClassListParams(args [0]string, r *http.Request) (params WatchNodeV1beta1RuntimeClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1NamespacedPodDisruptionBudgetParams is parameters of watchPolicyV1NamespacedPodDisruptionBudget operation.
type WatchPolicyV1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params WatchPolicyV1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params WatchPolicyV1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1NamespacedPodDisruptionBudgetListParams is parameters of watchPolicyV1NamespacedPodDisruptionBudgetList operation.
type WatchPolicyV1NamespacedPodDisruptionBudgetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1NamespacedPodDisruptionBudgetListParams(packed map[string]any) (params WatchPolicyV1NamespacedPodDisruptionBudgetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1NamespacedPodDisruptionBudgetListParams(args [1]string, r *http.Request) (params WatchPolicyV1NamespacedPodDisruptionBudgetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams is parameters of watchPolicyV1PodDisruptionBudgetListForAllNamespaces operation.
type WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(packed map[string]any) (params WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams is parameters of watchPolicyV1beta1NamespacedPodDisruptionBudget operation.
type WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PodDisruptionBudget.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(packed map[string]any) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(args [2]string, r *http.Request) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams is parameters of watchPolicyV1beta1NamespacedPodDisruptionBudgetList operation.
type WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(packed map[string]any) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(args [1]string, r *http.Request) (params WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams is parameters of watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces operation.
type WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(packed map[string]any) (params WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1beta1PodSecurityPolicyParams is parameters of watchPolicyV1beta1PodSecurityPolicy operation.
type WatchPolicyV1beta1PodSecurityPolicyParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PodSecurityPolicy.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1beta1PodSecurityPolicyParams(packed map[string]any) (params WatchPolicyV1beta1PodSecurityPolicyParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodSecurityPolicyParams(args [1]string, r *http.Request) (params WatchPolicyV1beta1PodSecurityPolicyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchPolicyV1beta1PodSecurityPolicyListParams is parameters of watchPolicyV1beta1PodSecurityPolicyList operation.
type WatchPolicyV1beta1PodSecurityPolicyListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchPolicyV1beta1PodSecurityPolicyListParams(packed map[string]any) (params WatchPolicyV1beta1PodSecurityPolicyListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchPolicyV1beta1PodSecurityPolicyListParams(args [0]string, r *http.Request) (params WatchPolicyV1beta1PodSecurityPolicyListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1ClusterRoleParams is parameters of watchRbacAuthorizationV1ClusterRole operation.
type WatchRbacAuthorizationV1ClusterRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ClusterRole.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1ClusterRoleParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1ClusterRoleBindingParams is parameters of watchRbacAuthorizationV1ClusterRoleBinding operation.
type WatchRbacAuthorizationV1ClusterRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the ClusterRoleBinding.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1ClusterRoleBindingParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleBindingParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1ClusterRoleBindingListParams is parameters of watchRbacAuthorizationV1ClusterRoleBindingList operation.
type WatchRbacAuthorizationV1ClusterRoleBindingListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1ClusterRoleBindingListParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleBindingListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleBindingListParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleBindingListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1ClusterRoleListParams is parameters of watchRbacAuthorizationV1ClusterRoleList operation.
type WatchRbacAuthorizationV1ClusterRoleListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1ClusterRoleListParams(packed map[string]any) (params WatchRbacAuthorizationV1ClusterRoleListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1ClusterRoleListParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1ClusterRoleListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1NamespacedRoleParams is parameters of watchRbacAuthorizationV1NamespacedRole operation.
type WatchRbacAuthorizationV1NamespacedRoleParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the Role.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1NamespacedRoleParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleParams(args [2]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1NamespacedRoleBindingParams is parameters of watchRbacAuthorizationV1NamespacedRoleBinding operation.
type WatchRbacAuthorizationV1NamespacedRoleBindingParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the RoleBinding.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1NamespacedRoleBindingParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleBindingParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleBindingParams(args [2]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleBindingParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1NamespacedRoleBindingListParams is parameters of watchRbacAuthorizationV1NamespacedRoleBindingList operation.
type WatchRbacAuthorizationV1NamespacedRoleBindingListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1NamespacedRoleBindingListParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleBindingListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleBindingListParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleBindingListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1NamespacedRoleListParams is parameters of watchRbacAuthorizationV1NamespacedRoleList operation.
type WatchRbacAuthorizationV1NamespacedRoleListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1NamespacedRoleListParams(packed map[string]any) (params WatchRbacAuthorizationV1NamespacedRoleListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1NamespacedRoleListParams(args [1]string, r *http.Request) (params WatchRbacAuthorizationV1NamespacedRoleListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams is parameters of watchRbacAuthorizationV1RoleBindingListForAllNamespaces operation.
type WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(packed map[string]any) (params WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchRbacAuthorizationV1RoleListForAllNamespacesParams is parameters of watchRbacAuthorizationV1RoleListForAllNamespaces operation.
type WatchRbacAuthorizationV1RoleListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchRbacAuthorizationV1RoleListForAllNamespacesParams(packed map[string]any) (params WatchRbacAuthorizationV1RoleListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchRbacAuthorizationV1RoleListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchRbacAuthorizationV1RoleListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchSchedulingV1PriorityClassParams is parameters of watchSchedulingV1PriorityClass operation.
type WatchSchedulingV1PriorityClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the PriorityClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchSchedulingV1PriorityClassParams(packed map[string]any) (params WatchSchedulingV1PriorityClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchSchedulingV1PriorityClassParams(args [1]string, r *http.Request) (params WatchSchedulingV1PriorityClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchSchedulingV1PriorityClassListParams is parameters of watchSchedulingV1PriorityClassList operation.
type WatchSchedulingV1PriorityClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchSchedulingV1PriorityClassListParams(packed map[string]any) (params WatchSchedulingV1PriorityClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchSchedulingV1PriorityClassListParams(args [0]string, r *http.Request) (params WatchSchedulingV1PriorityClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1CSIDriverParams is parameters of watchStorageV1CSIDriver operation.
type WatchStorageV1CSIDriverParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CSIDriver.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1CSIDriverParams(packed map[string]any) (params WatchStorageV1CSIDriverParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSIDriverParams(args [1]string, r *http.Request) (params WatchStorageV1CSIDriverParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1CSIDriverListParams is parameters of watchStorageV1CSIDriverList operation.
type WatchStorageV1CSIDriverListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1CSIDriverListParams(packed map[string]any) (params WatchStorageV1CSIDriverListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSIDriverListParams(args [0]string, r *http.Request) (params WatchStorageV1CSIDriverListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1CSINodeParams is parameters of watchStorageV1CSINode operation.
type WatchStorageV1CSINodeParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CSINode.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1CSINodeParams(packed map[string]any) (params WatchStorageV1CSINodeParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSINodeParams(args [1]string, r *http.Request) (params WatchStorageV1CSINodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1CSINodeListParams is parameters of watchStorageV1CSINodeList operation.
type WatchStorageV1CSINodeListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1CSINodeListParams(packed map[string]any) (params WatchStorageV1CSINodeListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1CSINodeListParams(args [0]string, r *http.Request) (params WatchStorageV1CSINodeListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1StorageClassParams is parameters of watchStorageV1StorageClass operation.
type WatchStorageV1StorageClassParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the StorageClass.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1StorageClassParams(packed map[string]any) (params WatchStorageV1StorageClassParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1StorageClassParams(args [1]string, r *http.Request) (params WatchStorageV1StorageClassParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1StorageClassListParams is parameters of watchStorageV1StorageClassList operation.
type WatchStorageV1StorageClassListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1StorageClassListParams(packed map[string]any) (params WatchStorageV1StorageClassListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1StorageClassListParams(args [0]string, r *http.Request) (params WatchStorageV1StorageClassListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1VolumeAttachmentParams is parameters of watchStorageV1VolumeAttachment operation.
type WatchStorageV1VolumeAttachmentParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the VolumeAttachment.
	Name string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1VolumeAttachmentParams(packed map[string]any) (params WatchStorageV1VolumeAttachmentParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1VolumeAttachmentParams(args [1]string, r *http.Request) (params WatchStorageV1VolumeAttachmentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1VolumeAttachmentListParams is parameters of watchStorageV1VolumeAttachmentList operation.
type WatchStorageV1VolumeAttachmentListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1VolumeAttachmentListParams(packed map[string]any) (params WatchStorageV1VolumeAttachmentListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1VolumeAttachmentListParams(args [0]string, r *http.Request) (params WatchStorageV1VolumeAttachmentListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams is parameters of watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces operation.
type WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(packed map[string]any) (params WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1alpha1NamespacedCSIStorageCapacityParams is parameters of watchStorageV1alpha1NamespacedCSIStorageCapacity operation.
type WatchStorageV1alpha1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(packed map[string]any) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams is parameters of watchStorageV1alpha1NamespacedCSIStorageCapacityList operation.
type WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(packed map[string]any) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(args [1]string, r *http.Request) (params WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams is parameters of watchStorageV1beta1CSIStorageCapacityListForAllNamespaces operation.
type WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(packed map[string]any) (params WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(args [0]string, r *http.Request) (params WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1beta1NamespacedCSIStorageCapacityParams is parameters of watchStorageV1beta1NamespacedCSIStorageCapacity operation.
type WatchStorageV1beta1NamespacedCSIStorageCapacityParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Name of the CSIStorageCapacity.
	Name string
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1beta1NamespacedCSIStorageCapacityParams(packed map[string]any) (params WatchStorageV1beta1NamespacedCSIStorageCapacityParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Name = packed["name"].(string)
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1NamespacedCSIStorageCapacityParams(args [2]string, r *http.Request) (params WatchStorageV1beta1NamespacedCSIStorageCapacityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}

// WatchStorageV1beta1NamespacedCSIStorageCapacityListParams is parameters of watchStorageV1beta1NamespacedCSIStorageCapacityList operation.
type WatchStorageV1beta1NamespacedCSIStorageCapacityListParams struct {
	// AllowWatchBookmarks requests watch events with type "BOOKMARK". Servers that do not implement
	// bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should
	// not assume bookmarks are returned at any specific interval, nor may they assume the server will
	// send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
	AllowWatchBookmarks OptBool `json:",omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value
	// is server defined, clients may only use the continue value from a previous query result with
	// identical query parameters (except for the value of continue) and the server may reject a continue
	// value it does not recognize. If the specified continue value is no longer valid whether due to
	// expiration (generally five to fifteen minutes) or a configuration change on the server, the server
	// will respond with a 410 ResourceExpired error together with a continue token. If the client needs
	// a consistent list, it must restart their list without the continue field. Otherwise, the client
	// may send another list request with the token received with the 410 error, the server will respond
	// with a list starting from the next key, but from the latest snapshot, which is inconsistent from
	// the previous list results - objects that are created, modified, or deleted after the first list
	// request will be included in the response, as long as their keys are after the "next key".
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their fields. Defaults to everything.
	FieldSelector OptString `json:",omitempty"`
	// A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector OptString `json:",omitempty"`
	// Limit is a maximum number of responses to return for a list call. If more items exist, the server
	// will set the `continue` field on the list metadata to a value that can be used with the same
	// initial query to retrieve the next set of results. Setting a limit may return fewer than the
	// requested amount of items (up to zero items) in the event all requested objects are filtered out
	// and clients should only use the presence of the continue field to determine whether more results
	// are available. Servers may choose not to support the limit argument and will return all of the
	// available results. If limit is specified and the continue field is empty, clients may assume that
	// no more results are available. This field is not supported if watch is true.
	// The server guarantees that the objects returned when using continue will be identical to issuing a
	// single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first
	// list result was calculated is returned.
	Limit OptInt `json:",omitempty"`
	// Object name and auth scope, such as for teams and projects.
	Namespace string
	// If 'true', then the output is pretty printed.
	Pretty OptString `json:",omitempty"`
	// ResourceVersion sets a constraint on what resource versions a request may be served from. See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersion OptString `json:",omitempty"`
	// ResourceVersionMatch determines how resourceVersion is applied to list calls. It is highly
	// recommended that resourceVersionMatch be set for list calls where resourceVersion is set See
	// https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.
	// Defaults to unset.
	ResourceVersionMatch OptString `json:",omitempty"`
	// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity
	// or inactivity.
	TimeoutSeconds OptInt `json:",omitempty"`
	// Watch for changes to the described resources and return them as a stream of add, update, and
	// remove notifications. Specify resourceVersion.
	Watch OptBool `json:",omitempty"`
}

func unpackWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(packed map[string]any) (params WatchStorageV1beta1NamespacedCSIStorageCapacityListParams) {
	if v, ok := packed["allowWatchBookmarks"]; ok {
		params.AllowWatchBookmarks = v.(OptBool)
	}
	if v, ok := packed["continue"]; ok {
		params.Continue = v.(OptString)
	}
	if v, ok := packed["fieldSelector"]; ok {
		params.FieldSelector = v.(OptString)
	}
	if v, ok := packed["labelSelector"]; ok {
		params.LabelSelector = v.(OptString)
	}
	if v, ok := packed["limit"]; ok {
		params.Limit = v.(OptInt)
	}
	params.Namespace = packed["namespace"].(string)
	if v, ok := packed["pretty"]; ok {
		params.Pretty = v.(OptString)
	}
	if v, ok := packed["resourceVersion"]; ok {
		params.ResourceVersion = v.(OptString)
	}
	if v, ok := packed["resourceVersionMatch"]; ok {
		params.ResourceVersionMatch = v.(OptString)
	}
	if v, ok := packed["timeoutSeconds"]; ok {
		params.TimeoutSeconds = v.(OptInt)
	}
	if v, ok := packed["watch"]; ok {
		params.Watch = v.(OptBool)
	}
	return params
}

func decodeWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(args [1]string, r *http.Request) (params WatchStorageV1beta1NamespacedCSIStorageCapacityListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: allowWatchBookmarks.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "allowWatchBookmarks",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllowWatchBookmarksVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllowWatchBookmarksVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AllowWatchBookmarks.SetTo(paramsDotAllowWatchBookmarksVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: allowWatchBookmarks: parse")
			}
		}
	}
	// Decode query: continue.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "continue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContinueVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContinueVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Continue.SetTo(paramsDotContinueVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: continue: parse")
			}
		}
	}
	// Decode query: fieldSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFieldSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFieldSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FieldSelector.SetTo(paramsDotFieldSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: fieldSelector: parse")
			}
		}
	}
	// Decode query: labelSelector.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labelSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelSelectorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelSelectorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LabelSelector.SetTo(paramsDotLabelSelectorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labelSelector: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode path: namespace.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "namespace",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Namespace = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: namespace: parse")
			}
		} else {
			return params, errors.New("path: namespace: not specified")
		}
	}
	// Decode query: pretty.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pretty",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPrettyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPrettyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pretty.SetTo(paramsDotPrettyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pretty: parse")
			}
		}
	}
	// Decode query: resourceVersion.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersion",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersion.SetTo(paramsDotResourceVersionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersion: parse")
			}
		}
	}
	// Decode query: resourceVersionMatch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "resourceVersionMatch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResourceVersionMatchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResourceVersionMatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResourceVersionMatch.SetTo(paramsDotResourceVersionMatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: resourceVersionMatch: parse")
			}
		}
	}
	// Decode query: timeoutSeconds.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeoutSeconds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutSecondsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutSecondsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutSeconds.SetTo(paramsDotTimeoutSecondsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: timeoutSeconds: parse")
			}
		}
	}
	// Decode query: watch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "watch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWatchVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWatchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Watch.SetTo(paramsDotWatchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: watch: parse")
			}
		}
	}
	return params, nil
}
