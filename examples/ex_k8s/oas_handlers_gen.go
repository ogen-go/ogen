// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// HandleGetAPIVersionsRequest handles getAPIVersions operation.
//
// GET /apis/
func (s *Server) handleGetAPIVersionsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAPIVersions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAPIVersions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAPIVersions",
			ID:   "getAPIVersions",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAPIVersions", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAPIVersionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAPIVersions",
			OperationID:   "getAPIVersions",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAPIVersionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAPIVersions(ctx)
			},
		)
	} else {
		response, err = s.h.GetAPIVersions(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAPIVersionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAdmissionregistrationAPIGroupRequest handles getAdmissionregistrationAPIGroup operation.
//
// GET /apis/admissionregistration.k8s.io/
func (s *Server) handleGetAdmissionregistrationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAdmissionregistrationAPIGroup",
			ID:   "getAdmissionregistrationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAdmissionregistrationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAdmissionregistrationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAdmissionregistrationAPIGroup",
			OperationID:   "getAdmissionregistrationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAdmissionregistrationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAdmissionregistrationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetAdmissionregistrationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAdmissionregistrationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAdmissionregistrationV1APIResourcesRequest handles getAdmissionregistrationV1APIResources operation.
//
// GET /apis/admissionregistration.k8s.io/v1/
func (s *Server) handleGetAdmissionregistrationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAdmissionregistrationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAdmissionregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAdmissionregistrationV1APIResources",
			ID:   "getAdmissionregistrationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAdmissionregistrationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAdmissionregistrationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAdmissionregistrationV1APIResources",
			OperationID:   "getAdmissionregistrationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAdmissionregistrationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAdmissionregistrationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAdmissionregistrationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAdmissionregistrationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetApiextensionsAPIGroupRequest handles getApiextensionsAPIGroup operation.
//
// GET /apis/apiextensions.k8s.io/
func (s *Server) handleGetApiextensionsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiextensionsAPIGroup",
			ID:   "getApiextensionsAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetApiextensionsAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetApiextensionsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetApiextensionsAPIGroup",
			OperationID:   "getApiextensionsAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiextensionsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetApiextensionsAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetApiextensionsAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiextensionsAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetApiextensionsV1APIResourcesRequest handles getApiextensionsV1APIResources operation.
//
// GET /apis/apiextensions.k8s.io/v1/
func (s *Server) handleGetApiextensionsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiextensionsV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiextensionsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiextensionsV1APIResources",
			ID:   "getApiextensionsV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetApiextensionsV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetApiextensionsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetApiextensionsV1APIResources",
			OperationID:   "getApiextensionsV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiextensionsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetApiextensionsV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetApiextensionsV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiextensionsV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetApiregistrationAPIGroupRequest handles getApiregistrationAPIGroup operation.
//
// GET /apis/apiregistration.k8s.io/
func (s *Server) handleGetApiregistrationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiregistrationAPIGroup",
			ID:   "getApiregistrationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetApiregistrationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetApiregistrationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetApiregistrationAPIGroup",
			OperationID:   "getApiregistrationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiregistrationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetApiregistrationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetApiregistrationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiregistrationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetApiregistrationV1APIResourcesRequest handles getApiregistrationV1APIResources operation.
//
// GET /apis/apiregistration.k8s.io/v1/
func (s *Server) handleGetApiregistrationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getApiregistrationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetApiregistrationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetApiregistrationV1APIResources",
			ID:   "getApiregistrationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetApiregistrationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetApiregistrationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetApiregistrationV1APIResources",
			OperationID:   "getApiregistrationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetApiregistrationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetApiregistrationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetApiregistrationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetApiregistrationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAppsAPIGroupRequest handles getAppsAPIGroup operation.
//
// GET /apis/apps/
func (s *Server) handleGetAppsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAppsAPIGroup",
			ID:   "getAppsAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAppsAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAppsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAppsAPIGroup",
			OperationID:   "getAppsAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAppsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAppsAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetAppsAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppsAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAppsV1APIResourcesRequest handles getAppsV1APIResources operation.
//
// GET /apis/apps/v1/
func (s *Server) handleGetAppsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAppsV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAppsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAppsV1APIResources",
			ID:   "getAppsV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAppsV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAppsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAppsV1APIResources",
			OperationID:   "getAppsV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAppsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAppsV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAppsV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppsV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAuthenticationAPIGroupRequest handles getAuthenticationAPIGroup operation.
//
// GET /apis/authentication.k8s.io/
func (s *Server) handleGetAuthenticationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthenticationAPIGroup",
			ID:   "getAuthenticationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAuthenticationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAuthenticationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAuthenticationAPIGroup",
			OperationID:   "getAuthenticationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthenticationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAuthenticationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetAuthenticationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthenticationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAuthenticationV1APIResourcesRequest handles getAuthenticationV1APIResources operation.
//
// GET /apis/authentication.k8s.io/v1/
func (s *Server) handleGetAuthenticationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthenticationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthenticationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthenticationV1APIResources",
			ID:   "getAuthenticationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAuthenticationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAuthenticationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAuthenticationV1APIResources",
			OperationID:   "getAuthenticationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthenticationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAuthenticationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAuthenticationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthenticationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAuthorizationAPIGroupRequest handles getAuthorizationAPIGroup operation.
//
// GET /apis/authorization.k8s.io/
func (s *Server) handleGetAuthorizationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthorizationAPIGroup",
			ID:   "getAuthorizationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAuthorizationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAuthorizationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAuthorizationAPIGroup",
			OperationID:   "getAuthorizationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthorizationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAuthorizationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetAuthorizationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthorizationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAuthorizationV1APIResourcesRequest handles getAuthorizationV1APIResources operation.
//
// GET /apis/authorization.k8s.io/v1/
func (s *Server) handleGetAuthorizationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAuthorizationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAuthorizationV1APIResources",
			ID:   "getAuthorizationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAuthorizationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAuthorizationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAuthorizationV1APIResources",
			OperationID:   "getAuthorizationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthorizationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAuthorizationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAuthorizationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAutoscalingAPIGroupRequest handles getAutoscalingAPIGroup operation.
//
// GET /apis/autoscaling/
func (s *Server) handleGetAutoscalingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingAPIGroup",
			ID:   "getAutoscalingAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAutoscalingAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAutoscalingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAutoscalingAPIGroup",
			OperationID:   "getAutoscalingAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAutoscalingAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetAutoscalingAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAutoscalingV1APIResourcesRequest handles getAutoscalingV1APIResources operation.
//
// GET /apis/autoscaling/v1/
func (s *Server) handleGetAutoscalingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV1APIResources",
			ID:   "getAutoscalingV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAutoscalingV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAutoscalingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAutoscalingV1APIResources",
			OperationID:   "getAutoscalingV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAutoscalingV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAutoscalingV2beta1APIResourcesRequest handles getAutoscalingV2beta1APIResources operation.
//
// GET /apis/autoscaling/v2beta1/
func (s *Server) handleGetAutoscalingV2beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV2beta1APIResources",
			ID:   "getAutoscalingV2beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAutoscalingV2beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAutoscalingV2beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAutoscalingV2beta1APIResources",
			OperationID:   "getAutoscalingV2beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV2beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAutoscalingV2beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV2beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV2beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetAutoscalingV2beta2APIResourcesRequest handles getAutoscalingV2beta2APIResources operation.
//
// GET /apis/autoscaling/v2beta2/
func (s *Server) handleGetAutoscalingV2beta2APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAutoscalingV2beta2APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAutoscalingV2beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAutoscalingV2beta2APIResources",
			ID:   "getAutoscalingV2beta2APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetAutoscalingV2beta2APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAutoscalingV2beta2APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetAutoscalingV2beta2APIResources",
			OperationID:   "getAutoscalingV2beta2APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAutoscalingV2beta2APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetAutoscalingV2beta2APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetAutoscalingV2beta2APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAutoscalingV2beta2APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetBatchAPIGroupRequest handles getBatchAPIGroup operation.
//
// GET /apis/batch/
func (s *Server) handleGetBatchAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchAPIGroup",
			ID:   "getBatchAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetBatchAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBatchAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetBatchAPIGroup",
			OperationID:   "getBatchAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetBatchAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetBatchAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetBatchV1APIResourcesRequest handles getBatchV1APIResources operation.
//
// GET /apis/batch/v1/
func (s *Server) handleGetBatchV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchV1APIResources",
			ID:   "getBatchV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetBatchV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBatchV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetBatchV1APIResources",
			OperationID:   "getBatchV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetBatchV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetBatchV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetBatchV1beta1APIResourcesRequest handles getBatchV1beta1APIResources operation.
//
// GET /apis/batch/v1beta1/
func (s *Server) handleGetBatchV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBatchV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBatchV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBatchV1beta1APIResources",
			ID:   "getBatchV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetBatchV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBatchV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetBatchV1beta1APIResources",
			OperationID:   "getBatchV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetBatchV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetBatchV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetBatchV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBatchV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCertificatesAPIGroupRequest handles getCertificatesAPIGroup operation.
//
// GET /apis/certificates.k8s.io/
func (s *Server) handleGetCertificatesAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificatesAPIGroup",
			ID:   "getCertificatesAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCertificatesAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCertificatesAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCertificatesAPIGroup",
			OperationID:   "getCertificatesAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCertificatesAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCertificatesAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetCertificatesAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificatesAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCertificatesV1APIResourcesRequest handles getCertificatesV1APIResources operation.
//
// GET /apis/certificates.k8s.io/v1/
func (s *Server) handleGetCertificatesV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCertificatesV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCertificatesV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCertificatesV1APIResources",
			ID:   "getCertificatesV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCertificatesV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCertificatesV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCertificatesV1APIResources",
			OperationID:   "getCertificatesV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCertificatesV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCertificatesV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetCertificatesV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCertificatesV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCodeVersionRequest handles getCodeVersion operation.
//
// GET /version/
func (s *Server) handleGetCodeVersionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCodeVersion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCodeVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCodeVersion",
			ID:   "getCodeVersion",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCodeVersion", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCodeVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCodeVersion",
			OperationID:   "getCodeVersion",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCodeVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCodeVersion(ctx)
			},
		)
	} else {
		response, err = s.h.GetCodeVersion(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCodeVersionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCoordinationAPIGroupRequest handles getCoordinationAPIGroup operation.
//
// GET /apis/coordination.k8s.io/
func (s *Server) handleGetCoordinationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoordinationAPIGroup",
			ID:   "getCoordinationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCoordinationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCoordinationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCoordinationAPIGroup",
			OperationID:   "getCoordinationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoordinationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCoordinationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetCoordinationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoordinationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCoordinationV1APIResourcesRequest handles getCoordinationV1APIResources operation.
//
// GET /apis/coordination.k8s.io/v1/
func (s *Server) handleGetCoordinationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoordinationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoordinationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoordinationV1APIResources",
			ID:   "getCoordinationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCoordinationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCoordinationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCoordinationV1APIResources",
			OperationID:   "getCoordinationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoordinationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCoordinationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetCoordinationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoordinationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCoreAPIVersionsRequest handles getCoreAPIVersions operation.
//
// GET /api/
func (s *Server) handleGetCoreAPIVersionsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreAPIVersions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreAPIVersions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoreAPIVersions",
			ID:   "getCoreAPIVersions",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCoreAPIVersions", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCoreAPIVersionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCoreAPIVersions",
			OperationID:   "getCoreAPIVersions",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoreAPIVersionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCoreAPIVersions(ctx)
			},
		)
	} else {
		response, err = s.h.GetCoreAPIVersions(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoreAPIVersionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetCoreV1APIResourcesRequest handles getCoreV1APIResources operation.
//
// GET /api/v1/
func (s *Server) handleGetCoreV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCoreV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetCoreV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetCoreV1APIResources",
			ID:   "getCoreV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetCoreV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetCoreV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetCoreV1APIResources",
			OperationID:   "getCoreV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetCoreV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetCoreV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetCoreV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetCoreV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetDiscoveryAPIGroupRequest handles getDiscoveryAPIGroup operation.
//
// GET /apis/discovery.k8s.io/
func (s *Server) handleGetDiscoveryAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryAPIGroup",
			ID:   "getDiscoveryAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetDiscoveryAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDiscoveryAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetDiscoveryAPIGroup",
			OperationID:   "getDiscoveryAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetDiscoveryAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetDiscoveryAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetDiscoveryV1APIResourcesRequest handles getDiscoveryV1APIResources operation.
//
// GET /apis/discovery.k8s.io/v1/
func (s *Server) handleGetDiscoveryV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryV1APIResources",
			ID:   "getDiscoveryV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetDiscoveryV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDiscoveryV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetDiscoveryV1APIResources",
			OperationID:   "getDiscoveryV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetDiscoveryV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetDiscoveryV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetDiscoveryV1beta1APIResourcesRequest handles getDiscoveryV1beta1APIResources operation.
//
// GET /apis/discovery.k8s.io/v1beta1/
func (s *Server) handleGetDiscoveryV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDiscoveryV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDiscoveryV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDiscoveryV1beta1APIResources",
			ID:   "getDiscoveryV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetDiscoveryV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDiscoveryV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetDiscoveryV1beta1APIResources",
			OperationID:   "getDiscoveryV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDiscoveryV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetDiscoveryV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetDiscoveryV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDiscoveryV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetEventsAPIGroupRequest handles getEventsAPIGroup operation.
//
// GET /apis/events.k8s.io/
func (s *Server) handleGetEventsAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsAPIGroup",
			ID:   "getEventsAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetEventsAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEventsAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetEventsAPIGroup",
			OperationID:   "getEventsAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetEventsAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetEventsAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetEventsV1APIResourcesRequest handles getEventsV1APIResources operation.
//
// GET /apis/events.k8s.io/v1/
func (s *Server) handleGetEventsV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsV1APIResources",
			ID:   "getEventsV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetEventsV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEventsV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetEventsV1APIResources",
			OperationID:   "getEventsV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetEventsV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetEventsV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetEventsV1beta1APIResourcesRequest handles getEventsV1beta1APIResources operation.
//
// GET /apis/events.k8s.io/v1beta1/
func (s *Server) handleGetEventsV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEventsV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEventsV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventsV1beta1APIResources",
			ID:   "getEventsV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetEventsV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEventsV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetEventsV1beta1APIResources",
			OperationID:   "getEventsV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetEventsV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetEventsV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetEventsV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetFlowcontrolApiserverAPIGroupRequest handles getFlowcontrolApiserverAPIGroup operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/
func (s *Server) handleGetFlowcontrolApiserverAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverAPIGroup",
			ID:   "getFlowcontrolApiserverAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetFlowcontrolApiserverAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetFlowcontrolApiserverAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetFlowcontrolApiserverAPIGroup",
			OperationID:   "getFlowcontrolApiserverAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetFlowcontrolApiserverAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetFlowcontrolApiserverV1beta1APIResourcesRequest handles getFlowcontrolApiserverV1beta1APIResources operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/
func (s *Server) handleGetFlowcontrolApiserverV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverV1beta1APIResources",
			ID:   "getFlowcontrolApiserverV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetFlowcontrolApiserverV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetFlowcontrolApiserverV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetFlowcontrolApiserverV1beta1APIResources",
			OperationID:   "getFlowcontrolApiserverV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetFlowcontrolApiserverV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetFlowcontrolApiserverV1beta2APIResourcesRequest handles getFlowcontrolApiserverV1beta2APIResources operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/
func (s *Server) handleGetFlowcontrolApiserverV1beta2APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFlowcontrolApiserverV1beta2APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetFlowcontrolApiserverV1beta2APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetFlowcontrolApiserverV1beta2APIResources",
			ID:   "getFlowcontrolApiserverV1beta2APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetFlowcontrolApiserverV1beta2APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetFlowcontrolApiserverV1beta2APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetFlowcontrolApiserverV1beta2APIResources",
			OperationID:   "getFlowcontrolApiserverV1beta2APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetFlowcontrolApiserverV1beta2APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetFlowcontrolApiserverV1beta2APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetFlowcontrolApiserverV1beta2APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetFlowcontrolApiserverV1beta2APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetInternalApiserverAPIGroupRequest handles getInternalApiserverAPIGroup operation.
//
// GET /apis/internal.apiserver.k8s.io/
func (s *Server) handleGetInternalApiserverAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetInternalApiserverAPIGroup",
			ID:   "getInternalApiserverAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetInternalApiserverAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetInternalApiserverAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetInternalApiserverAPIGroup",
			OperationID:   "getInternalApiserverAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetInternalApiserverAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetInternalApiserverAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetInternalApiserverAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetInternalApiserverAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetInternalApiserverV1alpha1APIResourcesRequest handles getInternalApiserverV1alpha1APIResources operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/
func (s *Server) handleGetInternalApiserverV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInternalApiserverV1alpha1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetInternalApiserverV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetInternalApiserverV1alpha1APIResources",
			ID:   "getInternalApiserverV1alpha1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetInternalApiserverV1alpha1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetInternalApiserverV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetInternalApiserverV1alpha1APIResources",
			OperationID:   "getInternalApiserverV1alpha1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetInternalApiserverV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetInternalApiserverV1alpha1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetInternalApiserverV1alpha1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetInternalApiserverV1alpha1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNetworkingAPIGroupRequest handles getNetworkingAPIGroup operation.
//
// GET /apis/networking.k8s.io/
func (s *Server) handleGetNetworkingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkingAPIGroup",
			ID:   "getNetworkingAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNetworkingAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNetworkingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNetworkingAPIGroup",
			OperationID:   "getNetworkingAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNetworkingAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetNetworkingAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkingAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNetworkingV1APIResourcesRequest handles getNetworkingV1APIResources operation.
//
// GET /apis/networking.k8s.io/v1/
func (s *Server) handleGetNetworkingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkingV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNetworkingV1APIResources",
			ID:   "getNetworkingV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNetworkingV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNetworkingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNetworkingV1APIResources",
			OperationID:   "getNetworkingV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNetworkingV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetNetworkingV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkingV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNodeAPIGroupRequest handles getNodeAPIGroup operation.
//
// GET /apis/node.k8s.io/
func (s *Server) handleGetNodeAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeAPIGroup",
			ID:   "getNodeAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNodeAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNodeAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNodeAPIGroup",
			OperationID:   "getNodeAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNodeAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetNodeAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNodeV1APIResourcesRequest handles getNodeV1APIResources operation.
//
// GET /apis/node.k8s.io/v1/
func (s *Server) handleGetNodeV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1APIResources",
			ID:   "getNodeV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNodeV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNodeV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNodeV1APIResources",
			OperationID:   "getNodeV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNodeV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetNodeV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNodeV1alpha1APIResourcesRequest handles getNodeV1alpha1APIResources operation.
//
// GET /apis/node.k8s.io/v1alpha1/
func (s *Server) handleGetNodeV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1alpha1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1alpha1APIResources",
			ID:   "getNodeV1alpha1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNodeV1alpha1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNodeV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNodeV1alpha1APIResources",
			OperationID:   "getNodeV1alpha1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNodeV1alpha1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetNodeV1alpha1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1alpha1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetNodeV1beta1APIResourcesRequest handles getNodeV1beta1APIResources operation.
//
// GET /apis/node.k8s.io/v1beta1/
func (s *Server) handleGetNodeV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNodeV1beta1APIResources",
			ID:   "getNodeV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetNodeV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNodeV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetNodeV1beta1APIResources",
			OperationID:   "getNodeV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetNodeV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetNodeV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetPolicyAPIGroupRequest handles getPolicyAPIGroup operation.
//
// GET /apis/policy/
func (s *Server) handleGetPolicyAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyAPIGroup",
			ID:   "getPolicyAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetPolicyAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPolicyAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetPolicyAPIGroup",
			OperationID:   "getPolicyAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetPolicyAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetPolicyAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetPolicyV1APIResourcesRequest handles getPolicyV1APIResources operation.
//
// GET /apis/policy/v1/
func (s *Server) handleGetPolicyV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyV1APIResources",
			ID:   "getPolicyV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetPolicyV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPolicyV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetPolicyV1APIResources",
			OperationID:   "getPolicyV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetPolicyV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetPolicyV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetPolicyV1beta1APIResourcesRequest handles getPolicyV1beta1APIResources operation.
//
// GET /apis/policy/v1beta1/
func (s *Server) handleGetPolicyV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPolicyV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPolicyV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPolicyV1beta1APIResources",
			ID:   "getPolicyV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetPolicyV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPolicyV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetPolicyV1beta1APIResources",
			OperationID:   "getPolicyV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPolicyV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetPolicyV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetPolicyV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPolicyV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetRbacAuthorizationAPIGroupRequest handles getRbacAuthorizationAPIGroup operation.
//
// GET /apis/rbac.authorization.k8s.io/
func (s *Server) handleGetRbacAuthorizationAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRbacAuthorizationAPIGroup",
			ID:   "getRbacAuthorizationAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetRbacAuthorizationAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetRbacAuthorizationAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetRbacAuthorizationAPIGroup",
			OperationID:   "getRbacAuthorizationAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetRbacAuthorizationAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetRbacAuthorizationAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetRbacAuthorizationAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRbacAuthorizationAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetRbacAuthorizationV1APIResourcesRequest handles getRbacAuthorizationV1APIResources operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/
func (s *Server) handleGetRbacAuthorizationV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRbacAuthorizationV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRbacAuthorizationV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRbacAuthorizationV1APIResources",
			ID:   "getRbacAuthorizationV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetRbacAuthorizationV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetRbacAuthorizationV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetRbacAuthorizationV1APIResources",
			OperationID:   "getRbacAuthorizationV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetRbacAuthorizationV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetRbacAuthorizationV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetRbacAuthorizationV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRbacAuthorizationV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetSchedulingAPIGroupRequest handles getSchedulingAPIGroup operation.
//
// GET /apis/scheduling.k8s.io/
func (s *Server) handleGetSchedulingAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSchedulingAPIGroup",
			ID:   "getSchedulingAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetSchedulingAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSchedulingAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetSchedulingAPIGroup",
			OperationID:   "getSchedulingAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSchedulingAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetSchedulingAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetSchedulingAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSchedulingAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetSchedulingV1APIResourcesRequest handles getSchedulingV1APIResources operation.
//
// GET /apis/scheduling.k8s.io/v1/
func (s *Server) handleGetSchedulingV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSchedulingV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSchedulingV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSchedulingV1APIResources",
			ID:   "getSchedulingV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetSchedulingV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetSchedulingV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetSchedulingV1APIResources",
			OperationID:   "getSchedulingV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSchedulingV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetSchedulingV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetSchedulingV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSchedulingV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetServiceAccountIssuerOpenIDConfigurationRequest handles getServiceAccountIssuerOpenIDConfiguration operation.
//
// GET /.well-known/openid-configuration/
func (s *Server) handleGetServiceAccountIssuerOpenIDConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServiceAccountIssuerOpenIDConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetServiceAccountIssuerOpenIDConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetServiceAccountIssuerOpenIDConfiguration",
			ID:   "getServiceAccountIssuerOpenIDConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetServiceAccountIssuerOpenIDConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetServiceAccountIssuerOpenIDConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetServiceAccountIssuerOpenIDConfiguration",
			OperationID:   "getServiceAccountIssuerOpenIDConfiguration",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetServiceAccountIssuerOpenIDConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetServiceAccountIssuerOpenIDConfiguration(ctx)
			},
		)
	} else {
		response, err = s.h.GetServiceAccountIssuerOpenIDConfiguration(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetServiceAccountIssuerOpenIDConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetStorageAPIGroupRequest handles getStorageAPIGroup operation.
//
// GET /apis/storage.k8s.io/
func (s *Server) handleGetStorageAPIGroupRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageAPIGroup"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageAPIGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageAPIGroup",
			ID:   "getStorageAPIGroup",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetStorageAPIGroup", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStorageAPIGroupRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetStorageAPIGroup",
			OperationID:   "getStorageAPIGroup",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageAPIGroupRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetStorageAPIGroup(ctx)
			},
		)
	} else {
		response, err = s.h.GetStorageAPIGroup(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageAPIGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetStorageV1APIResourcesRequest handles getStorageV1APIResources operation.
//
// GET /apis/storage.k8s.io/v1/
func (s *Server) handleGetStorageV1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1APIResources",
			ID:   "getStorageV1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetStorageV1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStorageV1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetStorageV1APIResources",
			OperationID:   "getStorageV1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetStorageV1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetStorageV1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetStorageV1alpha1APIResourcesRequest handles getStorageV1alpha1APIResources operation.
//
// GET /apis/storage.k8s.io/v1alpha1/
func (s *Server) handleGetStorageV1alpha1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1alpha1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1alpha1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1alpha1APIResources",
			ID:   "getStorageV1alpha1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetStorageV1alpha1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStorageV1alpha1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetStorageV1alpha1APIResources",
			OperationID:   "getStorageV1alpha1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1alpha1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetStorageV1alpha1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetStorageV1alpha1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1alpha1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetStorageV1beta1APIResourcesRequest handles getStorageV1beta1APIResources operation.
//
// GET /apis/storage.k8s.io/v1beta1/
func (s *Server) handleGetStorageV1beta1APIResourcesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStorageV1beta1APIResources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStorageV1beta1APIResources",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStorageV1beta1APIResources",
			ID:   "getStorageV1beta1APIResources",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "GetStorageV1beta1APIResources", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStorageV1beta1APIResourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GetStorageV1beta1APIResources",
			OperationID:   "getStorageV1beta1APIResources",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetStorageV1beta1APIResourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GetStorageV1beta1APIResources(ctx)
			},
		)
	} else {
		response, err = s.h.GetStorageV1beta1APIResources(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStorageV1beta1APIResourcesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAdmissionregistrationV1MutatingWebhookConfigurationRequest handles listAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1MutatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "listAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAdmissionregistrationV1MutatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationID:   "listAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = ListAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles listAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations
func (s *Server) handleListAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "listAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAdmissionregistrationV1ValidatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationID:   "listAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = ListAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListApiextensionsV1CustomResourceDefinitionRequest handles listApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions
func (s *Server) handleListApiextensionsV1CustomResourceDefinitionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiextensionsV1CustomResourceDefinition"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListApiextensionsV1CustomResourceDefinition",
			ID:   "listApiextensionsV1CustomResourceDefinition",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListApiextensionsV1CustomResourceDefinition", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListApiextensionsV1CustomResourceDefinition",
			OperationID:   "listApiextensionsV1CustomResourceDefinition",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListApiextensionsV1CustomResourceDefinitionParams
			Response = ListApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListApiextensionsV1CustomResourceDefinition(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListApiregistrationV1APIServiceRequest handles listApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices
func (s *Server) handleListApiregistrationV1APIServiceRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listApiregistrationV1APIService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListApiregistrationV1APIService",
			ID:   "listApiregistrationV1APIService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListApiregistrationV1APIService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListApiregistrationV1APIService",
			OperationID:   "listApiregistrationV1APIService",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListApiregistrationV1APIServiceParams
			Response = ListApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListApiregistrationV1APIService(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1ControllerRevisionForAllNamespacesRequest handles listAppsV1ControllerRevisionForAllNamespaces operation.
//
// GET /apis/apps/v1/controllerrevisions
func (s *Server) handleListAppsV1ControllerRevisionForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ControllerRevisionForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ControllerRevisionForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1ControllerRevisionForAllNamespaces",
			ID:   "listAppsV1ControllerRevisionForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1ControllerRevisionForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1ControllerRevisionForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1ControllerRevisionForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1ControllerRevisionForAllNamespaces",
			OperationID:   "listAppsV1ControllerRevisionForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1ControllerRevisionForAllNamespacesParams
			Response = ListAppsV1ControllerRevisionForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1ControllerRevisionForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1ControllerRevisionForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1ControllerRevisionForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1ControllerRevisionForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1DaemonSetForAllNamespacesRequest handles listAppsV1DaemonSetForAllNamespaces operation.
//
// GET /apis/apps/v1/daemonsets
func (s *Server) handleListAppsV1DaemonSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DaemonSetForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DaemonSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1DaemonSetForAllNamespaces",
			ID:   "listAppsV1DaemonSetForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1DaemonSetForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1DaemonSetForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1DaemonSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1DaemonSetForAllNamespaces",
			OperationID:   "listAppsV1DaemonSetForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1DaemonSetForAllNamespacesParams
			Response = ListAppsV1DaemonSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1DaemonSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1DaemonSetForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1DaemonSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1DaemonSetForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1DeploymentForAllNamespacesRequest handles listAppsV1DeploymentForAllNamespaces operation.
//
// GET /apis/apps/v1/deployments
func (s *Server) handleListAppsV1DeploymentForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1DeploymentForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1DeploymentForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1DeploymentForAllNamespaces",
			ID:   "listAppsV1DeploymentForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1DeploymentForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1DeploymentForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1DeploymentForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1DeploymentForAllNamespaces",
			OperationID:   "listAppsV1DeploymentForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1DeploymentForAllNamespacesParams
			Response = ListAppsV1DeploymentForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1DeploymentForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1DeploymentForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1DeploymentForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1DeploymentForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1NamespacedControllerRevisionRequest handles listAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions
func (s *Server) handleListAppsV1NamespacedControllerRevisionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedControllerRevision"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedControllerRevision",
			ID:   "listAppsV1NamespacedControllerRevision",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1NamespacedControllerRevision", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1NamespacedControllerRevision",
			OperationID:   "listAppsV1NamespacedControllerRevision",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedControllerRevisionParams
			Response = ListAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1NamespacedControllerRevision(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1NamespacedDaemonSetRequest handles listAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets
func (s *Server) handleListAppsV1NamespacedDaemonSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDaemonSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedDaemonSet",
			ID:   "listAppsV1NamespacedDaemonSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1NamespacedDaemonSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1NamespacedDaemonSet",
			OperationID:   "listAppsV1NamespacedDaemonSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedDaemonSetParams
			Response = ListAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1NamespacedDaemonSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1NamespacedDeploymentRequest handles listAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments
func (s *Server) handleListAppsV1NamespacedDeploymentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedDeployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedDeployment",
			ID:   "listAppsV1NamespacedDeployment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1NamespacedDeployment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1NamespacedDeployment",
			OperationID:   "listAppsV1NamespacedDeployment",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedDeploymentParams
			Response = ListAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1NamespacedDeployment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1NamespacedReplicaSetRequest handles listAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets
func (s *Server) handleListAppsV1NamespacedReplicaSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedReplicaSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedReplicaSet",
			ID:   "listAppsV1NamespacedReplicaSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1NamespacedReplicaSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1NamespacedReplicaSet",
			OperationID:   "listAppsV1NamespacedReplicaSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedReplicaSetParams
			Response = ListAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1NamespacedReplicaSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1NamespacedStatefulSetRequest handles listAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets
func (s *Server) handleListAppsV1NamespacedStatefulSetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1NamespacedStatefulSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1NamespacedStatefulSet",
			ID:   "listAppsV1NamespacedStatefulSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1NamespacedStatefulSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1NamespacedStatefulSet",
			OperationID:   "listAppsV1NamespacedStatefulSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1NamespacedStatefulSetParams
			Response = ListAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1NamespacedStatefulSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1ReplicaSetForAllNamespacesRequest handles listAppsV1ReplicaSetForAllNamespaces operation.
//
// GET /apis/apps/v1/replicasets
func (s *Server) handleListAppsV1ReplicaSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1ReplicaSetForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1ReplicaSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1ReplicaSetForAllNamespaces",
			ID:   "listAppsV1ReplicaSetForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1ReplicaSetForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1ReplicaSetForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1ReplicaSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1ReplicaSetForAllNamespaces",
			OperationID:   "listAppsV1ReplicaSetForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1ReplicaSetForAllNamespacesParams
			Response = ListAppsV1ReplicaSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1ReplicaSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1ReplicaSetForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1ReplicaSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1ReplicaSetForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAppsV1StatefulSetForAllNamespacesRequest handles listAppsV1StatefulSetForAllNamespaces operation.
//
// GET /apis/apps/v1/statefulsets
func (s *Server) handleListAppsV1StatefulSetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAppsV1StatefulSetForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAppsV1StatefulSetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAppsV1StatefulSetForAllNamespaces",
			ID:   "listAppsV1StatefulSetForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAppsV1StatefulSetForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAppsV1StatefulSetForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAppsV1StatefulSetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAppsV1StatefulSetForAllNamespaces",
			OperationID:   "listAppsV1StatefulSetForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAppsV1StatefulSetForAllNamespacesParams
			Response = ListAppsV1StatefulSetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAppsV1StatefulSetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAppsV1StatefulSetForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAppsV1StatefulSetForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAppsV1StatefulSetForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			OperationID:   "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationID:   "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta1/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			OperationID:   "listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationID:   "listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest handles listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta2/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			ID:   "listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			OperationID:   "listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams
			Response = ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationID:   "listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = ListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1CronJobForAllNamespacesRequest handles listBatchV1CronJobForAllNamespaces operation.
//
// GET /apis/batch/v1/cronjobs
func (s *Server) handleListBatchV1CronJobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1CronJobForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1CronJobForAllNamespaces",
			ID:   "listBatchV1CronJobForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1CronJobForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1CronJobForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1CronJobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1CronJobForAllNamespaces",
			OperationID:   "listBatchV1CronJobForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1CronJobForAllNamespacesParams
			Response = ListBatchV1CronJobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1CronJobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1CronJobForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1CronJobForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1JobForAllNamespacesRequest handles listBatchV1JobForAllNamespaces operation.
//
// GET /apis/batch/v1/jobs
func (s *Server) handleListBatchV1JobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1JobForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1JobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1JobForAllNamespaces",
			ID:   "listBatchV1JobForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1JobForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1JobForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1JobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1JobForAllNamespaces",
			OperationID:   "listBatchV1JobForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1JobForAllNamespacesParams
			Response = ListBatchV1JobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1JobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1JobForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1JobForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1JobForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1NamespacedCronJobRequest handles listBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1NamespacedCronJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1NamespacedCronJob",
			ID:   "listBatchV1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1NamespacedCronJob",
			OperationID:   "listBatchV1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1NamespacedCronJobParams
			Response = ListBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1NamespacedJobRequest handles listBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs
func (s *Server) handleListBatchV1NamespacedJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1NamespacedJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1NamespacedJob",
			ID:   "listBatchV1NamespacedJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1NamespacedJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1NamespacedJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1NamespacedJob",
			OperationID:   "listBatchV1NamespacedJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1NamespacedJobParams
			Response = ListBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1NamespacedJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1NamespacedJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1beta1CronJobForAllNamespacesRequest handles listBatchV1beta1CronJobForAllNamespaces operation.
//
// GET /apis/batch/v1beta1/cronjobs
func (s *Server) handleListBatchV1beta1CronJobForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1CronJobForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1CronJobForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1beta1CronJobForAllNamespaces",
			ID:   "listBatchV1beta1CronJobForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1beta1CronJobForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1beta1CronJobForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1beta1CronJobForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1beta1CronJobForAllNamespaces",
			OperationID:   "listBatchV1beta1CronJobForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1beta1CronJobForAllNamespacesParams
			Response = ListBatchV1beta1CronJobForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1beta1CronJobForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1beta1CronJobForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1beta1CronJobForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1beta1CronJobForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListBatchV1beta1NamespacedCronJobRequest handles listBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs
func (s *Server) handleListBatchV1beta1NamespacedCronJobRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listBatchV1beta1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListBatchV1beta1NamespacedCronJob",
			ID:   "listBatchV1beta1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListBatchV1beta1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListBatchV1beta1NamespacedCronJob",
			OperationID:   "listBatchV1beta1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListBatchV1beta1NamespacedCronJobParams
			Response = ListBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListBatchV1beta1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCertificatesV1CertificateSigningRequestRequest handles listCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests
func (s *Server) handleListCertificatesV1CertificateSigningRequestRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCertificatesV1CertificateSigningRequest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCertificatesV1CertificateSigningRequest",
			ID:   "listCertificatesV1CertificateSigningRequest",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCertificatesV1CertificateSigningRequest", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCertificatesV1CertificateSigningRequest",
			OperationID:   "listCertificatesV1CertificateSigningRequest",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCertificatesV1CertificateSigningRequestParams
			Response = ListCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCertificatesV1CertificateSigningRequest(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoordinationV1LeaseForAllNamespacesRequest handles listCoordinationV1LeaseForAllNamespaces operation.
//
// GET /apis/coordination.k8s.io/v1/leases
func (s *Server) handleListCoordinationV1LeaseForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1LeaseForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1LeaseForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoordinationV1LeaseForAllNamespaces",
			ID:   "listCoordinationV1LeaseForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoordinationV1LeaseForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoordinationV1LeaseForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoordinationV1LeaseForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoordinationV1LeaseForAllNamespaces",
			OperationID:   "listCoordinationV1LeaseForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoordinationV1LeaseForAllNamespacesParams
			Response = ListCoordinationV1LeaseForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoordinationV1LeaseForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoordinationV1LeaseForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoordinationV1LeaseForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoordinationV1LeaseForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoordinationV1NamespacedLeaseRequest handles listCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases
func (s *Server) handleListCoordinationV1NamespacedLeaseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoordinationV1NamespacedLease"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoordinationV1NamespacedLease",
			ID:   "listCoordinationV1NamespacedLease",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoordinationV1NamespacedLease", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoordinationV1NamespacedLease",
			OperationID:   "listCoordinationV1NamespacedLease",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoordinationV1NamespacedLeaseParams
			Response = ListCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoordinationV1NamespacedLease(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ComponentStatusRequest handles listCoreV1ComponentStatus operation.
//
// GET /api/v1/componentstatuses
func (s *Server) handleListCoreV1ComponentStatusRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ComponentStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ComponentStatus",
			ID:   "listCoreV1ComponentStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ComponentStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ComponentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ComponentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ComponentStatus",
			OperationID:   "listCoreV1ComponentStatus",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ComponentStatusParams
			Response = ListCoreV1ComponentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ComponentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ComponentStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ComponentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ComponentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ConfigMapForAllNamespacesRequest handles listCoreV1ConfigMapForAllNamespaces operation.
//
// GET /api/v1/configmaps
func (s *Server) handleListCoreV1ConfigMapForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ConfigMapForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ConfigMapForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ConfigMapForAllNamespaces",
			ID:   "listCoreV1ConfigMapForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ConfigMapForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ConfigMapForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ConfigMapForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ConfigMapForAllNamespaces",
			OperationID:   "listCoreV1ConfigMapForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ConfigMapForAllNamespacesParams
			Response = ListCoreV1ConfigMapForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ConfigMapForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ConfigMapForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ConfigMapForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ConfigMapForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1EndpointsForAllNamespacesRequest handles listCoreV1EndpointsForAllNamespaces operation.
//
// GET /api/v1/endpoints
func (s *Server) handleListCoreV1EndpointsForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EndpointsForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EndpointsForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1EndpointsForAllNamespaces",
			ID:   "listCoreV1EndpointsForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1EndpointsForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1EndpointsForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1EndpointsForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1EndpointsForAllNamespaces",
			OperationID:   "listCoreV1EndpointsForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1EndpointsForAllNamespacesParams
			Response = ListCoreV1EndpointsForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1EndpointsForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1EndpointsForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1EndpointsForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1EndpointsForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1EventForAllNamespacesRequest handles listCoreV1EventForAllNamespaces operation.
//
// GET /api/v1/events
func (s *Server) handleListCoreV1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1EventForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1EventForAllNamespaces",
			ID:   "listCoreV1EventForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1EventForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1EventForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1EventForAllNamespaces",
			OperationID:   "listCoreV1EventForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1EventForAllNamespacesParams
			Response = ListCoreV1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1EventForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1EventForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1LimitRangeForAllNamespacesRequest handles listCoreV1LimitRangeForAllNamespaces operation.
//
// GET /api/v1/limitranges
func (s *Server) handleListCoreV1LimitRangeForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1LimitRangeForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1LimitRangeForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1LimitRangeForAllNamespaces",
			ID:   "listCoreV1LimitRangeForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1LimitRangeForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1LimitRangeForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1LimitRangeForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1LimitRangeForAllNamespaces",
			OperationID:   "listCoreV1LimitRangeForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1LimitRangeForAllNamespacesParams
			Response = ListCoreV1LimitRangeForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1LimitRangeForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1LimitRangeForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1LimitRangeForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1LimitRangeForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespaceRequest handles listCoreV1Namespace operation.
//
// GET /api/v1/namespaces
func (s *Server) handleListCoreV1NamespaceRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Namespace"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1Namespace",
			ID:   "listCoreV1Namespace",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1Namespace", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespaceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1Namespace",
			OperationID:   "listCoreV1Namespace",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespaceParams
			Response = ListCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1Namespace(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1Namespace(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespaceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedConfigMapRequest handles listCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/namespaces/{namespace}/configmaps
func (s *Server) handleListCoreV1NamespacedConfigMapRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedConfigMap"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedConfigMap",
			ID:   "listCoreV1NamespacedConfigMap",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedConfigMap", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedConfigMap",
			OperationID:   "listCoreV1NamespacedConfigMap",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedConfigMapParams
			Response = ListCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedConfigMap(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedEndpointsRequest handles listCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/namespaces/{namespace}/endpoints
func (s *Server) handleListCoreV1NamespacedEndpointsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEndpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedEndpoints",
			ID:   "listCoreV1NamespacedEndpoints",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedEndpoints", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedEndpoints",
			OperationID:   "listCoreV1NamespacedEndpoints",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedEndpointsParams
			Response = ListCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedEndpoints(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedEventRequest handles listCoreV1NamespacedEvent operation.
//
// GET /api/v1/namespaces/{namespace}/events
func (s *Server) handleListCoreV1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedEvent",
			ID:   "listCoreV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedEvent",
			OperationID:   "listCoreV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedEventParams
			Response = ListCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedLimitRangeRequest handles listCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/namespaces/{namespace}/limitranges
func (s *Server) handleListCoreV1NamespacedLimitRangeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedLimitRange"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedLimitRange",
			ID:   "listCoreV1NamespacedLimitRange",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedLimitRange", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedLimitRange",
			OperationID:   "listCoreV1NamespacedLimitRange",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedLimitRangeParams
			Response = ListCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedLimitRange(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedPersistentVolumeClaimRequest handles listCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleListCoreV1NamespacedPersistentVolumeClaimRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPersistentVolumeClaim"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPersistentVolumeClaim",
			ID:   "listCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedPersistentVolumeClaim", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedPersistentVolumeClaim",
			OperationID:   "listCoreV1NamespacedPersistentVolumeClaim",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPersistentVolumeClaimParams
			Response = ListCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedPersistentVolumeClaim(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedPodRequest handles listCoreV1NamespacedPod operation.
//
// GET /api/v1/namespaces/{namespace}/pods
func (s *Server) handleListCoreV1NamespacedPodRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPod"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPod",
			ID:   "listCoreV1NamespacedPod",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedPod", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedPodParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedPod",
			OperationID:   "listCoreV1NamespacedPod",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPodParams
			Response = ListCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedPod(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedPodTemplateRequest handles listCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/namespaces/{namespace}/podtemplates
func (s *Server) handleListCoreV1NamespacedPodTemplateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedPodTemplate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedPodTemplate",
			ID:   "listCoreV1NamespacedPodTemplate",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedPodTemplate", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedPodTemplate",
			OperationID:   "listCoreV1NamespacedPodTemplate",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedPodTemplateParams
			Response = ListCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedPodTemplate(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedReplicationControllerRequest handles listCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleListCoreV1NamespacedReplicationControllerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedReplicationController"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedReplicationController",
			ID:   "listCoreV1NamespacedReplicationController",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedReplicationController", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedReplicationController",
			OperationID:   "listCoreV1NamespacedReplicationController",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedReplicationControllerParams
			Response = ListCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedReplicationController(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedResourceQuotaRequest handles listCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas
func (s *Server) handleListCoreV1NamespacedResourceQuotaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedResourceQuota"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedResourceQuota",
			ID:   "listCoreV1NamespacedResourceQuota",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedResourceQuota", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedResourceQuota",
			OperationID:   "listCoreV1NamespacedResourceQuota",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedResourceQuotaParams
			Response = ListCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedResourceQuota(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedSecretRequest handles listCoreV1NamespacedSecret operation.
//
// GET /api/v1/namespaces/{namespace}/secrets
func (s *Server) handleListCoreV1NamespacedSecretRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedSecret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedSecret",
			ID:   "listCoreV1NamespacedSecret",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedSecret", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedSecret",
			OperationID:   "listCoreV1NamespacedSecret",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedSecretParams
			Response = ListCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedServiceRequest handles listCoreV1NamespacedService operation.
//
// GET /api/v1/namespaces/{namespace}/services
func (s *Server) handleListCoreV1NamespacedServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedService",
			ID:   "listCoreV1NamespacedService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedService",
			OperationID:   "listCoreV1NamespacedService",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedServiceParams
			Response = ListCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedService(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NamespacedServiceAccountRequest handles listCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts
func (s *Server) handleListCoreV1NamespacedServiceAccountRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1NamespacedServiceAccount"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1NamespacedServiceAccount",
			ID:   "listCoreV1NamespacedServiceAccount",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1NamespacedServiceAccount", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1NamespacedServiceAccount",
			OperationID:   "listCoreV1NamespacedServiceAccount",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NamespacedServiceAccountParams
			Response = ListCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1NamespacedServiceAccount(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1NodeRequest handles listCoreV1Node operation.
//
// GET /api/v1/nodes
func (s *Server) handleListCoreV1NodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1Node"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1Node",
			ID:   "listCoreV1Node",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1Node", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1NodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1Node",
			OperationID:   "listCoreV1Node",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1NodeParams
			Response = ListCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1Node(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1Node(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1NodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1PersistentVolumeRequest handles listCoreV1PersistentVolume operation.
//
// GET /api/v1/persistentvolumes
func (s *Server) handleListCoreV1PersistentVolumeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolume"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PersistentVolume",
			ID:   "listCoreV1PersistentVolume",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1PersistentVolume", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1PersistentVolume",
			OperationID:   "listCoreV1PersistentVolume",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PersistentVolumeParams
			Response = ListCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1PersistentVolume(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1PersistentVolumeClaimForAllNamespacesRequest handles listCoreV1PersistentVolumeClaimForAllNamespaces operation.
//
// GET /api/v1/persistentvolumeclaims
func (s *Server) handleListCoreV1PersistentVolumeClaimForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PersistentVolumeClaimForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PersistentVolumeClaimForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PersistentVolumeClaimForAllNamespaces",
			ID:   "listCoreV1PersistentVolumeClaimForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1PersistentVolumeClaimForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1PersistentVolumeClaimForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PersistentVolumeClaimForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1PersistentVolumeClaimForAllNamespaces",
			OperationID:   "listCoreV1PersistentVolumeClaimForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PersistentVolumeClaimForAllNamespacesParams
			Response = ListCoreV1PersistentVolumeClaimForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PersistentVolumeClaimForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1PersistentVolumeClaimForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PersistentVolumeClaimForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1PodForAllNamespacesRequest handles listCoreV1PodForAllNamespaces operation.
//
// GET /api/v1/pods
func (s *Server) handleListCoreV1PodForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PodForAllNamespaces",
			ID:   "listCoreV1PodForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1PodForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1PodForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PodForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1PodForAllNamespaces",
			OperationID:   "listCoreV1PodForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PodForAllNamespacesParams
			Response = ListCoreV1PodForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PodForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1PodForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1PodForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PodForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1PodTemplateForAllNamespacesRequest handles listCoreV1PodTemplateForAllNamespaces operation.
//
// GET /api/v1/podtemplates
func (s *Server) handleListCoreV1PodTemplateForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1PodTemplateForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1PodTemplateForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1PodTemplateForAllNamespaces",
			ID:   "listCoreV1PodTemplateForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1PodTemplateForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1PodTemplateForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1PodTemplateForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1PodTemplateForAllNamespaces",
			OperationID:   "listCoreV1PodTemplateForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1PodTemplateForAllNamespacesParams
			Response = ListCoreV1PodTemplateForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1PodTemplateForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1PodTemplateForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1PodTemplateForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1PodTemplateForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ReplicationControllerForAllNamespacesRequest handles listCoreV1ReplicationControllerForAllNamespaces operation.
//
// GET /api/v1/replicationcontrollers
func (s *Server) handleListCoreV1ReplicationControllerForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ReplicationControllerForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ReplicationControllerForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ReplicationControllerForAllNamespaces",
			ID:   "listCoreV1ReplicationControllerForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ReplicationControllerForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ReplicationControllerForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ReplicationControllerForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ReplicationControllerForAllNamespaces",
			OperationID:   "listCoreV1ReplicationControllerForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ReplicationControllerForAllNamespacesParams
			Response = ListCoreV1ReplicationControllerForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ReplicationControllerForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ReplicationControllerForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ReplicationControllerForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ReplicationControllerForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ResourceQuotaForAllNamespacesRequest handles listCoreV1ResourceQuotaForAllNamespaces operation.
//
// GET /api/v1/resourcequotas
func (s *Server) handleListCoreV1ResourceQuotaForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ResourceQuotaForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ResourceQuotaForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ResourceQuotaForAllNamespaces",
			ID:   "listCoreV1ResourceQuotaForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ResourceQuotaForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ResourceQuotaForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ResourceQuotaForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ResourceQuotaForAllNamespaces",
			OperationID:   "listCoreV1ResourceQuotaForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ResourceQuotaForAllNamespacesParams
			Response = ListCoreV1ResourceQuotaForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ResourceQuotaForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ResourceQuotaForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ResourceQuotaForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ResourceQuotaForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1SecretForAllNamespacesRequest handles listCoreV1SecretForAllNamespaces operation.
//
// GET /api/v1/secrets
func (s *Server) handleListCoreV1SecretForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1SecretForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1SecretForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1SecretForAllNamespaces",
			ID:   "listCoreV1SecretForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1SecretForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1SecretForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1SecretForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1SecretForAllNamespaces",
			OperationID:   "listCoreV1SecretForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1SecretForAllNamespacesParams
			Response = ListCoreV1SecretForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1SecretForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1SecretForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1SecretForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1SecretForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ServiceAccountForAllNamespacesRequest handles listCoreV1ServiceAccountForAllNamespaces operation.
//
// GET /api/v1/serviceaccounts
func (s *Server) handleListCoreV1ServiceAccountForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceAccountForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceAccountForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ServiceAccountForAllNamespaces",
			ID:   "listCoreV1ServiceAccountForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ServiceAccountForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ServiceAccountForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ServiceAccountForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ServiceAccountForAllNamespaces",
			OperationID:   "listCoreV1ServiceAccountForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ServiceAccountForAllNamespacesParams
			Response = ListCoreV1ServiceAccountForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ServiceAccountForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ServiceAccountForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ServiceAccountForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ServiceAccountForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListCoreV1ServiceForAllNamespacesRequest handles listCoreV1ServiceForAllNamespaces operation.
//
// GET /api/v1/services
func (s *Server) handleListCoreV1ServiceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listCoreV1ServiceForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListCoreV1ServiceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListCoreV1ServiceForAllNamespaces",
			ID:   "listCoreV1ServiceForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListCoreV1ServiceForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListCoreV1ServiceForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListCoreV1ServiceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListCoreV1ServiceForAllNamespaces",
			OperationID:   "listCoreV1ServiceForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListCoreV1ServiceForAllNamespacesParams
			Response = ListCoreV1ServiceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListCoreV1ServiceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListCoreV1ServiceForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListCoreV1ServiceForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListCoreV1ServiceForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListDiscoveryV1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1EndpointSliceForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1/endpointslices
func (s *Server) handleListDiscoveryV1EndpointSliceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1EndpointSliceForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1EndpointSliceForAllNamespaces",
			ID:   "listDiscoveryV1EndpointSliceForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListDiscoveryV1EndpointSliceForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListDiscoveryV1EndpointSliceForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1EndpointSliceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListDiscoveryV1EndpointSliceForAllNamespaces",
			OperationID:   "listDiscoveryV1EndpointSliceForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1EndpointSliceForAllNamespacesParams
			Response = ListDiscoveryV1EndpointSliceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1EndpointSliceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListDiscoveryV1EndpointSliceForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1EndpointSliceForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListDiscoveryV1NamespacedEndpointSliceRequest handles listDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1NamespacedEndpointSliceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1NamespacedEndpointSlice",
			ID:   "listDiscoveryV1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListDiscoveryV1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListDiscoveryV1NamespacedEndpointSlice",
			OperationID:   "listDiscoveryV1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1NamespacedEndpointSliceParams
			Response = ListDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListDiscoveryV1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest handles listDiscoveryV1beta1EndpointSliceForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1beta1/endpointslices
func (s *Server) handleListDiscoveryV1beta1EndpointSliceForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1EndpointSliceForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
			ID:   "listDiscoveryV1beta1EndpointSliceForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListDiscoveryV1beta1EndpointSliceForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListDiscoveryV1beta1EndpointSliceForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1beta1EndpointSliceForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListDiscoveryV1beta1EndpointSliceForAllNamespaces",
			OperationID:   "listDiscoveryV1beta1EndpointSliceForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1beta1EndpointSliceForAllNamespacesParams
			Response = ListDiscoveryV1beta1EndpointSliceForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1beta1EndpointSliceForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1beta1EndpointSliceForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1beta1EndpointSliceForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListDiscoveryV1beta1NamespacedEndpointSliceRequest handles listDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices
func (s *Server) handleListDiscoveryV1beta1NamespacedEndpointSliceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDiscoveryV1beta1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "listDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListDiscoveryV1beta1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListDiscoveryV1beta1NamespacedEndpointSlice",
			OperationID:   "listDiscoveryV1beta1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = ListDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListEventsV1EventForAllNamespacesRequest handles listEventsV1EventForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1/events
func (s *Server) handleListEventsV1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1EventForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1EventForAllNamespaces",
			ID:   "listEventsV1EventForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListEventsV1EventForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListEventsV1EventForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListEventsV1EventForAllNamespaces",
			OperationID:   "listEventsV1EventForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1EventForAllNamespacesParams
			Response = ListEventsV1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListEventsV1EventForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListEventsV1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1EventForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListEventsV1NamespacedEventRequest handles listEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1NamespacedEvent",
			ID:   "listEventsV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListEventsV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListEventsV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListEventsV1NamespacedEvent",
			OperationID:   "listEventsV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1NamespacedEventParams
			Response = ListEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListEventsV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListEventsV1beta1EventForAllNamespacesRequest handles listEventsV1beta1EventForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1beta1/events
func (s *Server) handleListEventsV1beta1EventForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1EventForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1EventForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1beta1EventForAllNamespaces",
			ID:   "listEventsV1beta1EventForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListEventsV1beta1EventForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListEventsV1beta1EventForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1beta1EventForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListEventsV1beta1EventForAllNamespaces",
			OperationID:   "listEventsV1beta1EventForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1beta1EventForAllNamespacesParams
			Response = ListEventsV1beta1EventForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1beta1EventForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListEventsV1beta1EventForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListEventsV1beta1EventForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1beta1EventForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListEventsV1beta1NamespacedEventRequest handles listEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events
func (s *Server) handleListEventsV1beta1NamespacedEventRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listEventsV1beta1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListEventsV1beta1NamespacedEvent",
			ID:   "listEventsV1beta1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListEventsV1beta1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListEventsV1beta1NamespacedEvent",
			OperationID:   "listEventsV1beta1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListEventsV1beta1NamespacedEventParams
			Response = ListEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListEventsV1beta1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListFlowcontrolApiserverV1beta1FlowSchemaRequest handles listFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta1FlowSchemaRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "listFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta1FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListFlowcontrolApiserverV1beta1FlowSchema",
			OperationID:   "listFlowcontrolApiserverV1beta1FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = ListFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "listFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationID:   "listFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = ListFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListFlowcontrolApiserverV1beta2FlowSchemaRequest handles listFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas
func (s *Server) handleListFlowcontrolApiserverV1beta2FlowSchemaRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "listFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta2FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListFlowcontrolApiserverV1beta2FlowSchema",
			OperationID:   "listFlowcontrolApiserverV1beta2FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = ListFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles listFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations
func (s *Server) handleListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "listFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationID:   "listFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = ListFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListInternalApiserverV1alpha1StorageVersionRequest handles listInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions
func (s *Server) handleListInternalApiserverV1alpha1StorageVersionRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listInternalApiserverV1alpha1StorageVersion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListInternalApiserverV1alpha1StorageVersion",
			ID:   "listInternalApiserverV1alpha1StorageVersion",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListInternalApiserverV1alpha1StorageVersion", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListInternalApiserverV1alpha1StorageVersion",
			OperationID:   "listInternalApiserverV1alpha1StorageVersion",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListInternalApiserverV1alpha1StorageVersionParams
			Response = ListInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListInternalApiserverV1alpha1StorageVersion(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNetworkingV1IngressClassRequest handles listNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/ingressclasses
func (s *Server) handleListNetworkingV1IngressClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1IngressClass",
			ID:   "listNetworkingV1IngressClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNetworkingV1IngressClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNetworkingV1IngressClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNetworkingV1IngressClass",
			OperationID:   "listNetworkingV1IngressClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1IngressClassParams
			Response = ListNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNetworkingV1IngressClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1IngressClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNetworkingV1IngressForAllNamespacesRequest handles listNetworkingV1IngressForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/ingresses
func (s *Server) handleListNetworkingV1IngressForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1IngressForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1IngressForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1IngressForAllNamespaces",
			ID:   "listNetworkingV1IngressForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNetworkingV1IngressForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNetworkingV1IngressForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1IngressForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNetworkingV1IngressForAllNamespaces",
			OperationID:   "listNetworkingV1IngressForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1IngressForAllNamespacesParams
			Response = ListNetworkingV1IngressForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1IngressForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNetworkingV1IngressForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1IngressForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1IngressForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNetworkingV1NamespacedIngressRequest handles listNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses
func (s *Server) handleListNetworkingV1NamespacedIngressRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedIngress"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NamespacedIngress",
			ID:   "listNetworkingV1NamespacedIngress",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNetworkingV1NamespacedIngress", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNetworkingV1NamespacedIngress",
			OperationID:   "listNetworkingV1NamespacedIngress",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NamespacedIngressParams
			Response = ListNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNetworkingV1NamespacedIngress(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNetworkingV1NamespacedNetworkPolicyRequest handles listNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies
func (s *Server) handleListNetworkingV1NamespacedNetworkPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NamespacedNetworkPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NamespacedNetworkPolicy",
			ID:   "listNetworkingV1NamespacedNetworkPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNetworkingV1NamespacedNetworkPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNetworkingV1NamespacedNetworkPolicy",
			OperationID:   "listNetworkingV1NamespacedNetworkPolicy",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NamespacedNetworkPolicyParams
			Response = ListNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNetworkingV1NamespacedNetworkPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNetworkingV1NetworkPolicyForAllNamespacesRequest handles listNetworkingV1NetworkPolicyForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/networkpolicies
func (s *Server) handleListNetworkingV1NetworkPolicyForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNetworkingV1NetworkPolicyForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNetworkingV1NetworkPolicyForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNetworkingV1NetworkPolicyForAllNamespaces",
			ID:   "listNetworkingV1NetworkPolicyForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNetworkingV1NetworkPolicyForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNetworkingV1NetworkPolicyForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNetworkingV1NetworkPolicyForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNetworkingV1NetworkPolicyForAllNamespaces",
			OperationID:   "listNetworkingV1NetworkPolicyForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNetworkingV1NetworkPolicyForAllNamespacesParams
			Response = ListNetworkingV1NetworkPolicyForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNetworkingV1NetworkPolicyForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNetworkingV1NetworkPolicyForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNetworkingV1NetworkPolicyForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNetworkingV1NetworkPolicyForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNodeV1RuntimeClassRequest handles listNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/runtimeclasses
func (s *Server) handleListNodeV1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1RuntimeClass",
			ID:   "listNodeV1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNodeV1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNodeV1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNodeV1RuntimeClass",
			OperationID:   "listNodeV1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1RuntimeClassParams
			Response = ListNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNodeV1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNodeV1alpha1RuntimeClassRequest handles listNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses
func (s *Server) handleListNodeV1alpha1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1alpha1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1alpha1RuntimeClass",
			ID:   "listNodeV1alpha1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNodeV1alpha1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNodeV1alpha1RuntimeClass",
			OperationID:   "listNodeV1alpha1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1alpha1RuntimeClassParams
			Response = ListNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNodeV1alpha1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListNodeV1beta1RuntimeClassRequest handles listNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses
func (s *Server) handleListNodeV1beta1RuntimeClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listNodeV1beta1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListNodeV1beta1RuntimeClass",
			ID:   "listNodeV1beta1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListNodeV1beta1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListNodeV1beta1RuntimeClass",
			OperationID:   "listNodeV1beta1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListNodeV1beta1RuntimeClassParams
			Response = ListNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListNodeV1beta1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListPolicyV1NamespacedPodDisruptionBudgetRequest handles listPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1NamespacedPodDisruptionBudgetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1NamespacedPodDisruptionBudget",
			ID:   "listPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListPolicyV1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListPolicyV1NamespacedPodDisruptionBudget",
			OperationID:   "listPolicyV1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1NamespacedPodDisruptionBudgetParams
			Response = ListPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListPolicyV1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1PodDisruptionBudgetForAllNamespaces operation.
//
// GET /apis/policy/v1/poddisruptionbudgets
func (s *Server) handleListPolicyV1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1PodDisruptionBudgetForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
			ID:   "listPolicyV1PodDisruptionBudgetForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListPolicyV1PodDisruptionBudgetForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListPolicyV1PodDisruptionBudgetForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1PodDisruptionBudgetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListPolicyV1PodDisruptionBudgetForAllNamespaces",
			OperationID:   "listPolicyV1PodDisruptionBudgetForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1PodDisruptionBudgetForAllNamespacesParams
			Response = ListPolicyV1PodDisruptionBudgetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1PodDisruptionBudgetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListPolicyV1PodDisruptionBudgetForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles listPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "listPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListPolicyV1beta1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationID:   "listPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = ListPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest handles listPolicyV1beta1PodDisruptionBudgetForAllNamespaces operation.
//
// GET /apis/policy/v1beta1/poddisruptionbudgets
func (s *Server) handleListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodDisruptionBudgetForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			ID:   "listPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			OperationID:   "listPolicyV1beta1PodDisruptionBudgetForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams
			Response = ListPolicyV1beta1PodDisruptionBudgetForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1PodDisruptionBudgetForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1PodDisruptionBudgetForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1PodDisruptionBudgetForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListPolicyV1beta1PodSecurityPolicyRequest handles listPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/podsecuritypolicies
func (s *Server) handleListPolicyV1beta1PodSecurityPolicyRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listPolicyV1beta1PodSecurityPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListPolicyV1beta1PodSecurityPolicy",
			ID:   "listPolicyV1beta1PodSecurityPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListPolicyV1beta1PodSecurityPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListPolicyV1beta1PodSecurityPolicy",
			OperationID:   "listPolicyV1beta1PodSecurityPolicy",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListPolicyV1beta1PodSecurityPolicyParams
			Response = ListPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListPolicyV1beta1PodSecurityPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1ClusterRoleRequest handles listRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles
func (s *Server) handleListRbacAuthorizationV1ClusterRoleRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1ClusterRole",
			ID:   "listRbacAuthorizationV1ClusterRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1ClusterRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1ClusterRole",
			OperationID:   "listRbacAuthorizationV1ClusterRole",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1ClusterRoleParams
			Response = ListRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1ClusterRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1ClusterRoleBindingRequest handles listRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings
func (s *Server) handleListRbacAuthorizationV1ClusterRoleBindingRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1ClusterRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1ClusterRoleBinding",
			ID:   "listRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1ClusterRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1ClusterRoleBinding",
			OperationID:   "listRbacAuthorizationV1ClusterRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1ClusterRoleBindingParams
			Response = ListRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1ClusterRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1NamespacedRoleRequest handles listRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1NamespacedRole",
			ID:   "listRbacAuthorizationV1NamespacedRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1NamespacedRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1NamespacedRole",
			OperationID:   "listRbacAuthorizationV1NamespacedRole",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1NamespacedRoleParams
			Response = ListRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1NamespacedRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1NamespacedRoleBindingRequest handles listRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings
func (s *Server) handleListRbacAuthorizationV1NamespacedRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1NamespacedRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "listRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1NamespacedRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1NamespacedRoleBinding",
			OperationID:   "listRbacAuthorizationV1NamespacedRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1NamespacedRoleBindingParams
			Response = ListRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest handles listRbacAuthorizationV1RoleBindingForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/rolebindings
func (s *Server) handleListRbacAuthorizationV1RoleBindingForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleBindingForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
			ID:   "listRbacAuthorizationV1RoleBindingForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1RoleBindingForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1RoleBindingForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1RoleBindingForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1RoleBindingForAllNamespaces",
			OperationID:   "listRbacAuthorizationV1RoleBindingForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1RoleBindingForAllNamespacesParams
			Response = ListRbacAuthorizationV1RoleBindingForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1RoleBindingForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1RoleBindingForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleBindingForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListRbacAuthorizationV1RoleForAllNamespacesRequest handles listRbacAuthorizationV1RoleForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/roles
func (s *Server) handleListRbacAuthorizationV1RoleForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listRbacAuthorizationV1RoleForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListRbacAuthorizationV1RoleForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListRbacAuthorizationV1RoleForAllNamespaces",
			ID:   "listRbacAuthorizationV1RoleForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListRbacAuthorizationV1RoleForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListRbacAuthorizationV1RoleForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListRbacAuthorizationV1RoleForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListRbacAuthorizationV1RoleForAllNamespaces",
			OperationID:   "listRbacAuthorizationV1RoleForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListRbacAuthorizationV1RoleForAllNamespacesParams
			Response = ListRbacAuthorizationV1RoleForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListRbacAuthorizationV1RoleForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListRbacAuthorizationV1RoleForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListRbacAuthorizationV1RoleForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListRbacAuthorizationV1RoleForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListSchedulingV1PriorityClassRequest handles listSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses
func (s *Server) handleListSchedulingV1PriorityClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listSchedulingV1PriorityClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListSchedulingV1PriorityClass",
			ID:   "listSchedulingV1PriorityClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListSchedulingV1PriorityClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListSchedulingV1PriorityClass",
			OperationID:   "listSchedulingV1PriorityClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListSchedulingV1PriorityClassParams
			Response = ListSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListSchedulingV1PriorityClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1CSIDriverRequest handles listStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/csidrivers
func (s *Server) handleListStorageV1CSIDriverRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSIDriver"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1CSIDriver",
			ID:   "listStorageV1CSIDriver",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1CSIDriver", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1CSIDriverParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1CSIDriver",
			OperationID:   "listStorageV1CSIDriver",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1CSIDriverParams
			Response = ListStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1CSIDriver(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1CSIDriverResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1CSINodeRequest handles listStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/csinodes
func (s *Server) handleListStorageV1CSINodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1CSINode"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1CSINode",
			ID:   "listStorageV1CSINode",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1CSINode", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1CSINodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1CSINode",
			OperationID:   "listStorageV1CSINode",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1CSINodeParams
			Response = ListStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1CSINode(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1CSINode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1CSINodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1StorageClassRequest handles listStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/storageclasses
func (s *Server) handleListStorageV1StorageClassRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1StorageClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1StorageClass",
			ID:   "listStorageV1StorageClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1StorageClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1StorageClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1StorageClass",
			OperationID:   "listStorageV1StorageClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1StorageClassParams
			Response = ListStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1StorageClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1StorageClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1VolumeAttachmentRequest handles listStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments
func (s *Server) handleListStorageV1VolumeAttachmentRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1VolumeAttachment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1VolumeAttachment",
			ID:   "listStorageV1VolumeAttachment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1VolumeAttachment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1VolumeAttachment",
			OperationID:   "listStorageV1VolumeAttachment",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1VolumeAttachmentParams
			Response = ListStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1VolumeAttachment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1alpha1CSIStorageCapacityForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1alpha1/csistoragecapacities
func (s *Server) handleListStorageV1alpha1CSIStorageCapacityForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1CSIStorageCapacityForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			ID:   "listStorageV1alpha1CSIStorageCapacityForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1alpha1CSIStorageCapacityForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			OperationID:   "listStorageV1alpha1CSIStorageCapacityForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams
			Response = ListStorageV1alpha1CSIStorageCapacityForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1alpha1CSIStorageCapacityForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1alpha1CSIStorageCapacityForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1alpha1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1alpha1NamespacedCSIStorageCapacityRequest handles listStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1alpha1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "listStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1alpha1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationID:   "listStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = ListStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest handles listStorageV1beta1CSIStorageCapacityForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1beta1/csistoragecapacities
func (s *Server) handleListStorageV1beta1CSIStorageCapacityForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1CSIStorageCapacityForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
			ID:   "listStorageV1beta1CSIStorageCapacityForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1beta1CSIStorageCapacityForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1beta1CSIStorageCapacityForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1beta1CSIStorageCapacityForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1beta1CSIStorageCapacityForAllNamespaces",
			OperationID:   "listStorageV1beta1CSIStorageCapacityForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1beta1CSIStorageCapacityForAllNamespacesParams
			Response = ListStorageV1beta1CSIStorageCapacityForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1beta1CSIStorageCapacityForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1beta1CSIStorageCapacityForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1beta1CSIStorageCapacityForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleListStorageV1beta1NamespacedCSIStorageCapacityRequest handles listStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleListStorageV1beta1NamespacedCSIStorageCapacityRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listStorageV1beta1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ListStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ListStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "listStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ListStorageV1beta1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeListStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ListStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ListStorageV1beta1NamespacedCSIStorageCapacity",
			OperationID:   "listStorageV1beta1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ListStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = ListStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackListStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ListStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.ListStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeListStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleLogFileHandlerRequest handles logFileHandler operation.
//
// GET /logs/{logpath}
func (s *Server) handleLogFileHandlerRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileHandler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileHandler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LogFileHandler",
			ID:   "logFileHandler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "LogFileHandler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeLogFileHandlerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LogFileHandlerUnauthorized
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LogFileHandler",
			OperationID:   "logFileHandler",
			Body:          nil,
			Params: map[string]any{
				"logpath": params.Logpath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LogFileHandlerParams
			Response = LogFileHandlerUnauthorized
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLogFileHandlerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.LogFileHandler(ctx, params)
			},
		)
	} else {
		response, err = s.h.LogFileHandler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLogFileHandlerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleLogFileListHandlerRequest handles logFileListHandler operation.
//
// GET /logs/
func (s *Server) handleLogFileListHandlerRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("logFileListHandler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LogFileListHandler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LogFileListHandler",
			ID:   "logFileListHandler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "LogFileListHandler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LogFileListHandlerUnauthorized
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LogFileListHandler",
			OperationID:   "logFileListHandler",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = LogFileListHandlerUnauthorized
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.LogFileListHandler(ctx)
			},
		)
	} else {
		response, err = s.h.LogFileListHandler(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLogFileListHandlerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest handles readAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1MutatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "readAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAdmissionregistrationV1MutatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationID:   "readAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = ReadAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles readAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}
func (s *Server) handleReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "readAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAdmissionregistrationV1ValidatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationID:   "readAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = ReadAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadApiextensionsV1CustomResourceDefinitionRequest handles readApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinition"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiextensionsV1CustomResourceDefinition",
			ID:   "readApiextensionsV1CustomResourceDefinition",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadApiextensionsV1CustomResourceDefinition", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadApiextensionsV1CustomResourceDefinition",
			OperationID:   "readApiextensionsV1CustomResourceDefinition",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiextensionsV1CustomResourceDefinitionParams
			Response = ReadApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadApiextensionsV1CustomResourceDefinition(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadApiextensionsV1CustomResourceDefinitionStatusRequest handles readApiextensionsV1CustomResourceDefinitionStatus operation.
//
// GET /apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status
func (s *Server) handleReadApiextensionsV1CustomResourceDefinitionStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiextensionsV1CustomResourceDefinitionStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiextensionsV1CustomResourceDefinitionStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiextensionsV1CustomResourceDefinitionStatus",
			ID:   "readApiextensionsV1CustomResourceDefinitionStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadApiextensionsV1CustomResourceDefinitionStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadApiextensionsV1CustomResourceDefinitionStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiextensionsV1CustomResourceDefinitionStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadApiextensionsV1CustomResourceDefinitionStatus",
			OperationID:   "readApiextensionsV1CustomResourceDefinitionStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiextensionsV1CustomResourceDefinitionStatusParams
			Response = ReadApiextensionsV1CustomResourceDefinitionStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiextensionsV1CustomResourceDefinitionStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadApiextensionsV1CustomResourceDefinitionStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadApiextensionsV1CustomResourceDefinitionStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiextensionsV1CustomResourceDefinitionStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadApiregistrationV1APIServiceRequest handles readApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}
func (s *Server) handleReadApiregistrationV1APIServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiregistrationV1APIService",
			ID:   "readApiregistrationV1APIService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadApiregistrationV1APIService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadApiregistrationV1APIService",
			OperationID:   "readApiregistrationV1APIService",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiregistrationV1APIServiceParams
			Response = ReadApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadApiregistrationV1APIService(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadApiregistrationV1APIServiceStatusRequest handles readApiregistrationV1APIServiceStatus operation.
//
// GET /apis/apiregistration.k8s.io/v1/apiservices/{name}/status
func (s *Server) handleReadApiregistrationV1APIServiceStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readApiregistrationV1APIServiceStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadApiregistrationV1APIServiceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadApiregistrationV1APIServiceStatus",
			ID:   "readApiregistrationV1APIServiceStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadApiregistrationV1APIServiceStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadApiregistrationV1APIServiceStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadApiregistrationV1APIServiceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadApiregistrationV1APIServiceStatus",
			OperationID:   "readApiregistrationV1APIServiceStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadApiregistrationV1APIServiceStatusParams
			Response = ReadApiregistrationV1APIServiceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadApiregistrationV1APIServiceStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadApiregistrationV1APIServiceStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadApiregistrationV1APIServiceStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadApiregistrationV1APIServiceStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedControllerRevisionRequest handles readAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleReadAppsV1NamespacedControllerRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedControllerRevision"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedControllerRevision",
			ID:   "readAppsV1NamespacedControllerRevision",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedControllerRevision", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedControllerRevision",
			OperationID:   "readAppsV1NamespacedControllerRevision",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedControllerRevisionParams
			Response = ReadAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedControllerRevision(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedDaemonSetRequest handles readAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleReadAppsV1NamespacedDaemonSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDaemonSet",
			ID:   "readAppsV1NamespacedDaemonSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedDaemonSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedDaemonSet",
			OperationID:   "readAppsV1NamespacedDaemonSet",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDaemonSetParams
			Response = ReadAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedDaemonSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedDaemonSetStatusRequest handles readAppsV1NamespacedDaemonSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedDaemonSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDaemonSetStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDaemonSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDaemonSetStatus",
			ID:   "readAppsV1NamespacedDaemonSetStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedDaemonSetStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedDaemonSetStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDaemonSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedDaemonSetStatus",
			OperationID:   "readAppsV1NamespacedDaemonSetStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDaemonSetStatusParams
			Response = ReadAppsV1NamespacedDaemonSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDaemonSetStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedDaemonSetStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDaemonSetStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDaemonSetStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedDeploymentRequest handles readAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}
func (s *Server) handleReadAppsV1NamespacedDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeployment",
			ID:   "readAppsV1NamespacedDeployment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeployment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedDeployment",
			OperationID:   "readAppsV1NamespacedDeployment",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentParams
			Response = ReadAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedDeployment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedDeploymentScaleRequest handles readAppsV1NamespacedDeploymentScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale
func (s *Server) handleReadAppsV1NamespacedDeploymentScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentScale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeploymentScale",
			ID:   "readAppsV1NamespacedDeploymentScale",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeploymentScale", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedDeploymentScaleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedDeploymentScale",
			OperationID:   "readAppsV1NamespacedDeploymentScale",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentScaleParams
			Response = ReadAppsV1NamespacedDeploymentScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentScaleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedDeploymentScale(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeploymentScale(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentScaleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedDeploymentStatusRequest handles readAppsV1NamespacedDeploymentStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}/status
func (s *Server) handleReadAppsV1NamespacedDeploymentStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedDeploymentStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedDeploymentStatus",
			ID:   "readAppsV1NamespacedDeploymentStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedDeploymentStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedDeploymentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedDeploymentStatus",
			OperationID:   "readAppsV1NamespacedDeploymentStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedDeploymentStatusParams
			Response = ReadAppsV1NamespacedDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedDeploymentStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedDeploymentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedDeploymentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedReplicaSetRequest handles readAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleReadAppsV1NamespacedReplicaSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSet",
			ID:   "readAppsV1NamespacedReplicaSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedReplicaSet",
			OperationID:   "readAppsV1NamespacedReplicaSet",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetParams
			Response = ReadAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedReplicaSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedReplicaSetScaleRequest handles readAppsV1NamespacedReplicaSetScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedReplicaSetScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetScale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSetScale",
			ID:   "readAppsV1NamespacedReplicaSetScale",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSetScale", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetScaleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedReplicaSetScale",
			OperationID:   "readAppsV1NamespacedReplicaSetScale",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetScaleParams
			Response = ReadAppsV1NamespacedReplicaSetScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetScaleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedReplicaSetScale(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSetScale(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetScaleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedReplicaSetStatusRequest handles readAppsV1NamespacedReplicaSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status
func (s *Server) handleReadAppsV1NamespacedReplicaSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedReplicaSetStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedReplicaSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedReplicaSetStatus",
			ID:   "readAppsV1NamespacedReplicaSetStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedReplicaSetStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedReplicaSetStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedReplicaSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedReplicaSetStatus",
			OperationID:   "readAppsV1NamespacedReplicaSetStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedReplicaSetStatusParams
			Response = ReadAppsV1NamespacedReplicaSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedReplicaSetStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedReplicaSetStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedReplicaSetStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedReplicaSetStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedStatefulSetRequest handles readAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleReadAppsV1NamespacedStatefulSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSet",
			ID:   "readAppsV1NamespacedStatefulSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedStatefulSet",
			OperationID:   "readAppsV1NamespacedStatefulSet",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetParams
			Response = ReadAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedStatefulSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedStatefulSetScaleRequest handles readAppsV1NamespacedStatefulSetScale operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale
func (s *Server) handleReadAppsV1NamespacedStatefulSetScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetScale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSetScale",
			ID:   "readAppsV1NamespacedStatefulSetScale",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSetScale", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetScaleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedStatefulSetScale",
			OperationID:   "readAppsV1NamespacedStatefulSetScale",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetScaleParams
			Response = ReadAppsV1NamespacedStatefulSetScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetScaleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedStatefulSetScale(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSetScale(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetScaleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAppsV1NamespacedStatefulSetStatusRequest handles readAppsV1NamespacedStatefulSetStatus operation.
//
// GET /apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status
func (s *Server) handleReadAppsV1NamespacedStatefulSetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAppsV1NamespacedStatefulSetStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAppsV1NamespacedStatefulSetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAppsV1NamespacedStatefulSetStatus",
			ID:   "readAppsV1NamespacedStatefulSetStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAppsV1NamespacedStatefulSetStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAppsV1NamespacedStatefulSetStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAppsV1NamespacedStatefulSetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAppsV1NamespacedStatefulSetStatus",
			OperationID:   "readAppsV1NamespacedStatefulSetStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAppsV1NamespacedStatefulSetStatusParams
			Response = ReadAppsV1NamespacedStatefulSetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAppsV1NamespacedStatefulSetStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAppsV1NamespacedStatefulSetStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAppsV1NamespacedStatefulSetStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAppsV1NamespacedStatefulSetStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationID:   "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			OperationID:   "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			OperationID:   "readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest handles readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus operation.
//
// GET /apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status
func (s *Server) handleReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			ID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			OperationID:   "readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams
			Response = ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1NamespacedCronJobRequest handles readBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedCronJob",
			ID:   "readBatchV1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1NamespacedCronJob",
			OperationID:   "readBatchV1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedCronJobParams
			Response = ReadBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1NamespacedCronJobStatusRequest handles readBatchV1NamespacedCronJobStatus operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedCronJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedCronJobStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedCronJobStatus",
			ID:   "readBatchV1NamespacedCronJobStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1NamespacedCronJobStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1NamespacedCronJobStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedCronJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1NamespacedCronJobStatus",
			OperationID:   "readBatchV1NamespacedCronJobStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedCronJobStatusParams
			Response = ReadBatchV1NamespacedCronJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedCronJobStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1NamespacedCronJobStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedCronJobStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1NamespacedJobRequest handles readBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}
func (s *Server) handleReadBatchV1NamespacedJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedJob",
			ID:   "readBatchV1NamespacedJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1NamespacedJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1NamespacedJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1NamespacedJob",
			OperationID:   "readBatchV1NamespacedJob",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedJobParams
			Response = ReadBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1NamespacedJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1NamespacedJobStatusRequest handles readBatchV1NamespacedJobStatus operation.
//
// GET /apis/batch/v1/namespaces/{namespace}/jobs/{name}/status
func (s *Server) handleReadBatchV1NamespacedJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1NamespacedJobStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1NamespacedJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1NamespacedJobStatus",
			ID:   "readBatchV1NamespacedJobStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1NamespacedJobStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1NamespacedJobStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1NamespacedJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1NamespacedJobStatus",
			OperationID:   "readBatchV1NamespacedJobStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1NamespacedJobStatusParams
			Response = ReadBatchV1NamespacedJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1NamespacedJobStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1NamespacedJobStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1NamespacedJobStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1NamespacedJobStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1beta1NamespacedCronJobRequest handles readBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleReadBatchV1beta1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1beta1NamespacedCronJob",
			ID:   "readBatchV1beta1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1beta1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1beta1NamespacedCronJob",
			OperationID:   "readBatchV1beta1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1beta1NamespacedCronJobParams
			Response = ReadBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1beta1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadBatchV1beta1NamespacedCronJobStatusRequest handles readBatchV1beta1NamespacedCronJobStatus operation.
//
// GET /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status
func (s *Server) handleReadBatchV1beta1NamespacedCronJobStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readBatchV1beta1NamespacedCronJobStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadBatchV1beta1NamespacedCronJobStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadBatchV1beta1NamespacedCronJobStatus",
			ID:   "readBatchV1beta1NamespacedCronJobStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadBatchV1beta1NamespacedCronJobStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadBatchV1beta1NamespacedCronJobStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadBatchV1beta1NamespacedCronJobStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadBatchV1beta1NamespacedCronJobStatus",
			OperationID:   "readBatchV1beta1NamespacedCronJobStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadBatchV1beta1NamespacedCronJobStatusParams
			Response = ReadBatchV1beta1NamespacedCronJobStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadBatchV1beta1NamespacedCronJobStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadBatchV1beta1NamespacedCronJobStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadBatchV1beta1NamespacedCronJobStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadBatchV1beta1NamespacedCronJobStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCertificatesV1CertificateSigningRequestRequest handles readCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}
func (s *Server) handleReadCertificatesV1CertificateSigningRequestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequest",
			ID:   "readCertificatesV1CertificateSigningRequest",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequest", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCertificatesV1CertificateSigningRequest",
			OperationID:   "readCertificatesV1CertificateSigningRequest",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestParams
			Response = ReadCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCertificatesV1CertificateSigningRequest(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCertificatesV1CertificateSigningRequestApprovalRequest handles readCertificatesV1CertificateSigningRequestApproval operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval
func (s *Server) handleReadCertificatesV1CertificateSigningRequestApprovalRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestApproval"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestApproval",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequestApproval",
			ID:   "readCertificatesV1CertificateSigningRequestApproval",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequestApproval", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestApprovalParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestApprovalRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCertificatesV1CertificateSigningRequestApproval",
			OperationID:   "readCertificatesV1CertificateSigningRequestApproval",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestApprovalParams
			Response = ReadCertificatesV1CertificateSigningRequestApprovalRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestApprovalParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCertificatesV1CertificateSigningRequestApproval(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequestApproval(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestApprovalResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCertificatesV1CertificateSigningRequestStatusRequest handles readCertificatesV1CertificateSigningRequestStatus operation.
//
// GET /apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status
func (s *Server) handleReadCertificatesV1CertificateSigningRequestStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCertificatesV1CertificateSigningRequestStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCertificatesV1CertificateSigningRequestStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCertificatesV1CertificateSigningRequestStatus",
			ID:   "readCertificatesV1CertificateSigningRequestStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCertificatesV1CertificateSigningRequestStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCertificatesV1CertificateSigningRequestStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCertificatesV1CertificateSigningRequestStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCertificatesV1CertificateSigningRequestStatus",
			OperationID:   "readCertificatesV1CertificateSigningRequestStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCertificatesV1CertificateSigningRequestStatusParams
			Response = ReadCertificatesV1CertificateSigningRequestStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCertificatesV1CertificateSigningRequestStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCertificatesV1CertificateSigningRequestStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCertificatesV1CertificateSigningRequestStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCertificatesV1CertificateSigningRequestStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoordinationV1NamespacedLeaseRequest handles readCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}
func (s *Server) handleReadCoordinationV1NamespacedLeaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoordinationV1NamespacedLease"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoordinationV1NamespacedLease",
			ID:   "readCoordinationV1NamespacedLease",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoordinationV1NamespacedLease", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoordinationV1NamespacedLease",
			OperationID:   "readCoordinationV1NamespacedLease",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoordinationV1NamespacedLeaseParams
			Response = ReadCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoordinationV1NamespacedLease(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1ComponentStatusRequest handles readCoreV1ComponentStatus operation.
//
// GET /api/v1/componentstatuses/{name}
func (s *Server) handleReadCoreV1ComponentStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1ComponentStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1ComponentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1ComponentStatus",
			ID:   "readCoreV1ComponentStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1ComponentStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1ComponentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1ComponentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1ComponentStatus",
			OperationID:   "readCoreV1ComponentStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1ComponentStatusParams
			Response = ReadCoreV1ComponentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1ComponentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1ComponentStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1ComponentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1ComponentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespaceRequest handles readCoreV1Namespace operation.
//
// GET /api/v1/namespaces/{name}
func (s *Server) handleReadCoreV1NamespaceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Namespace"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1Namespace",
			ID:   "readCoreV1Namespace",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1Namespace", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespaceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1Namespace",
			OperationID:   "readCoreV1Namespace",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespaceParams
			Response = ReadCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1Namespace(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1Namespace(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespaceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespaceStatusRequest handles readCoreV1NamespaceStatus operation.
//
// GET /api/v1/namespaces/{name}/status
func (s *Server) handleReadCoreV1NamespaceStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespaceStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespaceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespaceStatus",
			ID:   "readCoreV1NamespaceStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespaceStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespaceStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespaceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespaceStatus",
			OperationID:   "readCoreV1NamespaceStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespaceStatusParams
			Response = ReadCoreV1NamespaceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespaceStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespaceStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespaceStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespaceStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedConfigMapRequest handles readCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleReadCoreV1NamespacedConfigMapRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedConfigMap"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedConfigMap",
			ID:   "readCoreV1NamespacedConfigMap",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedConfigMap", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedConfigMap",
			OperationID:   "readCoreV1NamespacedConfigMap",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedConfigMapParams
			Response = ReadCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedConfigMap(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedEndpointsRequest handles readCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleReadCoreV1NamespacedEndpointsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEndpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedEndpoints",
			ID:   "readCoreV1NamespacedEndpoints",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedEndpoints", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedEndpoints",
			OperationID:   "readCoreV1NamespacedEndpoints",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedEndpointsParams
			Response = ReadCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedEndpoints(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedEventRequest handles readCoreV1NamespacedEvent operation.
//
// GET /api/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadCoreV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedEvent",
			ID:   "readCoreV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedEvent",
			OperationID:   "readCoreV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedEventParams
			Response = ReadCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedLimitRangeRequest handles readCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleReadCoreV1NamespacedLimitRangeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedLimitRange"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedLimitRange",
			ID:   "readCoreV1NamespacedLimitRange",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedLimitRange", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedLimitRange",
			OperationID:   "readCoreV1NamespacedLimitRange",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedLimitRangeParams
			Response = ReadCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedLimitRange(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPersistentVolumeClaimRequest handles readCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaim"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPersistentVolumeClaim",
			ID:   "readCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPersistentVolumeClaim", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPersistentVolumeClaim",
			OperationID:   "readCoreV1NamespacedPersistentVolumeClaim",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPersistentVolumeClaimParams
			Response = ReadCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPersistentVolumeClaim(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest handles readCoreV1NamespacedPersistentVolumeClaimStatus operation.
//
// GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status
func (s *Server) handleReadCoreV1NamespacedPersistentVolumeClaimStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPersistentVolumeClaimStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
			ID:   "readCoreV1NamespacedPersistentVolumeClaimStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPersistentVolumeClaimStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPersistentVolumeClaimStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPersistentVolumeClaimStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPersistentVolumeClaimStatus",
			OperationID:   "readCoreV1NamespacedPersistentVolumeClaimStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPersistentVolumeClaimStatusParams
			Response = ReadCoreV1NamespacedPersistentVolumeClaimStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPersistentVolumeClaimStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPersistentVolumeClaimStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPersistentVolumeClaimStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPersistentVolumeClaimStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPodRequest handles readCoreV1NamespacedPod operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}
func (s *Server) handleReadCoreV1NamespacedPodRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPod"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPod",
			ID:   "readCoreV1NamespacedPod",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPod", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPodParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPod",
			OperationID:   "readCoreV1NamespacedPod",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodParams
			Response = ReadCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPod(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPodEphemeralcontainersRequest handles readCoreV1NamespacedPodEphemeralcontainers operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers
func (s *Server) handleReadCoreV1NamespacedPodEphemeralcontainersRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodEphemeralcontainers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodEphemeralcontainers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodEphemeralcontainers",
			ID:   "readCoreV1NamespacedPodEphemeralcontainers",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodEphemeralcontainers", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPodEphemeralcontainersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodEphemeralcontainersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPodEphemeralcontainers",
			OperationID:   "readCoreV1NamespacedPodEphemeralcontainers",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodEphemeralcontainersParams
			Response = ReadCoreV1NamespacedPodEphemeralcontainersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodEphemeralcontainersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPodEphemeralcontainers(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodEphemeralcontainers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodEphemeralcontainersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPodLogRequest handles readCoreV1NamespacedPodLog operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/log
func (s *Server) handleReadCoreV1NamespacedPodLogRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodLog"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodLog",
			ID:   "readCoreV1NamespacedPodLog",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodLog", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPodLogParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodLogRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPodLog",
			OperationID:   "readCoreV1NamespacedPodLog",
			Body:          nil,
			Params: map[string]any{
				"container":                    params.Container,
				"follow":                       params.Follow,
				"insecureSkipTLSVerifyBackend": params.InsecureSkipTLSVerifyBackend,
				"limitBytes":                   params.LimitBytes,
				"name":                         params.Name,
				"namespace":                    params.Namespace,
				"pretty":                       params.Pretty,
				"previous":                     params.Previous,
				"sinceSeconds":                 params.SinceSeconds,
				"tailLines":                    params.TailLines,
				"timestamps":                   params.Timestamps,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodLogParams
			Response = ReadCoreV1NamespacedPodLogRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodLogParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPodLog(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodLog(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodLogResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPodStatusRequest handles readCoreV1NamespacedPodStatus operation.
//
// GET /api/v1/namespaces/{namespace}/pods/{name}/status
func (s *Server) handleReadCoreV1NamespacedPodStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodStatus",
			ID:   "readCoreV1NamespacedPodStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPodStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPodStatus",
			OperationID:   "readCoreV1NamespacedPodStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodStatusParams
			Response = ReadCoreV1NamespacedPodStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPodStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedPodTemplateRequest handles readCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleReadCoreV1NamespacedPodTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedPodTemplate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedPodTemplate",
			ID:   "readCoreV1NamespacedPodTemplate",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedPodTemplate", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedPodTemplate",
			OperationID:   "readCoreV1NamespacedPodTemplate",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedPodTemplateParams
			Response = ReadCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedPodTemplate(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedReplicationControllerRequest handles readCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleReadCoreV1NamespacedReplicationControllerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationController"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationController",
			ID:   "readCoreV1NamespacedReplicationController",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationController", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedReplicationController",
			OperationID:   "readCoreV1NamespacedReplicationController",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerParams
			Response = ReadCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedReplicationController(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedReplicationControllerScaleRequest handles readCoreV1NamespacedReplicationControllerScale operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale
func (s *Server) handleReadCoreV1NamespacedReplicationControllerScaleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerScale"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerScale",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationControllerScale",
			ID:   "readCoreV1NamespacedReplicationControllerScale",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationControllerScale", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerScaleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerScaleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedReplicationControllerScale",
			OperationID:   "readCoreV1NamespacedReplicationControllerScale",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerScaleParams
			Response = ReadCoreV1NamespacedReplicationControllerScaleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerScaleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedReplicationControllerScale(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationControllerScale(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerScaleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedReplicationControllerStatusRequest handles readCoreV1NamespacedReplicationControllerStatus operation.
//
// GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status
func (s *Server) handleReadCoreV1NamespacedReplicationControllerStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedReplicationControllerStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedReplicationControllerStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedReplicationControllerStatus",
			ID:   "readCoreV1NamespacedReplicationControllerStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedReplicationControllerStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedReplicationControllerStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedReplicationControllerStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedReplicationControllerStatus",
			OperationID:   "readCoreV1NamespacedReplicationControllerStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedReplicationControllerStatusParams
			Response = ReadCoreV1NamespacedReplicationControllerStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedReplicationControllerStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedReplicationControllerStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedReplicationControllerStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedReplicationControllerStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedResourceQuotaRequest handles readCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleReadCoreV1NamespacedResourceQuotaRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuota"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedResourceQuota",
			ID:   "readCoreV1NamespacedResourceQuota",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedResourceQuota", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedResourceQuota",
			OperationID:   "readCoreV1NamespacedResourceQuota",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedResourceQuotaParams
			Response = ReadCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedResourceQuota(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedResourceQuotaStatusRequest handles readCoreV1NamespacedResourceQuotaStatus operation.
//
// GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status
func (s *Server) handleReadCoreV1NamespacedResourceQuotaStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedResourceQuotaStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedResourceQuotaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedResourceQuotaStatus",
			ID:   "readCoreV1NamespacedResourceQuotaStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedResourceQuotaStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedResourceQuotaStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedResourceQuotaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedResourceQuotaStatus",
			OperationID:   "readCoreV1NamespacedResourceQuotaStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedResourceQuotaStatusParams
			Response = ReadCoreV1NamespacedResourceQuotaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedResourceQuotaStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedResourceQuotaStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedResourceQuotaStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedResourceQuotaStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedSecretRequest handles readCoreV1NamespacedSecret operation.
//
// GET /api/v1/namespaces/{namespace}/secrets/{name}
func (s *Server) handleReadCoreV1NamespacedSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedSecret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedSecret",
			ID:   "readCoreV1NamespacedSecret",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedSecret", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedSecret",
			OperationID:   "readCoreV1NamespacedSecret",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedSecretParams
			Response = ReadCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedServiceRequest handles readCoreV1NamespacedService operation.
//
// GET /api/v1/namespaces/{namespace}/services/{name}
func (s *Server) handleReadCoreV1NamespacedServiceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedService",
			ID:   "readCoreV1NamespacedService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedService",
			OperationID:   "readCoreV1NamespacedService",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceParams
			Response = ReadCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedService(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedServiceAccountRequest handles readCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleReadCoreV1NamespacedServiceAccountRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceAccount"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedServiceAccount",
			ID:   "readCoreV1NamespacedServiceAccount",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedServiceAccount", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedServiceAccount",
			OperationID:   "readCoreV1NamespacedServiceAccount",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceAccountParams
			Response = ReadCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedServiceAccount(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NamespacedServiceStatusRequest handles readCoreV1NamespacedServiceStatus operation.
//
// GET /api/v1/namespaces/{namespace}/services/{name}/status
func (s *Server) handleReadCoreV1NamespacedServiceStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NamespacedServiceStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NamespacedServiceStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NamespacedServiceStatus",
			ID:   "readCoreV1NamespacedServiceStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NamespacedServiceStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NamespacedServiceStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NamespacedServiceStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NamespacedServiceStatus",
			OperationID:   "readCoreV1NamespacedServiceStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NamespacedServiceStatusParams
			Response = ReadCoreV1NamespacedServiceStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NamespacedServiceStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NamespacedServiceStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NamespacedServiceStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NamespacedServiceStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NodeRequest handles readCoreV1Node operation.
//
// GET /api/v1/nodes/{name}
func (s *Server) handleReadCoreV1NodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1Node"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1Node",
			ID:   "readCoreV1Node",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1Node", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1Node",
			OperationID:   "readCoreV1Node",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NodeParams
			Response = ReadCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1Node(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1Node(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1NodeStatusRequest handles readCoreV1NodeStatus operation.
//
// GET /api/v1/nodes/{name}/status
func (s *Server) handleReadCoreV1NodeStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1NodeStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1NodeStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1NodeStatus",
			ID:   "readCoreV1NodeStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1NodeStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1NodeStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1NodeStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1NodeStatus",
			OperationID:   "readCoreV1NodeStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1NodeStatusParams
			Response = ReadCoreV1NodeStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1NodeStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1NodeStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1NodeStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1NodeStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1PersistentVolumeRequest handles readCoreV1PersistentVolume operation.
//
// GET /api/v1/persistentvolumes/{name}
func (s *Server) handleReadCoreV1PersistentVolumeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolume"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1PersistentVolume",
			ID:   "readCoreV1PersistentVolume",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1PersistentVolume", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1PersistentVolume",
			OperationID:   "readCoreV1PersistentVolume",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1PersistentVolumeParams
			Response = ReadCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1PersistentVolume(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadCoreV1PersistentVolumeStatusRequest handles readCoreV1PersistentVolumeStatus operation.
//
// GET /api/v1/persistentvolumes/{name}/status
func (s *Server) handleReadCoreV1PersistentVolumeStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readCoreV1PersistentVolumeStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadCoreV1PersistentVolumeStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadCoreV1PersistentVolumeStatus",
			ID:   "readCoreV1PersistentVolumeStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadCoreV1PersistentVolumeStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadCoreV1PersistentVolumeStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadCoreV1PersistentVolumeStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadCoreV1PersistentVolumeStatus",
			OperationID:   "readCoreV1PersistentVolumeStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadCoreV1PersistentVolumeStatusParams
			Response = ReadCoreV1PersistentVolumeStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadCoreV1PersistentVolumeStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadCoreV1PersistentVolumeStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadCoreV1PersistentVolumeStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadCoreV1PersistentVolumeStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadDiscoveryV1NamespacedEndpointSliceRequest handles readDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadDiscoveryV1NamespacedEndpointSlice",
			ID:   "readDiscoveryV1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadDiscoveryV1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadDiscoveryV1NamespacedEndpointSlice",
			OperationID:   "readDiscoveryV1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadDiscoveryV1NamespacedEndpointSliceParams
			Response = ReadDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadDiscoveryV1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadDiscoveryV1beta1NamespacedEndpointSliceRequest handles readDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleReadDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readDiscoveryV1beta1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "readDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadDiscoveryV1beta1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadDiscoveryV1beta1NamespacedEndpointSlice",
			OperationID:   "readDiscoveryV1beta1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = ReadDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadEventsV1NamespacedEventRequest handles readEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadEventsV1NamespacedEvent",
			ID:   "readEventsV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadEventsV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadEventsV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadEventsV1NamespacedEvent",
			OperationID:   "readEventsV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadEventsV1NamespacedEventParams
			Response = ReadEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadEventsV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadEventsV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadEventsV1beta1NamespacedEventRequest handles readEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}
func (s *Server) handleReadEventsV1beta1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readEventsV1beta1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadEventsV1beta1NamespacedEvent",
			ID:   "readEventsV1beta1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadEventsV1beta1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadEventsV1beta1NamespacedEvent",
			OperationID:   "readEventsV1beta1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadEventsV1beta1NamespacedEventParams
			Response = ReadEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadEventsV1beta1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta1FlowSchemaRequest handles readFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "readFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta1FlowSchema",
			OperationID:   "readFlowcontrolApiserverV1beta1FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = ReadFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta1FlowSchemaStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1FlowSchemaStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1FlowSchemaStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
			ID:   "readFlowcontrolApiserverV1beta1FlowSchemaStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1FlowSchemaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta1FlowSchemaStatus",
			OperationID:   "readFlowcontrolApiserverV1beta1FlowSchemaStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams
			Response = ReadFlowcontrolApiserverV1beta1FlowSchemaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1FlowSchemaStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta1FlowSchemaStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1FlowSchemaStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1FlowSchemaStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			ID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			OperationID:   "readFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams
			Response = ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta2FlowSchemaRequest handles readFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "readFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta2FlowSchema",
			OperationID:   "readFlowcontrolApiserverV1beta2FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = ReadFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest handles readFlowcontrolApiserverV1beta2FlowSchemaStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2FlowSchemaStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2FlowSchemaStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
			ID:   "readFlowcontrolApiserverV1beta2FlowSchemaStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2FlowSchemaStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta2FlowSchemaStatus",
			OperationID:   "readFlowcontrolApiserverV1beta2FlowSchemaStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams
			Response = ReadFlowcontrolApiserverV1beta2FlowSchemaStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2FlowSchemaStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta2FlowSchemaStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2FlowSchemaStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2FlowSchemaStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest handles readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status
func (s *Server) handleReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			ID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			OperationID:   "readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams
			Response = ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadInternalApiserverV1alpha1StorageVersionRequest handles readInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadInternalApiserverV1alpha1StorageVersion",
			ID:   "readInternalApiserverV1alpha1StorageVersion",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadInternalApiserverV1alpha1StorageVersion", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadInternalApiserverV1alpha1StorageVersion",
			OperationID:   "readInternalApiserverV1alpha1StorageVersion",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadInternalApiserverV1alpha1StorageVersionParams
			Response = ReadInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadInternalApiserverV1alpha1StorageVersion(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadInternalApiserverV1alpha1StorageVersionStatusRequest handles readInternalApiserverV1alpha1StorageVersionStatus operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status
func (s *Server) handleReadInternalApiserverV1alpha1StorageVersionStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readInternalApiserverV1alpha1StorageVersionStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadInternalApiserverV1alpha1StorageVersionStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadInternalApiserverV1alpha1StorageVersionStatus",
			ID:   "readInternalApiserverV1alpha1StorageVersionStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadInternalApiserverV1alpha1StorageVersionStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadInternalApiserverV1alpha1StorageVersionStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadInternalApiserverV1alpha1StorageVersionStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadInternalApiserverV1alpha1StorageVersionStatus",
			OperationID:   "readInternalApiserverV1alpha1StorageVersionStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadInternalApiserverV1alpha1StorageVersionStatusParams
			Response = ReadInternalApiserverV1alpha1StorageVersionStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadInternalApiserverV1alpha1StorageVersionStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadInternalApiserverV1alpha1StorageVersionStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadInternalApiserverV1alpha1StorageVersionStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadInternalApiserverV1alpha1StorageVersionStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNetworkingV1IngressClassRequest handles readNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/ingressclasses/{name}
func (s *Server) handleReadNetworkingV1IngressClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1IngressClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1IngressClass",
			ID:   "readNetworkingV1IngressClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNetworkingV1IngressClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNetworkingV1IngressClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNetworkingV1IngressClass",
			OperationID:   "readNetworkingV1IngressClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1IngressClassParams
			Response = ReadNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNetworkingV1IngressClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1IngressClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNetworkingV1NamespacedIngressRequest handles readNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleReadNetworkingV1NamespacedIngressRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngress"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedIngress",
			ID:   "readNetworkingV1NamespacedIngress",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedIngress", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNetworkingV1NamespacedIngress",
			OperationID:   "readNetworkingV1NamespacedIngress",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedIngressParams
			Response = ReadNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNetworkingV1NamespacedIngress(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNetworkingV1NamespacedIngressStatusRequest handles readNetworkingV1NamespacedIngressStatus operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status
func (s *Server) handleReadNetworkingV1NamespacedIngressStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedIngressStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedIngressStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedIngressStatus",
			ID:   "readNetworkingV1NamespacedIngressStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedIngressStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNetworkingV1NamespacedIngressStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedIngressStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNetworkingV1NamespacedIngressStatus",
			OperationID:   "readNetworkingV1NamespacedIngressStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedIngressStatusParams
			Response = ReadNetworkingV1NamespacedIngressStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedIngressStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNetworkingV1NamespacedIngressStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedIngressStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedIngressStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNetworkingV1NamespacedNetworkPolicyRequest handles readNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleReadNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNetworkingV1NamespacedNetworkPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNetworkingV1NamespacedNetworkPolicy",
			ID:   "readNetworkingV1NamespacedNetworkPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNetworkingV1NamespacedNetworkPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNetworkingV1NamespacedNetworkPolicy",
			OperationID:   "readNetworkingV1NamespacedNetworkPolicy",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNetworkingV1NamespacedNetworkPolicyParams
			Response = ReadNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNetworkingV1NamespacedNetworkPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNodeV1RuntimeClassRequest handles readNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1RuntimeClass",
			ID:   "readNodeV1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNodeV1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNodeV1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNodeV1RuntimeClass",
			OperationID:   "readNodeV1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1RuntimeClassParams
			Response = ReadNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNodeV1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNodeV1alpha1RuntimeClassRequest handles readNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1alpha1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1alpha1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1alpha1RuntimeClass",
			ID:   "readNodeV1alpha1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNodeV1alpha1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNodeV1alpha1RuntimeClass",
			OperationID:   "readNodeV1alpha1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1alpha1RuntimeClassParams
			Response = ReadNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNodeV1alpha1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadNodeV1beta1RuntimeClassRequest handles readNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/runtimeclasses/{name}
func (s *Server) handleReadNodeV1beta1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readNodeV1beta1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadNodeV1beta1RuntimeClass",
			ID:   "readNodeV1beta1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadNodeV1beta1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadNodeV1beta1RuntimeClass",
			OperationID:   "readNodeV1beta1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadNodeV1beta1RuntimeClassParams
			Response = ReadNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadNodeV1beta1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadPolicyV1NamespacedPodDisruptionBudgetRequest handles readPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1NamespacedPodDisruptionBudget",
			ID:   "readPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadPolicyV1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadPolicyV1NamespacedPodDisruptionBudget",
			OperationID:   "readPolicyV1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1NamespacedPodDisruptionBudgetParams
			Response = ReadPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadPolicyV1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1NamespacedPodDisruptionBudgetStatus operation.
//
// GET /apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1NamespacedPodDisruptionBudgetStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
			ID:   "readPolicyV1NamespacedPodDisruptionBudgetStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadPolicyV1NamespacedPodDisruptionBudgetStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadPolicyV1NamespacedPodDisruptionBudgetStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1NamespacedPodDisruptionBudgetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadPolicyV1NamespacedPodDisruptionBudgetStatus",
			OperationID:   "readPolicyV1NamespacedPodDisruptionBudgetStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1NamespacedPodDisruptionBudgetStatusParams
			Response = ReadPolicyV1NamespacedPodDisruptionBudgetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1NamespacedPodDisruptionBudgetStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadPolicyV1NamespacedPodDisruptionBudgetStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1NamespacedPodDisruptionBudgetStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles readPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "readPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadPolicyV1beta1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationID:   "readPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = ReadPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest handles readPolicyV1beta1NamespacedPodDisruptionBudgetStatus operation.
//
// GET /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status
func (s *Server) handleReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1NamespacedPodDisruptionBudgetStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			ID:   "readPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			OperationID:   "readPolicyV1beta1NamespacedPodDisruptionBudgetStatus",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams
			Response = ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1NamespacedPodDisruptionBudgetStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1NamespacedPodDisruptionBudgetStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadPolicyV1beta1PodSecurityPolicyRequest handles readPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/podsecuritypolicies/{name}
func (s *Server) handleReadPolicyV1beta1PodSecurityPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readPolicyV1beta1PodSecurityPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadPolicyV1beta1PodSecurityPolicy",
			ID:   "readPolicyV1beta1PodSecurityPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadPolicyV1beta1PodSecurityPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadPolicyV1beta1PodSecurityPolicy",
			OperationID:   "readPolicyV1beta1PodSecurityPolicy",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadPolicyV1beta1PodSecurityPolicyParams
			Response = ReadPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadPolicyV1beta1PodSecurityPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadRbacAuthorizationV1ClusterRoleRequest handles readRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterroles/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1ClusterRole",
			ID:   "readRbacAuthorizationV1ClusterRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadRbacAuthorizationV1ClusterRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadRbacAuthorizationV1ClusterRole",
			OperationID:   "readRbacAuthorizationV1ClusterRole",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1ClusterRoleParams
			Response = ReadRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadRbacAuthorizationV1ClusterRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadRbacAuthorizationV1ClusterRoleBindingRequest handles readRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1ClusterRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1ClusterRoleBinding",
			ID:   "readRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadRbacAuthorizationV1ClusterRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadRbacAuthorizationV1ClusterRoleBinding",
			OperationID:   "readRbacAuthorizationV1ClusterRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1ClusterRoleBindingParams
			Response = ReadRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadRbacAuthorizationV1ClusterRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadRbacAuthorizationV1NamespacedRoleRequest handles readRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1NamespacedRole",
			ID:   "readRbacAuthorizationV1NamespacedRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadRbacAuthorizationV1NamespacedRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadRbacAuthorizationV1NamespacedRole",
			OperationID:   "readRbacAuthorizationV1NamespacedRole",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1NamespacedRoleParams
			Response = ReadRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadRbacAuthorizationV1NamespacedRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadRbacAuthorizationV1NamespacedRoleBindingRequest handles readRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleReadRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readRbacAuthorizationV1NamespacedRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "readRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadRbacAuthorizationV1NamespacedRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadRbacAuthorizationV1NamespacedRoleBinding",
			OperationID:   "readRbacAuthorizationV1NamespacedRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadRbacAuthorizationV1NamespacedRoleBindingParams
			Response = ReadRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadSchedulingV1PriorityClassRequest handles readSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/priorityclasses/{name}
func (s *Server) handleReadSchedulingV1PriorityClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readSchedulingV1PriorityClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadSchedulingV1PriorityClass",
			ID:   "readSchedulingV1PriorityClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadSchedulingV1PriorityClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadSchedulingV1PriorityClass",
			OperationID:   "readSchedulingV1PriorityClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadSchedulingV1PriorityClassParams
			Response = ReadSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadSchedulingV1PriorityClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1CSIDriverRequest handles readStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/csidrivers/{name}
func (s *Server) handleReadStorageV1CSIDriverRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSIDriver"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1CSIDriver",
			ID:   "readStorageV1CSIDriver",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1CSIDriver", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1CSIDriverParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1CSIDriver",
			OperationID:   "readStorageV1CSIDriver",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1CSIDriverParams
			Response = ReadStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1CSIDriver(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1CSIDriverResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1CSINodeRequest handles readStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/csinodes/{name}
func (s *Server) handleReadStorageV1CSINodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1CSINode"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1CSINode",
			ID:   "readStorageV1CSINode",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1CSINode", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1CSINodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1CSINode",
			OperationID:   "readStorageV1CSINode",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1CSINodeParams
			Response = ReadStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1CSINode(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1CSINode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1CSINodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1StorageClassRequest handles readStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/storageclasses/{name}
func (s *Server) handleReadStorageV1StorageClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1StorageClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1StorageClass",
			ID:   "readStorageV1StorageClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1StorageClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1StorageClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1StorageClass",
			OperationID:   "readStorageV1StorageClass",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1StorageClassParams
			Response = ReadStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1StorageClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1StorageClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1VolumeAttachmentRequest handles readStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}
func (s *Server) handleReadStorageV1VolumeAttachmentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1VolumeAttachment",
			ID:   "readStorageV1VolumeAttachment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1VolumeAttachment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1VolumeAttachment",
			OperationID:   "readStorageV1VolumeAttachment",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1VolumeAttachmentParams
			Response = ReadStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1VolumeAttachment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1VolumeAttachmentStatusRequest handles readStorageV1VolumeAttachmentStatus operation.
//
// GET /apis/storage.k8s.io/v1/volumeattachments/{name}/status
func (s *Server) handleReadStorageV1VolumeAttachmentStatusRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1VolumeAttachmentStatus"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1VolumeAttachmentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1VolumeAttachmentStatus",
			ID:   "readStorageV1VolumeAttachmentStatus",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1VolumeAttachmentStatus", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1VolumeAttachmentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1VolumeAttachmentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1VolumeAttachmentStatus",
			OperationID:   "readStorageV1VolumeAttachmentStatus",
			Body:          nil,
			Params: map[string]any{
				"name":   params.Name,
				"pretty": params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1VolumeAttachmentStatusParams
			Response = ReadStorageV1VolumeAttachmentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1VolumeAttachmentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1VolumeAttachmentStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1VolumeAttachmentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1VolumeAttachmentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest handles readStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1alpha1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "readStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1alpha1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationID:   "readStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = ReadStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleReadStorageV1beta1NamespacedCSIStorageCapacityRequest handles readStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleReadStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readStorageV1beta1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReadStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReadStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "readStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "ReadStorageV1beta1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeReadStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReadStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReadStorageV1beta1NamespacedCSIStorageCapacity",
			OperationID:   "readStorageV1beta1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"name":      params.Name,
				"namespace": params.Namespace,
				"pretty":    params.Pretty,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReadStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = ReadStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReadStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReadStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReadStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReadStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest handles watchAdmissionregistrationV1MutatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
			ID:   "watchAdmissionregistrationV1MutatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAdmissionregistrationV1MutatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1MutatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAdmissionregistrationV1MutatingWebhookConfiguration",
			OperationID:   "watchAdmissionregistrationV1MutatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1MutatingWebhookConfigurationParams
			Response = WatchAdmissionregistrationV1MutatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1MutatingWebhookConfigurationList operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1MutatingWebhookConfigurationList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
			ID:   "watchAdmissionregistrationV1MutatingWebhookConfigurationList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAdmissionregistrationV1MutatingWebhookConfigurationList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1MutatingWebhookConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAdmissionregistrationV1MutatingWebhookConfigurationList",
			OperationID:   "watchAdmissionregistrationV1MutatingWebhookConfigurationList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1MutatingWebhookConfigurationListParams
			Response = WatchAdmissionregistrationV1MutatingWebhookConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1MutatingWebhookConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1MutatingWebhookConfigurationList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1MutatingWebhookConfigurationListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest handles watchAdmissionregistrationV1ValidatingWebhookConfiguration operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
			ID:   "watchAdmissionregistrationV1ValidatingWebhookConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAdmissionregistrationV1ValidatingWebhookConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1ValidatingWebhookConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAdmissionregistrationV1ValidatingWebhookConfiguration",
			OperationID:   "watchAdmissionregistrationV1ValidatingWebhookConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1ValidatingWebhookConfigurationParams
			Response = WatchAdmissionregistrationV1ValidatingWebhookConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest handles watchAdmissionregistrationV1ValidatingWebhookConfigurationList operation.
//
// GET /apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations
func (s *Server) handleWatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAdmissionregistrationV1ValidatingWebhookConfigurationList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			ID:   "watchAdmissionregistrationV1ValidatingWebhookConfigurationList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			OperationID:   "watchAdmissionregistrationV1ValidatingWebhookConfigurationList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams
			Response = WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAdmissionregistrationV1ValidatingWebhookConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAdmissionregistrationV1ValidatingWebhookConfigurationList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAdmissionregistrationV1ValidatingWebhookConfigurationListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchApiextensionsV1CustomResourceDefinitionRequest handles watchApiextensionsV1CustomResourceDefinition operation.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinition"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinition",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiextensionsV1CustomResourceDefinition",
			ID:   "watchApiextensionsV1CustomResourceDefinition",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchApiextensionsV1CustomResourceDefinition", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiextensionsV1CustomResourceDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchApiextensionsV1CustomResourceDefinition",
			OperationID:   "watchApiextensionsV1CustomResourceDefinition",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiextensionsV1CustomResourceDefinitionParams
			Response = WatchApiextensionsV1CustomResourceDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiextensionsV1CustomResourceDefinitionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchApiextensionsV1CustomResourceDefinition(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchApiextensionsV1CustomResourceDefinition(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchApiextensionsV1CustomResourceDefinitionListRequest handles watchApiextensionsV1CustomResourceDefinitionList operation.
//
// GET /apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions
func (s *Server) handleWatchApiextensionsV1CustomResourceDefinitionListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiextensionsV1CustomResourceDefinitionList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiextensionsV1CustomResourceDefinitionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiextensionsV1CustomResourceDefinitionList",
			ID:   "watchApiextensionsV1CustomResourceDefinitionList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchApiextensionsV1CustomResourceDefinitionList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchApiextensionsV1CustomResourceDefinitionListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiextensionsV1CustomResourceDefinitionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchApiextensionsV1CustomResourceDefinitionList",
			OperationID:   "watchApiextensionsV1CustomResourceDefinitionList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiextensionsV1CustomResourceDefinitionListParams
			Response = WatchApiextensionsV1CustomResourceDefinitionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiextensionsV1CustomResourceDefinitionListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchApiextensionsV1CustomResourceDefinitionList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchApiextensionsV1CustomResourceDefinitionList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiextensionsV1CustomResourceDefinitionListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchApiregistrationV1APIServiceRequest handles watchApiregistrationV1APIService operation.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices/{name}
func (s *Server) handleWatchApiregistrationV1APIServiceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiregistrationV1APIService",
			ID:   "watchApiregistrationV1APIService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchApiregistrationV1APIService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchApiregistrationV1APIServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiregistrationV1APIServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchApiregistrationV1APIService",
			OperationID:   "watchApiregistrationV1APIService",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiregistrationV1APIServiceParams
			Response = WatchApiregistrationV1APIServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiregistrationV1APIServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchApiregistrationV1APIService(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchApiregistrationV1APIService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchApiregistrationV1APIServiceListRequest handles watchApiregistrationV1APIServiceList operation.
//
// GET /apis/apiregistration.k8s.io/v1/watch/apiservices
func (s *Server) handleWatchApiregistrationV1APIServiceListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchApiregistrationV1APIServiceList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchApiregistrationV1APIServiceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchApiregistrationV1APIServiceList",
			ID:   "watchApiregistrationV1APIServiceList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchApiregistrationV1APIServiceList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchApiregistrationV1APIServiceListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchApiregistrationV1APIServiceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchApiregistrationV1APIServiceList",
			OperationID:   "watchApiregistrationV1APIServiceList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchApiregistrationV1APIServiceListParams
			Response = WatchApiregistrationV1APIServiceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchApiregistrationV1APIServiceListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchApiregistrationV1APIServiceList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchApiregistrationV1APIServiceList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchApiregistrationV1APIServiceListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1ControllerRevisionListForAllNamespacesRequest handles watchAppsV1ControllerRevisionListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/controllerrevisions
func (s *Server) handleWatchAppsV1ControllerRevisionListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ControllerRevisionListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ControllerRevisionListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1ControllerRevisionListForAllNamespaces",
			ID:   "watchAppsV1ControllerRevisionListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1ControllerRevisionListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1ControllerRevisionListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1ControllerRevisionListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1ControllerRevisionListForAllNamespaces",
			OperationID:   "watchAppsV1ControllerRevisionListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1ControllerRevisionListForAllNamespacesParams
			Response = WatchAppsV1ControllerRevisionListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1ControllerRevisionListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1ControllerRevisionListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1ControllerRevisionListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1ControllerRevisionListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1DaemonSetListForAllNamespacesRequest handles watchAppsV1DaemonSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/daemonsets
func (s *Server) handleWatchAppsV1DaemonSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DaemonSetListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DaemonSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1DaemonSetListForAllNamespaces",
			ID:   "watchAppsV1DaemonSetListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1DaemonSetListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1DaemonSetListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1DaemonSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1DaemonSetListForAllNamespaces",
			OperationID:   "watchAppsV1DaemonSetListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1DaemonSetListForAllNamespacesParams
			Response = WatchAppsV1DaemonSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1DaemonSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1DaemonSetListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1DaemonSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1DaemonSetListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1DeploymentListForAllNamespacesRequest handles watchAppsV1DeploymentListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/deployments
func (s *Server) handleWatchAppsV1DeploymentListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1DeploymentListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1DeploymentListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1DeploymentListForAllNamespaces",
			ID:   "watchAppsV1DeploymentListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1DeploymentListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1DeploymentListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1DeploymentListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1DeploymentListForAllNamespaces",
			OperationID:   "watchAppsV1DeploymentListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1DeploymentListForAllNamespacesParams
			Response = WatchAppsV1DeploymentListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1DeploymentListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1DeploymentListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1DeploymentListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1DeploymentListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedControllerRevisionRequest handles watchAppsV1NamespacedControllerRevision operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevision"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedControllerRevision",
			ID:   "watchAppsV1NamespacedControllerRevision",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedControllerRevision", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedControllerRevisionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedControllerRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedControllerRevision",
			OperationID:   "watchAppsV1NamespacedControllerRevision",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedControllerRevisionParams
			Response = WatchAppsV1NamespacedControllerRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedControllerRevisionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedControllerRevision(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedControllerRevision(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedControllerRevisionListRequest handles watchAppsV1NamespacedControllerRevisionList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions
func (s *Server) handleWatchAppsV1NamespacedControllerRevisionListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedControllerRevisionList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedControllerRevisionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedControllerRevisionList",
			ID:   "watchAppsV1NamespacedControllerRevisionList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedControllerRevisionList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedControllerRevisionListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedControllerRevisionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedControllerRevisionList",
			OperationID:   "watchAppsV1NamespacedControllerRevisionList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedControllerRevisionListParams
			Response = WatchAppsV1NamespacedControllerRevisionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedControllerRevisionListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedControllerRevisionList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedControllerRevisionList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedControllerRevisionListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedDaemonSetRequest handles watchAppsV1NamespacedDaemonSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}
func (s *Server) handleWatchAppsV1NamespacedDaemonSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDaemonSet",
			ID:   "watchAppsV1NamespacedDaemonSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedDaemonSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedDaemonSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDaemonSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedDaemonSet",
			OperationID:   "watchAppsV1NamespacedDaemonSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDaemonSetParams
			Response = WatchAppsV1NamespacedDaemonSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDaemonSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedDaemonSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDaemonSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedDaemonSetListRequest handles watchAppsV1NamespacedDaemonSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/daemonsets
func (s *Server) handleWatchAppsV1NamespacedDaemonSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDaemonSetList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDaemonSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDaemonSetList",
			ID:   "watchAppsV1NamespacedDaemonSetList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedDaemonSetList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedDaemonSetListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDaemonSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedDaemonSetList",
			OperationID:   "watchAppsV1NamespacedDaemonSetList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDaemonSetListParams
			Response = WatchAppsV1NamespacedDaemonSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDaemonSetListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedDaemonSetList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDaemonSetList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDaemonSetListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedDeploymentRequest handles watchAppsV1NamespacedDeployment operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}
func (s *Server) handleWatchAppsV1NamespacedDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDeployment",
			ID:   "watchAppsV1NamespacedDeployment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedDeployment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedDeployment",
			OperationID:   "watchAppsV1NamespacedDeployment",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDeploymentParams
			Response = WatchAppsV1NamespacedDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedDeployment(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedDeploymentListRequest handles watchAppsV1NamespacedDeploymentList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/deployments
func (s *Server) handleWatchAppsV1NamespacedDeploymentListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedDeploymentList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedDeploymentList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedDeploymentList",
			ID:   "watchAppsV1NamespacedDeploymentList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedDeploymentList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedDeploymentListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedDeploymentListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedDeploymentList",
			OperationID:   "watchAppsV1NamespacedDeploymentList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedDeploymentListParams
			Response = WatchAppsV1NamespacedDeploymentListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedDeploymentListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedDeploymentList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedDeploymentList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedDeploymentListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedReplicaSetRequest handles watchAppsV1NamespacedReplicaSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}
func (s *Server) handleWatchAppsV1NamespacedReplicaSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedReplicaSet",
			ID:   "watchAppsV1NamespacedReplicaSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedReplicaSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedReplicaSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedReplicaSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedReplicaSet",
			OperationID:   "watchAppsV1NamespacedReplicaSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedReplicaSetParams
			Response = WatchAppsV1NamespacedReplicaSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedReplicaSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedReplicaSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedReplicaSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedReplicaSetListRequest handles watchAppsV1NamespacedReplicaSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/replicasets
func (s *Server) handleWatchAppsV1NamespacedReplicaSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedReplicaSetList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedReplicaSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedReplicaSetList",
			ID:   "watchAppsV1NamespacedReplicaSetList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedReplicaSetList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedReplicaSetListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedReplicaSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedReplicaSetList",
			OperationID:   "watchAppsV1NamespacedReplicaSetList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedReplicaSetListParams
			Response = WatchAppsV1NamespacedReplicaSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedReplicaSetListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedReplicaSetList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedReplicaSetList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedReplicaSetListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedStatefulSetRequest handles watchAppsV1NamespacedStatefulSet operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}
func (s *Server) handleWatchAppsV1NamespacedStatefulSetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedStatefulSet",
			ID:   "watchAppsV1NamespacedStatefulSet",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedStatefulSet", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedStatefulSetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedStatefulSetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedStatefulSet",
			OperationID:   "watchAppsV1NamespacedStatefulSet",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedStatefulSetParams
			Response = WatchAppsV1NamespacedStatefulSetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedStatefulSetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedStatefulSet(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedStatefulSet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1NamespacedStatefulSetListRequest handles watchAppsV1NamespacedStatefulSetList operation.
//
// GET /apis/apps/v1/watch/namespaces/{namespace}/statefulsets
func (s *Server) handleWatchAppsV1NamespacedStatefulSetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1NamespacedStatefulSetList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1NamespacedStatefulSetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1NamespacedStatefulSetList",
			ID:   "watchAppsV1NamespacedStatefulSetList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1NamespacedStatefulSetList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1NamespacedStatefulSetListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1NamespacedStatefulSetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1NamespacedStatefulSetList",
			OperationID:   "watchAppsV1NamespacedStatefulSetList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1NamespacedStatefulSetListParams
			Response = WatchAppsV1NamespacedStatefulSetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1NamespacedStatefulSetListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1NamespacedStatefulSetList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1NamespacedStatefulSetList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1NamespacedStatefulSetListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1ReplicaSetListForAllNamespacesRequest handles watchAppsV1ReplicaSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/replicasets
func (s *Server) handleWatchAppsV1ReplicaSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1ReplicaSetListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1ReplicaSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1ReplicaSetListForAllNamespaces",
			ID:   "watchAppsV1ReplicaSetListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1ReplicaSetListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1ReplicaSetListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1ReplicaSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1ReplicaSetListForAllNamespaces",
			OperationID:   "watchAppsV1ReplicaSetListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1ReplicaSetListForAllNamespacesParams
			Response = WatchAppsV1ReplicaSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1ReplicaSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1ReplicaSetListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1ReplicaSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1ReplicaSetListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAppsV1StatefulSetListForAllNamespacesRequest handles watchAppsV1StatefulSetListForAllNamespaces operation.
//
// GET /apis/apps/v1/watch/statefulsets
func (s *Server) handleWatchAppsV1StatefulSetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAppsV1StatefulSetListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAppsV1StatefulSetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAppsV1StatefulSetListForAllNamespaces",
			ID:   "watchAppsV1StatefulSetListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAppsV1StatefulSetListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAppsV1StatefulSetListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAppsV1StatefulSetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAppsV1StatefulSetListForAllNamespaces",
			OperationID:   "watchAppsV1StatefulSetListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAppsV1StatefulSetListForAllNamespacesParams
			Response = WatchAppsV1StatefulSetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAppsV1StatefulSetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAppsV1StatefulSetListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAppsV1StatefulSetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAppsV1StatefulSetListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			OperationID:   "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			OperationID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV1NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV1NamespacedHorizontalPodAutoscalerList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			OperationID:   "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV1NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta1/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			OperationID:   "watchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			OperationID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			OperationID:   "watchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest handles watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces operation.
//
// GET /apis/autoscaling/v2beta2/watch/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			ID:   "watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			OperationID:   "watchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams
			Response = WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2HorizontalPodAutoscalerListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler operation.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			ID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			OperationID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams
			Response = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest handles watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList operation.
//
// GET /apis/autoscaling/v2beta2/watch/namespaces/{namespace}/horizontalpodautoscalers
func (s *Server) handleWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			ID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			OperationID:   "watchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams
			Response = WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1CronJobListForAllNamespacesRequest handles watchBatchV1CronJobListForAllNamespaces operation.
//
// GET /apis/batch/v1/watch/cronjobs
func (s *Server) handleWatchBatchV1CronJobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1CronJobListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1CronJobListForAllNamespaces",
			ID:   "watchBatchV1CronJobListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1CronJobListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1CronJobListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1CronJobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1CronJobListForAllNamespaces",
			OperationID:   "watchBatchV1CronJobListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1CronJobListForAllNamespacesParams
			Response = WatchBatchV1CronJobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1CronJobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1CronJobListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1CronJobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1JobListForAllNamespacesRequest handles watchBatchV1JobListForAllNamespaces operation.
//
// GET /apis/batch/v1/watch/jobs
func (s *Server) handleWatchBatchV1JobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1JobListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1JobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1JobListForAllNamespaces",
			ID:   "watchBatchV1JobListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1JobListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1JobListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1JobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1JobListForAllNamespaces",
			OperationID:   "watchBatchV1JobListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1JobListForAllNamespacesParams
			Response = WatchBatchV1JobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1JobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1JobListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1JobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1JobListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1NamespacedCronJobRequest handles watchBatchV1NamespacedCronJob operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedCronJob",
			ID:   "watchBatchV1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1NamespacedCronJob",
			OperationID:   "watchBatchV1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedCronJobParams
			Response = WatchBatchV1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1NamespacedCronJobListRequest handles watchBatchV1NamespacedCronJobList operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1NamespacedCronJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedCronJobList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedCronJobList",
			ID:   "watchBatchV1NamespacedCronJobList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1NamespacedCronJobList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1NamespacedCronJobListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedCronJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1NamespacedCronJobList",
			OperationID:   "watchBatchV1NamespacedCronJobList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedCronJobListParams
			Response = WatchBatchV1NamespacedCronJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedCronJobListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1NamespacedCronJobList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedCronJobList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedCronJobListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1NamespacedJobRequest handles watchBatchV1NamespacedJob operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}
func (s *Server) handleWatchBatchV1NamespacedJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedJob",
			ID:   "watchBatchV1NamespacedJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1NamespacedJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1NamespacedJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1NamespacedJob",
			OperationID:   "watchBatchV1NamespacedJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedJobParams
			Response = WatchBatchV1NamespacedJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1NamespacedJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1NamespacedJobListRequest handles watchBatchV1NamespacedJobList operation.
//
// GET /apis/batch/v1/watch/namespaces/{namespace}/jobs
func (s *Server) handleWatchBatchV1NamespacedJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1NamespacedJobList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1NamespacedJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1NamespacedJobList",
			ID:   "watchBatchV1NamespacedJobList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1NamespacedJobList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1NamespacedJobListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1NamespacedJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1NamespacedJobList",
			OperationID:   "watchBatchV1NamespacedJobList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1NamespacedJobListParams
			Response = WatchBatchV1NamespacedJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1NamespacedJobListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1NamespacedJobList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1NamespacedJobList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1NamespacedJobListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1beta1CronJobListForAllNamespacesRequest handles watchBatchV1beta1CronJobListForAllNamespaces operation.
//
// GET /apis/batch/v1beta1/watch/cronjobs
func (s *Server) handleWatchBatchV1beta1CronJobListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1CronJobListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1CronJobListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1CronJobListForAllNamespaces",
			ID:   "watchBatchV1beta1CronJobListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1beta1CronJobListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1beta1CronJobListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1CronJobListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1beta1CronJobListForAllNamespaces",
			OperationID:   "watchBatchV1beta1CronJobListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1CronJobListForAllNamespacesParams
			Response = WatchBatchV1beta1CronJobListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1CronJobListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1beta1CronJobListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1CronJobListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1CronJobListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1beta1NamespacedCronJobRequest handles watchBatchV1beta1NamespacedCronJob operation.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1NamespacedCronJob",
			ID:   "watchBatchV1beta1NamespacedCronJob",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1beta1NamespacedCronJob", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1beta1NamespacedCronJobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1NamespacedCronJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1beta1NamespacedCronJob",
			OperationID:   "watchBatchV1beta1NamespacedCronJob",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1NamespacedCronJobParams
			Response = WatchBatchV1beta1NamespacedCronJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1NamespacedCronJobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1beta1NamespacedCronJob(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1NamespacedCronJob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchBatchV1beta1NamespacedCronJobListRequest handles watchBatchV1beta1NamespacedCronJobList operation.
//
// GET /apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs
func (s *Server) handleWatchBatchV1beta1NamespacedCronJobListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchBatchV1beta1NamespacedCronJobList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchBatchV1beta1NamespacedCronJobList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchBatchV1beta1NamespacedCronJobList",
			ID:   "watchBatchV1beta1NamespacedCronJobList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchBatchV1beta1NamespacedCronJobList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchBatchV1beta1NamespacedCronJobListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchBatchV1beta1NamespacedCronJobListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchBatchV1beta1NamespacedCronJobList",
			OperationID:   "watchBatchV1beta1NamespacedCronJobList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchBatchV1beta1NamespacedCronJobListParams
			Response = WatchBatchV1beta1NamespacedCronJobListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchBatchV1beta1NamespacedCronJobListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchBatchV1beta1NamespacedCronJobList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchBatchV1beta1NamespacedCronJobList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchBatchV1beta1NamespacedCronJobListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCertificatesV1CertificateSigningRequestRequest handles watchCertificatesV1CertificateSigningRequest operation.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCertificatesV1CertificateSigningRequest",
			ID:   "watchCertificatesV1CertificateSigningRequest",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCertificatesV1CertificateSigningRequest", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCertificatesV1CertificateSigningRequestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCertificatesV1CertificateSigningRequestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCertificatesV1CertificateSigningRequest",
			OperationID:   "watchCertificatesV1CertificateSigningRequest",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCertificatesV1CertificateSigningRequestParams
			Response = WatchCertificatesV1CertificateSigningRequestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCertificatesV1CertificateSigningRequestParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCertificatesV1CertificateSigningRequest(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCertificatesV1CertificateSigningRequest(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCertificatesV1CertificateSigningRequestListRequest handles watchCertificatesV1CertificateSigningRequestList operation.
//
// GET /apis/certificates.k8s.io/v1/watch/certificatesigningrequests
func (s *Server) handleWatchCertificatesV1CertificateSigningRequestListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCertificatesV1CertificateSigningRequestList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCertificatesV1CertificateSigningRequestList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCertificatesV1CertificateSigningRequestList",
			ID:   "watchCertificatesV1CertificateSigningRequestList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCertificatesV1CertificateSigningRequestList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCertificatesV1CertificateSigningRequestListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCertificatesV1CertificateSigningRequestListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCertificatesV1CertificateSigningRequestList",
			OperationID:   "watchCertificatesV1CertificateSigningRequestList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCertificatesV1CertificateSigningRequestListParams
			Response = WatchCertificatesV1CertificateSigningRequestListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCertificatesV1CertificateSigningRequestListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCertificatesV1CertificateSigningRequestList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCertificatesV1CertificateSigningRequestList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCertificatesV1CertificateSigningRequestListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoordinationV1LeaseListForAllNamespacesRequest handles watchCoordinationV1LeaseListForAllNamespaces operation.
//
// GET /apis/coordination.k8s.io/v1/watch/leases
func (s *Server) handleWatchCoordinationV1LeaseListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1LeaseListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1LeaseListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1LeaseListForAllNamespaces",
			ID:   "watchCoordinationV1LeaseListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoordinationV1LeaseListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoordinationV1LeaseListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1LeaseListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoordinationV1LeaseListForAllNamespaces",
			OperationID:   "watchCoordinationV1LeaseListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1LeaseListForAllNamespacesParams
			Response = WatchCoordinationV1LeaseListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1LeaseListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoordinationV1LeaseListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1LeaseListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1LeaseListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoordinationV1NamespacedLeaseRequest handles watchCoordinationV1NamespacedLease operation.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}
func (s *Server) handleWatchCoordinationV1NamespacedLeaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLease"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1NamespacedLease",
			ID:   "watchCoordinationV1NamespacedLease",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoordinationV1NamespacedLease", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoordinationV1NamespacedLeaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1NamespacedLeaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoordinationV1NamespacedLease",
			OperationID:   "watchCoordinationV1NamespacedLease",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1NamespacedLeaseParams
			Response = WatchCoordinationV1NamespacedLeaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1NamespacedLeaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoordinationV1NamespacedLease(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1NamespacedLease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoordinationV1NamespacedLeaseListRequest handles watchCoordinationV1NamespacedLeaseList operation.
//
// GET /apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases
func (s *Server) handleWatchCoordinationV1NamespacedLeaseListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoordinationV1NamespacedLeaseList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoordinationV1NamespacedLeaseList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoordinationV1NamespacedLeaseList",
			ID:   "watchCoordinationV1NamespacedLeaseList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoordinationV1NamespacedLeaseList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoordinationV1NamespacedLeaseListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoordinationV1NamespacedLeaseListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoordinationV1NamespacedLeaseList",
			OperationID:   "watchCoordinationV1NamespacedLeaseList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoordinationV1NamespacedLeaseListParams
			Response = WatchCoordinationV1NamespacedLeaseListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoordinationV1NamespacedLeaseListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoordinationV1NamespacedLeaseList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoordinationV1NamespacedLeaseList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoordinationV1NamespacedLeaseListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1ConfigMapListForAllNamespacesRequest handles watchCoreV1ConfigMapListForAllNamespaces operation.
//
// GET /api/v1/watch/configmaps
func (s *Server) handleWatchCoreV1ConfigMapListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ConfigMapListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ConfigMapListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ConfigMapListForAllNamespaces",
			ID:   "watchCoreV1ConfigMapListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1ConfigMapListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1ConfigMapListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ConfigMapListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1ConfigMapListForAllNamespaces",
			OperationID:   "watchCoreV1ConfigMapListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ConfigMapListForAllNamespacesParams
			Response = WatchCoreV1ConfigMapListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ConfigMapListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1ConfigMapListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ConfigMapListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ConfigMapListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1EndpointsListForAllNamespacesRequest handles watchCoreV1EndpointsListForAllNamespaces operation.
//
// GET /api/v1/watch/endpoints
func (s *Server) handleWatchCoreV1EndpointsListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EndpointsListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EndpointsListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1EndpointsListForAllNamespaces",
			ID:   "watchCoreV1EndpointsListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1EndpointsListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1EndpointsListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1EndpointsListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1EndpointsListForAllNamespaces",
			OperationID:   "watchCoreV1EndpointsListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1EndpointsListForAllNamespacesParams
			Response = WatchCoreV1EndpointsListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1EndpointsListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1EndpointsListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1EndpointsListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1EndpointsListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1EventListForAllNamespacesRequest handles watchCoreV1EventListForAllNamespaces operation.
//
// GET /api/v1/watch/events
func (s *Server) handleWatchCoreV1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1EventListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1EventListForAllNamespaces",
			ID:   "watchCoreV1EventListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1EventListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1EventListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1EventListForAllNamespaces",
			OperationID:   "watchCoreV1EventListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1EventListForAllNamespacesParams
			Response = WatchCoreV1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1EventListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1LimitRangeListForAllNamespacesRequest handles watchCoreV1LimitRangeListForAllNamespaces operation.
//
// GET /api/v1/watch/limitranges
func (s *Server) handleWatchCoreV1LimitRangeListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1LimitRangeListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1LimitRangeListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1LimitRangeListForAllNamespaces",
			ID:   "watchCoreV1LimitRangeListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1LimitRangeListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1LimitRangeListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1LimitRangeListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1LimitRangeListForAllNamespaces",
			OperationID:   "watchCoreV1LimitRangeListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1LimitRangeListForAllNamespacesParams
			Response = WatchCoreV1LimitRangeListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1LimitRangeListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1LimitRangeListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1LimitRangeListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1LimitRangeListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespaceRequest handles watchCoreV1Namespace operation.
//
// GET /api/v1/watch/namespaces/{name}
func (s *Server) handleWatchCoreV1NamespaceRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Namespace"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Namespace",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1Namespace",
			ID:   "watchCoreV1Namespace",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1Namespace", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespaceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1Namespace",
			OperationID:   "watchCoreV1Namespace",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespaceParams
			Response = WatchCoreV1NamespaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespaceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1Namespace(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1Namespace(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespaceListRequest handles watchCoreV1NamespaceList operation.
//
// GET /api/v1/watch/namespaces
func (s *Server) handleWatchCoreV1NamespaceListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespaceList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespaceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespaceList",
			ID:   "watchCoreV1NamespaceList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespaceList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespaceListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespaceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespaceList",
			OperationID:   "watchCoreV1NamespaceList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespaceListParams
			Response = WatchCoreV1NamespaceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespaceListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespaceList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespaceList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespaceListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedConfigMapRequest handles watchCoreV1NamespacedConfigMap operation.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps/{name}
func (s *Server) handleWatchCoreV1NamespacedConfigMapRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMap"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMap",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedConfigMap",
			ID:   "watchCoreV1NamespacedConfigMap",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedConfigMap", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedConfigMapParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedConfigMapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedConfigMap",
			OperationID:   "watchCoreV1NamespacedConfigMap",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedConfigMapParams
			Response = WatchCoreV1NamespacedConfigMapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedConfigMapParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedConfigMap(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedConfigMap(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedConfigMapListRequest handles watchCoreV1NamespacedConfigMapList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/configmaps
func (s *Server) handleWatchCoreV1NamespacedConfigMapListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedConfigMapList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedConfigMapList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedConfigMapList",
			ID:   "watchCoreV1NamespacedConfigMapList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedConfigMapList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedConfigMapListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedConfigMapListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedConfigMapList",
			OperationID:   "watchCoreV1NamespacedConfigMapList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedConfigMapListParams
			Response = WatchCoreV1NamespacedConfigMapListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedConfigMapListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedConfigMapList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedConfigMapList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedConfigMapListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedEndpointsRequest handles watchCoreV1NamespacedEndpoints operation.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints/{name}
func (s *Server) handleWatchCoreV1NamespacedEndpointsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpoints",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEndpoints",
			ID:   "watchCoreV1NamespacedEndpoints",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedEndpoints", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedEndpointsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEndpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedEndpoints",
			OperationID:   "watchCoreV1NamespacedEndpoints",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEndpointsParams
			Response = WatchCoreV1NamespacedEndpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEndpointsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedEndpoints(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEndpoints(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedEndpointsListRequest handles watchCoreV1NamespacedEndpointsList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/endpoints
func (s *Server) handleWatchCoreV1NamespacedEndpointsListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEndpointsList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEndpointsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEndpointsList",
			ID:   "watchCoreV1NamespacedEndpointsList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedEndpointsList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedEndpointsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEndpointsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedEndpointsList",
			OperationID:   "watchCoreV1NamespacedEndpointsList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEndpointsListParams
			Response = WatchCoreV1NamespacedEndpointsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEndpointsListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedEndpointsList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEndpointsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEndpointsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedEventRequest handles watchCoreV1NamespacedEvent operation.
//
// GET /api/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchCoreV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEvent",
			ID:   "watchCoreV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedEvent",
			OperationID:   "watchCoreV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEventParams
			Response = WatchCoreV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedEventListRequest handles watchCoreV1NamespacedEventList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchCoreV1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedEventList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedEventList",
			ID:   "watchCoreV1NamespacedEventList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedEventList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedEventListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedEventList",
			OperationID:   "watchCoreV1NamespacedEventList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedEventListParams
			Response = WatchCoreV1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedEventList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedEventList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedEventListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedLimitRangeRequest handles watchCoreV1NamespacedLimitRange operation.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges/{name}
func (s *Server) handleWatchCoreV1NamespacedLimitRangeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRange"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRange",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedLimitRange",
			ID:   "watchCoreV1NamespacedLimitRange",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedLimitRange", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedLimitRangeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedLimitRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedLimitRange",
			OperationID:   "watchCoreV1NamespacedLimitRange",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedLimitRangeParams
			Response = WatchCoreV1NamespacedLimitRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedLimitRangeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedLimitRange(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedLimitRange(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedLimitRangeListRequest handles watchCoreV1NamespacedLimitRangeList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/limitranges
func (s *Server) handleWatchCoreV1NamespacedLimitRangeListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedLimitRangeList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedLimitRangeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedLimitRangeList",
			ID:   "watchCoreV1NamespacedLimitRangeList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedLimitRangeList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedLimitRangeListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedLimitRangeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedLimitRangeList",
			OperationID:   "watchCoreV1NamespacedLimitRangeList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedLimitRangeListParams
			Response = WatchCoreV1NamespacedLimitRangeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedLimitRangeListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedLimitRangeList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedLimitRangeList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedLimitRangeListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPersistentVolumeClaimRequest handles watchCoreV1NamespacedPersistentVolumeClaim operation.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaim"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaim",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPersistentVolumeClaim",
			ID:   "watchCoreV1NamespacedPersistentVolumeClaim",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPersistentVolumeClaim", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPersistentVolumeClaimRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPersistentVolumeClaim",
			OperationID:   "watchCoreV1NamespacedPersistentVolumeClaim",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPersistentVolumeClaimParams
			Response = WatchCoreV1NamespacedPersistentVolumeClaimRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPersistentVolumeClaimParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPersistentVolumeClaim(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaim(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPersistentVolumeClaimListRequest handles watchCoreV1NamespacedPersistentVolumeClaimList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims
func (s *Server) handleWatchCoreV1NamespacedPersistentVolumeClaimListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPersistentVolumeClaimList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPersistentVolumeClaimList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPersistentVolumeClaimList",
			ID:   "watchCoreV1NamespacedPersistentVolumeClaimList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPersistentVolumeClaimList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPersistentVolumeClaimListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPersistentVolumeClaimListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPersistentVolumeClaimList",
			OperationID:   "watchCoreV1NamespacedPersistentVolumeClaimList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPersistentVolumeClaimListParams
			Response = WatchCoreV1NamespacedPersistentVolumeClaimListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPersistentVolumeClaimListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPersistentVolumeClaimList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPersistentVolumeClaimList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPersistentVolumeClaimListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPodRequest handles watchCoreV1NamespacedPod operation.
//
// GET /api/v1/watch/namespaces/{namespace}/pods/{name}
func (s *Server) handleWatchCoreV1NamespacedPodRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPod"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPod",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPod",
			ID:   "watchCoreV1NamespacedPod",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPod", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPodParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPod",
			OperationID:   "watchCoreV1NamespacedPod",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodParams
			Response = WatchCoreV1NamespacedPodRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPod(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPod(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPodListRequest handles watchCoreV1NamespacedPodList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/pods
func (s *Server) handleWatchCoreV1NamespacedPodListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodList",
			ID:   "watchCoreV1NamespacedPodList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPodListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPodList",
			OperationID:   "watchCoreV1NamespacedPodList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodListParams
			Response = WatchCoreV1NamespacedPodListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPodList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPodTemplateRequest handles watchCoreV1NamespacedPodTemplate operation.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates/{name}
func (s *Server) handleWatchCoreV1NamespacedPodTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodTemplate",
			ID:   "watchCoreV1NamespacedPodTemplate",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodTemplate", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPodTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPodTemplate",
			OperationID:   "watchCoreV1NamespacedPodTemplate",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodTemplateParams
			Response = WatchCoreV1NamespacedPodTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodTemplateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPodTemplate(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodTemplate(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedPodTemplateListRequest handles watchCoreV1NamespacedPodTemplateList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/podtemplates
func (s *Server) handleWatchCoreV1NamespacedPodTemplateListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedPodTemplateList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedPodTemplateList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedPodTemplateList",
			ID:   "watchCoreV1NamespacedPodTemplateList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedPodTemplateList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedPodTemplateListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedPodTemplateListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedPodTemplateList",
			OperationID:   "watchCoreV1NamespacedPodTemplateList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedPodTemplateListParams
			Response = WatchCoreV1NamespacedPodTemplateListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedPodTemplateListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedPodTemplateList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedPodTemplateList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedPodTemplateListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedReplicationControllerRequest handles watchCoreV1NamespacedReplicationController operation.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationController"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationController",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedReplicationController",
			ID:   "watchCoreV1NamespacedReplicationController",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedReplicationController", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedReplicationControllerParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedReplicationControllerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedReplicationController",
			OperationID:   "watchCoreV1NamespacedReplicationController",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedReplicationControllerParams
			Response = WatchCoreV1NamespacedReplicationControllerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedReplicationControllerParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedReplicationController(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedReplicationController(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedReplicationControllerListRequest handles watchCoreV1NamespacedReplicationControllerList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/replicationcontrollers
func (s *Server) handleWatchCoreV1NamespacedReplicationControllerListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedReplicationControllerList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedReplicationControllerList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedReplicationControllerList",
			ID:   "watchCoreV1NamespacedReplicationControllerList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedReplicationControllerList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedReplicationControllerListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedReplicationControllerListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedReplicationControllerList",
			OperationID:   "watchCoreV1NamespacedReplicationControllerList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedReplicationControllerListParams
			Response = WatchCoreV1NamespacedReplicationControllerListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedReplicationControllerListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedReplicationControllerList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedReplicationControllerList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedReplicationControllerListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedResourceQuotaRequest handles watchCoreV1NamespacedResourceQuota operation.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas/{name}
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuota"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuota",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedResourceQuota",
			ID:   "watchCoreV1NamespacedResourceQuota",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedResourceQuota", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedResourceQuotaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedResourceQuotaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedResourceQuota",
			OperationID:   "watchCoreV1NamespacedResourceQuota",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedResourceQuotaParams
			Response = WatchCoreV1NamespacedResourceQuotaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedResourceQuotaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedResourceQuota(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedResourceQuota(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedResourceQuotaListRequest handles watchCoreV1NamespacedResourceQuotaList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/resourcequotas
func (s *Server) handleWatchCoreV1NamespacedResourceQuotaListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedResourceQuotaList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedResourceQuotaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedResourceQuotaList",
			ID:   "watchCoreV1NamespacedResourceQuotaList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedResourceQuotaList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedResourceQuotaListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedResourceQuotaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedResourceQuotaList",
			OperationID:   "watchCoreV1NamespacedResourceQuotaList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedResourceQuotaListParams
			Response = WatchCoreV1NamespacedResourceQuotaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedResourceQuotaListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedResourceQuotaList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedResourceQuotaList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedResourceQuotaListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedSecretRequest handles watchCoreV1NamespacedSecret operation.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets/{name}
func (s *Server) handleWatchCoreV1NamespacedSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedSecret",
			ID:   "watchCoreV1NamespacedSecret",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedSecret", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedSecret",
			OperationID:   "watchCoreV1NamespacedSecret",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedSecretParams
			Response = WatchCoreV1NamespacedSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedSecretListRequest handles watchCoreV1NamespacedSecretList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/secrets
func (s *Server) handleWatchCoreV1NamespacedSecretListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedSecretList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedSecretList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedSecretList",
			ID:   "watchCoreV1NamespacedSecretList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedSecretList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedSecretListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedSecretListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedSecretList",
			OperationID:   "watchCoreV1NamespacedSecretList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedSecretListParams
			Response = WatchCoreV1NamespacedSecretListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedSecretListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedSecretList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedSecretList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedSecretListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedServiceRequest handles watchCoreV1NamespacedService operation.
//
// GET /api/v1/watch/namespaces/{namespace}/services/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedService"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedService",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedService",
			ID:   "watchCoreV1NamespacedService",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedService", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedServiceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedService",
			OperationID:   "watchCoreV1NamespacedService",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceParams
			Response = WatchCoreV1NamespacedServiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedService(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedService(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedServiceAccountRequest handles watchCoreV1NamespacedServiceAccount operation.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}
func (s *Server) handleWatchCoreV1NamespacedServiceAccountRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccount"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceAccount",
			ID:   "watchCoreV1NamespacedServiceAccount",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceAccount", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedServiceAccountParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedServiceAccount",
			OperationID:   "watchCoreV1NamespacedServiceAccount",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceAccountParams
			Response = WatchCoreV1NamespacedServiceAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceAccountParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedServiceAccount(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceAccount(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedServiceAccountListRequest handles watchCoreV1NamespacedServiceAccountList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/serviceaccounts
func (s *Server) handleWatchCoreV1NamespacedServiceAccountListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceAccountList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceAccountList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceAccountList",
			ID:   "watchCoreV1NamespacedServiceAccountList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceAccountList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedServiceAccountListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceAccountListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedServiceAccountList",
			OperationID:   "watchCoreV1NamespacedServiceAccountList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceAccountListParams
			Response = WatchCoreV1NamespacedServiceAccountListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceAccountListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedServiceAccountList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceAccountList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceAccountListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NamespacedServiceListRequest handles watchCoreV1NamespacedServiceList operation.
//
// GET /api/v1/watch/namespaces/{namespace}/services
func (s *Server) handleWatchCoreV1NamespacedServiceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NamespacedServiceList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NamespacedServiceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NamespacedServiceList",
			ID:   "watchCoreV1NamespacedServiceList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NamespacedServiceList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NamespacedServiceListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NamespacedServiceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NamespacedServiceList",
			OperationID:   "watchCoreV1NamespacedServiceList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NamespacedServiceListParams
			Response = WatchCoreV1NamespacedServiceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NamespacedServiceListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NamespacedServiceList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NamespacedServiceList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NamespacedServiceListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NodeRequest handles watchCoreV1Node operation.
//
// GET /api/v1/watch/nodes/{name}
func (s *Server) handleWatchCoreV1NodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1Node"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1Node",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1Node",
			ID:   "watchCoreV1Node",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1Node", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1Node",
			OperationID:   "watchCoreV1Node",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NodeParams
			Response = WatchCoreV1NodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1Node(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1Node(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1NodeListRequest handles watchCoreV1NodeList operation.
//
// GET /api/v1/watch/nodes
func (s *Server) handleWatchCoreV1NodeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1NodeList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1NodeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1NodeList",
			ID:   "watchCoreV1NodeList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1NodeList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1NodeListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1NodeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1NodeList",
			OperationID:   "watchCoreV1NodeList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1NodeListParams
			Response = WatchCoreV1NodeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1NodeListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1NodeList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1NodeList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1NodeListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1PersistentVolumeRequest handles watchCoreV1PersistentVolume operation.
//
// GET /api/v1/watch/persistentvolumes/{name}
func (s *Server) handleWatchCoreV1PersistentVolumeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolume"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolume",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolume",
			ID:   "watchCoreV1PersistentVolume",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1PersistentVolume", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1PersistentVolumeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1PersistentVolume",
			OperationID:   "watchCoreV1PersistentVolume",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeParams
			Response = WatchCoreV1PersistentVolumeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1PersistentVolume(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolume(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest handles watchCoreV1PersistentVolumeClaimListForAllNamespaces operation.
//
// GET /api/v1/watch/persistentvolumeclaims
func (s *Server) handleWatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeClaimListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
			ID:   "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1PersistentVolumeClaimListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeClaimListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1PersistentVolumeClaimListForAllNamespaces",
			OperationID:   "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams
			Response = WatchCoreV1PersistentVolumeClaimListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeClaimListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolumeClaimListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeClaimListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1PersistentVolumeListRequest handles watchCoreV1PersistentVolumeList operation.
//
// GET /api/v1/watch/persistentvolumes
func (s *Server) handleWatchCoreV1PersistentVolumeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PersistentVolumeList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PersistentVolumeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PersistentVolumeList",
			ID:   "watchCoreV1PersistentVolumeList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1PersistentVolumeList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1PersistentVolumeListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PersistentVolumeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1PersistentVolumeList",
			OperationID:   "watchCoreV1PersistentVolumeList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PersistentVolumeListParams
			Response = WatchCoreV1PersistentVolumeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PersistentVolumeListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1PersistentVolumeList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PersistentVolumeList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PersistentVolumeListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1PodListForAllNamespacesRequest handles watchCoreV1PodListForAllNamespaces operation.
//
// GET /api/v1/watch/pods
func (s *Server) handleWatchCoreV1PodListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PodListForAllNamespaces",
			ID:   "watchCoreV1PodListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1PodListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1PodListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PodListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1PodListForAllNamespaces",
			OperationID:   "watchCoreV1PodListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PodListForAllNamespacesParams
			Response = WatchCoreV1PodListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PodListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1PodListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PodListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PodListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1PodTemplateListForAllNamespacesRequest handles watchCoreV1PodTemplateListForAllNamespaces operation.
//
// GET /api/v1/watch/podtemplates
func (s *Server) handleWatchCoreV1PodTemplateListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1PodTemplateListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1PodTemplateListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1PodTemplateListForAllNamespaces",
			ID:   "watchCoreV1PodTemplateListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1PodTemplateListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1PodTemplateListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1PodTemplateListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1PodTemplateListForAllNamespaces",
			OperationID:   "watchCoreV1PodTemplateListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1PodTemplateListForAllNamespacesParams
			Response = WatchCoreV1PodTemplateListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1PodTemplateListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1PodTemplateListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1PodTemplateListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1PodTemplateListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1ReplicationControllerListForAllNamespacesRequest handles watchCoreV1ReplicationControllerListForAllNamespaces operation.
//
// GET /api/v1/watch/replicationcontrollers
func (s *Server) handleWatchCoreV1ReplicationControllerListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ReplicationControllerListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ReplicationControllerListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ReplicationControllerListForAllNamespaces",
			ID:   "watchCoreV1ReplicationControllerListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1ReplicationControllerListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1ReplicationControllerListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ReplicationControllerListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1ReplicationControllerListForAllNamespaces",
			OperationID:   "watchCoreV1ReplicationControllerListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ReplicationControllerListForAllNamespacesParams
			Response = WatchCoreV1ReplicationControllerListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ReplicationControllerListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1ReplicationControllerListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ReplicationControllerListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ReplicationControllerListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1ResourceQuotaListForAllNamespacesRequest handles watchCoreV1ResourceQuotaListForAllNamespaces operation.
//
// GET /api/v1/watch/resourcequotas
func (s *Server) handleWatchCoreV1ResourceQuotaListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ResourceQuotaListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ResourceQuotaListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ResourceQuotaListForAllNamespaces",
			ID:   "watchCoreV1ResourceQuotaListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1ResourceQuotaListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1ResourceQuotaListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ResourceQuotaListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1ResourceQuotaListForAllNamespaces",
			OperationID:   "watchCoreV1ResourceQuotaListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ResourceQuotaListForAllNamespacesParams
			Response = WatchCoreV1ResourceQuotaListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ResourceQuotaListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1ResourceQuotaListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ResourceQuotaListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ResourceQuotaListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1SecretListForAllNamespacesRequest handles watchCoreV1SecretListForAllNamespaces operation.
//
// GET /api/v1/watch/secrets
func (s *Server) handleWatchCoreV1SecretListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1SecretListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1SecretListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1SecretListForAllNamespaces",
			ID:   "watchCoreV1SecretListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1SecretListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1SecretListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1SecretListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1SecretListForAllNamespaces",
			OperationID:   "watchCoreV1SecretListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1SecretListForAllNamespacesParams
			Response = WatchCoreV1SecretListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1SecretListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1SecretListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1SecretListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1SecretListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1ServiceAccountListForAllNamespacesRequest handles watchCoreV1ServiceAccountListForAllNamespaces operation.
//
// GET /api/v1/watch/serviceaccounts
func (s *Server) handleWatchCoreV1ServiceAccountListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceAccountListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceAccountListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ServiceAccountListForAllNamespaces",
			ID:   "watchCoreV1ServiceAccountListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1ServiceAccountListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1ServiceAccountListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ServiceAccountListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1ServiceAccountListForAllNamespaces",
			OperationID:   "watchCoreV1ServiceAccountListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ServiceAccountListForAllNamespacesParams
			Response = WatchCoreV1ServiceAccountListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ServiceAccountListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1ServiceAccountListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ServiceAccountListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ServiceAccountListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchCoreV1ServiceListForAllNamespacesRequest handles watchCoreV1ServiceListForAllNamespaces operation.
//
// GET /api/v1/watch/services
func (s *Server) handleWatchCoreV1ServiceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchCoreV1ServiceListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchCoreV1ServiceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchCoreV1ServiceListForAllNamespaces",
			ID:   "watchCoreV1ServiceListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchCoreV1ServiceListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchCoreV1ServiceListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchCoreV1ServiceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchCoreV1ServiceListForAllNamespaces",
			OperationID:   "watchCoreV1ServiceListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchCoreV1ServiceListForAllNamespacesParams
			Response = WatchCoreV1ServiceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchCoreV1ServiceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchCoreV1ServiceListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchCoreV1ServiceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchCoreV1ServiceListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1EndpointSliceListForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1EndpointSliceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1EndpointSliceListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
			ID:   "watchDiscoveryV1EndpointSliceListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1EndpointSliceListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1EndpointSliceListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1EndpointSliceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1EndpointSliceListForAllNamespaces",
			OperationID:   "watchDiscoveryV1EndpointSliceListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1EndpointSliceListForAllNamespacesParams
			Response = WatchDiscoveryV1EndpointSliceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1EndpointSliceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1EndpointSliceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1NamespacedEndpointSliceRequest handles watchDiscoveryV1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1NamespacedEndpointSlice",
			ID:   "watchDiscoveryV1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1NamespacedEndpointSlice",
			OperationID:   "watchDiscoveryV1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1NamespacedEndpointSliceParams
			Response = WatchDiscoveryV1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1NamespacedEndpointSliceListRequest handles watchDiscoveryV1NamespacedEndpointSliceList operation.
//
// GET /apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1NamespacedEndpointSliceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1NamespacedEndpointSliceList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1NamespacedEndpointSliceList",
			ID:   "watchDiscoveryV1NamespacedEndpointSliceList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1NamespacedEndpointSliceList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1NamespacedEndpointSliceListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1NamespacedEndpointSliceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1NamespacedEndpointSliceList",
			OperationID:   "watchDiscoveryV1NamespacedEndpointSliceList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1NamespacedEndpointSliceListParams
			Response = WatchDiscoveryV1NamespacedEndpointSliceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1NamespacedEndpointSliceListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1NamespacedEndpointSliceList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1NamespacedEndpointSliceList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest handles watchDiscoveryV1beta1EndpointSliceListForAllNamespaces operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1EndpointSliceListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			ID:   "watchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			OperationID:   "watchDiscoveryV1beta1EndpointSliceListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams
			Response = WatchDiscoveryV1beta1EndpointSliceListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1EndpointSliceListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1EndpointSliceListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest handles watchDiscoveryV1beta1NamespacedEndpointSlice operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices/{name}
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSlice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSlice",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1NamespacedEndpointSlice",
			ID:   "watchDiscoveryV1beta1NamespacedEndpointSlice",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1beta1NamespacedEndpointSlice", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1NamespacedEndpointSliceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1beta1NamespacedEndpointSlice",
			OperationID:   "watchDiscoveryV1beta1NamespacedEndpointSlice",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1NamespacedEndpointSliceParams
			Response = WatchDiscoveryV1beta1NamespacedEndpointSliceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1NamespacedEndpointSliceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSlice(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest handles watchDiscoveryV1beta1NamespacedEndpointSliceList operation.
//
// GET /apis/discovery.k8s.io/v1beta1/watch/namespaces/{namespace}/endpointslices
func (s *Server) handleWatchDiscoveryV1beta1NamespacedEndpointSliceListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchDiscoveryV1beta1NamespacedEndpointSliceList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
			ID:   "watchDiscoveryV1beta1NamespacedEndpointSliceList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchDiscoveryV1beta1NamespacedEndpointSliceList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchDiscoveryV1beta1NamespacedEndpointSliceListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchDiscoveryV1beta1NamespacedEndpointSliceListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchDiscoveryV1beta1NamespacedEndpointSliceList",
			OperationID:   "watchDiscoveryV1beta1NamespacedEndpointSliceList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchDiscoveryV1beta1NamespacedEndpointSliceListParams
			Response = WatchDiscoveryV1beta1NamespacedEndpointSliceListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchDiscoveryV1beta1NamespacedEndpointSliceListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchDiscoveryV1beta1NamespacedEndpointSliceList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchDiscoveryV1beta1NamespacedEndpointSliceList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchDiscoveryV1beta1NamespacedEndpointSliceListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1EventListForAllNamespacesRequest handles watchEventsV1EventListForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1/watch/events
func (s *Server) handleWatchEventsV1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1EventListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1EventListForAllNamespaces",
			ID:   "watchEventsV1EventListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1EventListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1EventListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1EventListForAllNamespaces",
			OperationID:   "watchEventsV1EventListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1EventListForAllNamespacesParams
			Response = WatchEventsV1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1EventListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1EventListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1NamespacedEventRequest handles watchEventsV1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1NamespacedEvent",
			ID:   "watchEventsV1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1NamespacedEvent",
			OperationID:   "watchEventsV1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1NamespacedEventParams
			Response = WatchEventsV1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1NamespacedEventListRequest handles watchEventsV1NamespacedEventList operation.
//
// GET /apis/events.k8s.io/v1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1NamespacedEventList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1NamespacedEventList",
			ID:   "watchEventsV1NamespacedEventList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1NamespacedEventList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1NamespacedEventListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1NamespacedEventList",
			OperationID:   "watchEventsV1NamespacedEventList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1NamespacedEventListParams
			Response = WatchEventsV1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1NamespacedEventList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1NamespacedEventList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1NamespacedEventListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1beta1EventListForAllNamespacesRequest handles watchEventsV1beta1EventListForAllNamespaces operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/events
func (s *Server) handleWatchEventsV1beta1EventListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1EventListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1EventListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1EventListForAllNamespaces",
			ID:   "watchEventsV1beta1EventListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1beta1EventListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1beta1EventListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1EventListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1beta1EventListForAllNamespaces",
			OperationID:   "watchEventsV1beta1EventListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1EventListForAllNamespacesParams
			Response = WatchEventsV1beta1EventListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1EventListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1beta1EventListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1EventListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1EventListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1beta1NamespacedEventRequest handles watchEventsV1beta1NamespacedEvent operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}
func (s *Server) handleWatchEventsV1beta1NamespacedEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEvent"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1NamespacedEvent",
			ID:   "watchEventsV1beta1NamespacedEvent",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1beta1NamespacedEvent", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1beta1NamespacedEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1NamespacedEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1beta1NamespacedEvent",
			OperationID:   "watchEventsV1beta1NamespacedEvent",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1NamespacedEventParams
			Response = WatchEventsV1beta1NamespacedEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1NamespacedEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1beta1NamespacedEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1NamespacedEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchEventsV1beta1NamespacedEventListRequest handles watchEventsV1beta1NamespacedEventList operation.
//
// GET /apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events
func (s *Server) handleWatchEventsV1beta1NamespacedEventListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchEventsV1beta1NamespacedEventList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchEventsV1beta1NamespacedEventList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchEventsV1beta1NamespacedEventList",
			ID:   "watchEventsV1beta1NamespacedEventList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchEventsV1beta1NamespacedEventList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchEventsV1beta1NamespacedEventListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchEventsV1beta1NamespacedEventListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchEventsV1beta1NamespacedEventList",
			OperationID:   "watchEventsV1beta1NamespacedEventList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchEventsV1beta1NamespacedEventListParams
			Response = WatchEventsV1beta1NamespacedEventListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchEventsV1beta1NamespacedEventListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchEventsV1beta1NamespacedEventList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchEventsV1beta1NamespacedEventList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchEventsV1beta1NamespacedEventListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest handles watchFlowcontrolApiserverV1beta1FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1FlowSchema",
			ID:   "watchFlowcontrolApiserverV1beta1FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta1FlowSchema",
			OperationID:   "watchFlowcontrolApiserverV1beta1FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1FlowSchemaParams
			Response = WatchFlowcontrolApiserverV1beta1FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta1FlowSchemaList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta1FlowSchemaListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1FlowSchemaList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
			ID:   "watchFlowcontrolApiserverV1beta1FlowSchemaList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1FlowSchemaList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1FlowSchemaListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1FlowSchemaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta1FlowSchemaList",
			OperationID:   "watchFlowcontrolApiserverV1beta1FlowSchemaList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1FlowSchemaListParams
			Response = WatchFlowcontrolApiserverV1beta1FlowSchemaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1FlowSchemaListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1FlowSchemaList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1FlowSchemaListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			ID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			OperationID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams
			Response = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta1/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			ID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			OperationID:   "watchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams
			Response = WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest handles watchFlowcontrolApiserverV1beta2FlowSchema operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchema"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchema",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2FlowSchema",
			ID:   "watchFlowcontrolApiserverV1beta2FlowSchema",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2FlowSchema", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2FlowSchemaRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta2FlowSchema",
			OperationID:   "watchFlowcontrolApiserverV1beta2FlowSchema",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2FlowSchemaParams
			Response = WatchFlowcontrolApiserverV1beta2FlowSchemaRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2FlowSchemaParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchema(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest handles watchFlowcontrolApiserverV1beta2FlowSchemaList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas
func (s *Server) handleWatchFlowcontrolApiserverV1beta2FlowSchemaListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2FlowSchemaList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
			ID:   "watchFlowcontrolApiserverV1beta2FlowSchemaList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2FlowSchemaList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2FlowSchemaListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2FlowSchemaListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta2FlowSchemaList",
			OperationID:   "watchFlowcontrolApiserverV1beta2FlowSchemaList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2FlowSchemaListParams
			Response = WatchFlowcontrolApiserverV1beta2FlowSchemaListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2FlowSchemaListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2FlowSchemaList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2FlowSchemaListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			ID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			OperationID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams
			Response = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest handles watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList operation.
//
// GET /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations
func (s *Server) handleWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			ID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			OperationID:   "watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams
			Response = WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchInternalApiserverV1alpha1StorageVersionRequest handles watchInternalApiserverV1alpha1StorageVersion operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchInternalApiserverV1alpha1StorageVersion",
			ID:   "watchInternalApiserverV1alpha1StorageVersion",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchInternalApiserverV1alpha1StorageVersion", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchInternalApiserverV1alpha1StorageVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchInternalApiserverV1alpha1StorageVersion",
			OperationID:   "watchInternalApiserverV1alpha1StorageVersion",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchInternalApiserverV1alpha1StorageVersionParams
			Response = WatchInternalApiserverV1alpha1StorageVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchInternalApiserverV1alpha1StorageVersionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchInternalApiserverV1alpha1StorageVersion(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchInternalApiserverV1alpha1StorageVersion(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchInternalApiserverV1alpha1StorageVersionListRequest handles watchInternalApiserverV1alpha1StorageVersionList operation.
//
// GET /apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions
func (s *Server) handleWatchInternalApiserverV1alpha1StorageVersionListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchInternalApiserverV1alpha1StorageVersionList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchInternalApiserverV1alpha1StorageVersionList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchInternalApiserverV1alpha1StorageVersionList",
			ID:   "watchInternalApiserverV1alpha1StorageVersionList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchInternalApiserverV1alpha1StorageVersionList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchInternalApiserverV1alpha1StorageVersionListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchInternalApiserverV1alpha1StorageVersionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchInternalApiserverV1alpha1StorageVersionList",
			OperationID:   "watchInternalApiserverV1alpha1StorageVersionList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchInternalApiserverV1alpha1StorageVersionListParams
			Response = WatchInternalApiserverV1alpha1StorageVersionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchInternalApiserverV1alpha1StorageVersionListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchInternalApiserverV1alpha1StorageVersionList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchInternalApiserverV1alpha1StorageVersionList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchInternalApiserverV1alpha1StorageVersionListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1IngressClassRequest handles watchNetworkingV1IngressClass operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses/{name}
func (s *Server) handleWatchNetworkingV1IngressClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressClass",
			ID:   "watchNetworkingV1IngressClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1IngressClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1IngressClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1IngressClass",
			OperationID:   "watchNetworkingV1IngressClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressClassParams
			Response = WatchNetworkingV1IngressClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1IngressClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1IngressClassListRequest handles watchNetworkingV1IngressClassList operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingressclasses
func (s *Server) handleWatchNetworkingV1IngressClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressClassList",
			ID:   "watchNetworkingV1IngressClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1IngressClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1IngressClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1IngressClassList",
			OperationID:   "watchNetworkingV1IngressClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressClassListParams
			Response = WatchNetworkingV1IngressClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1IngressClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1IngressListForAllNamespacesRequest handles watchNetworkingV1IngressListForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/watch/ingresses
func (s *Server) handleWatchNetworkingV1IngressListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1IngressListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1IngressListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1IngressListForAllNamespaces",
			ID:   "watchNetworkingV1IngressListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1IngressListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1IngressListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1IngressListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1IngressListForAllNamespaces",
			OperationID:   "watchNetworkingV1IngressListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1IngressListForAllNamespacesParams
			Response = WatchNetworkingV1IngressListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1IngressListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1IngressListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1IngressListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1IngressListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1NamespacedIngressRequest handles watchNetworkingV1NamespacedIngress operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}
func (s *Server) handleWatchNetworkingV1NamespacedIngressRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngress"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngress",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedIngress",
			ID:   "watchNetworkingV1NamespacedIngress",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedIngress", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1NamespacedIngressParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedIngressRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1NamespacedIngress",
			OperationID:   "watchNetworkingV1NamespacedIngress",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedIngressParams
			Response = WatchNetworkingV1NamespacedIngressRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedIngressParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1NamespacedIngress(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedIngress(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1NamespacedIngressListRequest handles watchNetworkingV1NamespacedIngressList operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses
func (s *Server) handleWatchNetworkingV1NamespacedIngressListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedIngressList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedIngressList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedIngressList",
			ID:   "watchNetworkingV1NamespacedIngressList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedIngressList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1NamespacedIngressListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedIngressListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1NamespacedIngressList",
			OperationID:   "watchNetworkingV1NamespacedIngressList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedIngressListParams
			Response = WatchNetworkingV1NamespacedIngressListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedIngressListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1NamespacedIngressList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedIngressList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedIngressListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1NamespacedNetworkPolicyRequest handles watchNetworkingV1NamespacedNetworkPolicy operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedNetworkPolicy",
			ID:   "watchNetworkingV1NamespacedNetworkPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedNetworkPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedNetworkPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1NamespacedNetworkPolicy",
			OperationID:   "watchNetworkingV1NamespacedNetworkPolicy",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedNetworkPolicyParams
			Response = WatchNetworkingV1NamespacedNetworkPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedNetworkPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1NamespacedNetworkPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1NamespacedNetworkPolicyListRequest handles watchNetworkingV1NamespacedNetworkPolicyList operation.
//
// GET /apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies
func (s *Server) handleWatchNetworkingV1NamespacedNetworkPolicyListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NamespacedNetworkPolicyList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NamespacedNetworkPolicyList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NamespacedNetworkPolicyList",
			ID:   "watchNetworkingV1NamespacedNetworkPolicyList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1NamespacedNetworkPolicyList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1NamespacedNetworkPolicyListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NamespacedNetworkPolicyListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1NamespacedNetworkPolicyList",
			OperationID:   "watchNetworkingV1NamespacedNetworkPolicyList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NamespacedNetworkPolicyListParams
			Response = WatchNetworkingV1NamespacedNetworkPolicyListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NamespacedNetworkPolicyListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1NamespacedNetworkPolicyList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NamespacedNetworkPolicyList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NamespacedNetworkPolicyListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest handles watchNetworkingV1NetworkPolicyListForAllNamespaces operation.
//
// GET /apis/networking.k8s.io/v1/watch/networkpolicies
func (s *Server) handleWatchNetworkingV1NetworkPolicyListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNetworkingV1NetworkPolicyListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
			ID:   "watchNetworkingV1NetworkPolicyListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNetworkingV1NetworkPolicyListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNetworkingV1NetworkPolicyListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNetworkingV1NetworkPolicyListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNetworkingV1NetworkPolicyListForAllNamespaces",
			OperationID:   "watchNetworkingV1NetworkPolicyListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNetworkingV1NetworkPolicyListForAllNamespacesParams
			Response = WatchNetworkingV1NetworkPolicyListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNetworkingV1NetworkPolicyListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNetworkingV1NetworkPolicyListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNetworkingV1NetworkPolicyListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1RuntimeClassRequest handles watchNodeV1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1RuntimeClass",
			ID:   "watchNodeV1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1RuntimeClass",
			OperationID:   "watchNodeV1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1RuntimeClassParams
			Response = WatchNodeV1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1RuntimeClassListRequest handles watchNodeV1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1RuntimeClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1RuntimeClassList",
			ID:   "watchNodeV1RuntimeClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1RuntimeClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1RuntimeClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1RuntimeClassList",
			OperationID:   "watchNodeV1RuntimeClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1RuntimeClassListParams
			Response = WatchNodeV1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1RuntimeClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1RuntimeClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1RuntimeClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1alpha1RuntimeClassRequest handles watchNodeV1alpha1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1alpha1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1alpha1RuntimeClass",
			ID:   "watchNodeV1alpha1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1alpha1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1alpha1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1alpha1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1alpha1RuntimeClass",
			OperationID:   "watchNodeV1alpha1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1alpha1RuntimeClassParams
			Response = WatchNodeV1alpha1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1alpha1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1alpha1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1alpha1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1alpha1RuntimeClassListRequest handles watchNodeV1alpha1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1alpha1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1alpha1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1alpha1RuntimeClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1alpha1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1alpha1RuntimeClassList",
			ID:   "watchNodeV1alpha1RuntimeClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1alpha1RuntimeClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1alpha1RuntimeClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1alpha1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1alpha1RuntimeClassList",
			OperationID:   "watchNodeV1alpha1RuntimeClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1alpha1RuntimeClassListParams
			Response = WatchNodeV1alpha1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1alpha1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1alpha1RuntimeClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1alpha1RuntimeClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1alpha1RuntimeClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1beta1RuntimeClassRequest handles watchNodeV1beta1RuntimeClass operation.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses/{name}
func (s *Server) handleWatchNodeV1beta1RuntimeClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1beta1RuntimeClass",
			ID:   "watchNodeV1beta1RuntimeClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1beta1RuntimeClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1beta1RuntimeClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1beta1RuntimeClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1beta1RuntimeClass",
			OperationID:   "watchNodeV1beta1RuntimeClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1beta1RuntimeClassParams
			Response = WatchNodeV1beta1RuntimeClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1beta1RuntimeClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1beta1RuntimeClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1beta1RuntimeClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchNodeV1beta1RuntimeClassListRequest handles watchNodeV1beta1RuntimeClassList operation.
//
// GET /apis/node.k8s.io/v1beta1/watch/runtimeclasses
func (s *Server) handleWatchNodeV1beta1RuntimeClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchNodeV1beta1RuntimeClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchNodeV1beta1RuntimeClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchNodeV1beta1RuntimeClassList",
			ID:   "watchNodeV1beta1RuntimeClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchNodeV1beta1RuntimeClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchNodeV1beta1RuntimeClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchNodeV1beta1RuntimeClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchNodeV1beta1RuntimeClassList",
			OperationID:   "watchNodeV1beta1RuntimeClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchNodeV1beta1RuntimeClassListParams
			Response = WatchNodeV1beta1RuntimeClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchNodeV1beta1RuntimeClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchNodeV1beta1RuntimeClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchNodeV1beta1RuntimeClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchNodeV1beta1RuntimeClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1NamespacedPodDisruptionBudget",
			ID:   "watchPolicyV1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1NamespacedPodDisruptionBudget",
			OperationID:   "watchPolicyV1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1NamespacedPodDisruptionBudgetParams
			Response = WatchPolicyV1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1NamespacedPodDisruptionBudgetList operation.
//
// GET /apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1NamespacedPodDisruptionBudgetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1NamespacedPodDisruptionBudgetList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1NamespacedPodDisruptionBudgetList",
			ID:   "watchPolicyV1NamespacedPodDisruptionBudgetList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1NamespacedPodDisruptionBudgetList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1NamespacedPodDisruptionBudgetListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1NamespacedPodDisruptionBudgetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1NamespacedPodDisruptionBudgetList",
			OperationID:   "watchPolicyV1NamespacedPodDisruptionBudgetList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1NamespacedPodDisruptionBudgetListParams
			Response = WatchPolicyV1NamespacedPodDisruptionBudgetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1NamespacedPodDisruptionBudgetListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1NamespacedPodDisruptionBudgetList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1NamespacedPodDisruptionBudgetList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1PodDisruptionBudgetListForAllNamespaces operation.
//
// GET /apis/policy/v1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1PodDisruptionBudgetListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			ID:   "watchPolicyV1PodDisruptionBudgetListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			OperationID:   "watchPolicyV1PodDisruptionBudgetListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams
			Response = WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1PodDisruptionBudgetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudget operation.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudget"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
			ID:   "watchPolicyV1beta1NamespacedPodDisruptionBudget",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1beta1NamespacedPodDisruptionBudget", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1NamespacedPodDisruptionBudgetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1beta1NamespacedPodDisruptionBudget",
			OperationID:   "watchPolicyV1beta1NamespacedPodDisruptionBudget",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1NamespacedPodDisruptionBudgetParams
			Response = WatchPolicyV1beta1NamespacedPodDisruptionBudgetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudget(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest handles watchPolicyV1beta1NamespacedPodDisruptionBudgetList operation.
//
// GET /apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1NamespacedPodDisruptionBudgetListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1NamespacedPodDisruptionBudgetList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			ID:   "watchPolicyV1beta1NamespacedPodDisruptionBudgetList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1NamespacedPodDisruptionBudgetListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			OperationID:   "watchPolicyV1beta1NamespacedPodDisruptionBudgetList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams
			Response = WatchPolicyV1beta1NamespacedPodDisruptionBudgetListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1NamespacedPodDisruptionBudgetListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudgetList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1NamespacedPodDisruptionBudgetList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1NamespacedPodDisruptionBudgetListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest handles watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces operation.
//
// GET /apis/policy/v1beta1/watch/poddisruptionbudgets
func (s *Server) handleWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			ID:   "watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			OperationID:   "watchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams
			Response = WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodDisruptionBudgetListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodDisruptionBudgetListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1beta1PodSecurityPolicyRequest handles watchPolicyV1beta1PodSecurityPolicy operation.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies/{name}
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodSecurityPolicy",
			ID:   "watchPolicyV1beta1PodSecurityPolicy",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1beta1PodSecurityPolicy", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodSecurityPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1beta1PodSecurityPolicy",
			OperationID:   "watchPolicyV1beta1PodSecurityPolicy",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodSecurityPolicyParams
			Response = WatchPolicyV1beta1PodSecurityPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodSecurityPolicyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1beta1PodSecurityPolicy(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodSecurityPolicy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchPolicyV1beta1PodSecurityPolicyListRequest handles watchPolicyV1beta1PodSecurityPolicyList operation.
//
// GET /apis/policy/v1beta1/watch/podsecuritypolicies
func (s *Server) handleWatchPolicyV1beta1PodSecurityPolicyListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchPolicyV1beta1PodSecurityPolicyList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchPolicyV1beta1PodSecurityPolicyList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchPolicyV1beta1PodSecurityPolicyList",
			ID:   "watchPolicyV1beta1PodSecurityPolicyList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchPolicyV1beta1PodSecurityPolicyList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchPolicyV1beta1PodSecurityPolicyListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchPolicyV1beta1PodSecurityPolicyListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchPolicyV1beta1PodSecurityPolicyList",
			OperationID:   "watchPolicyV1beta1PodSecurityPolicyList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchPolicyV1beta1PodSecurityPolicyListParams
			Response = WatchPolicyV1beta1PodSecurityPolicyListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchPolicyV1beta1PodSecurityPolicyListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchPolicyV1beta1PodSecurityPolicyList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchPolicyV1beta1PodSecurityPolicyList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchPolicyV1beta1PodSecurityPolicyListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1ClusterRoleRequest handles watchRbacAuthorizationV1ClusterRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRole",
			ID:   "watchRbacAuthorizationV1ClusterRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1ClusterRole",
			OperationID:   "watchRbacAuthorizationV1ClusterRole",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleParams
			Response = WatchRbacAuthorizationV1ClusterRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1ClusterRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1ClusterRoleBindingRequest handles watchRbacAuthorizationV1ClusterRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleBinding",
			ID:   "watchRbacAuthorizationV1ClusterRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1ClusterRoleBinding",
			OperationID:   "watchRbacAuthorizationV1ClusterRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleBindingParams
			Response = WatchRbacAuthorizationV1ClusterRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1ClusterRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1ClusterRoleBindingListRequest handles watchRbacAuthorizationV1ClusterRoleBindingList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleBindingListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleBindingList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleBindingList",
			ID:   "watchRbacAuthorizationV1ClusterRoleBindingList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleBindingList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleBindingListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleBindingListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1ClusterRoleBindingList",
			OperationID:   "watchRbacAuthorizationV1ClusterRoleBindingList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleBindingListParams
			Response = WatchRbacAuthorizationV1ClusterRoleBindingListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleBindingListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1ClusterRoleBindingList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleBindingList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleBindingListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1ClusterRoleListRequest handles watchRbacAuthorizationV1ClusterRoleList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/clusterroles
func (s *Server) handleWatchRbacAuthorizationV1ClusterRoleListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1ClusterRoleList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1ClusterRoleList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1ClusterRoleList",
			ID:   "watchRbacAuthorizationV1ClusterRoleList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1ClusterRoleList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1ClusterRoleListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1ClusterRoleListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1ClusterRoleList",
			OperationID:   "watchRbacAuthorizationV1ClusterRoleList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1ClusterRoleListParams
			Response = WatchRbacAuthorizationV1ClusterRoleListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1ClusterRoleListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1ClusterRoleList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1ClusterRoleList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1ClusterRoleListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1NamespacedRoleRequest handles watchRbacAuthorizationV1NamespacedRole operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRole"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRole",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRole",
			ID:   "watchRbacAuthorizationV1NamespacedRole",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRole", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1NamespacedRole",
			OperationID:   "watchRbacAuthorizationV1NamespacedRole",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleParams
			Response = WatchRbacAuthorizationV1NamespacedRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1NamespacedRole(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRole(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1NamespacedRoleBindingRequest handles watchRbacAuthorizationV1NamespacedRoleBinding operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBinding"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBinding",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleBinding",
			ID:   "watchRbacAuthorizationV1NamespacedRoleBinding",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleBinding", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleBindingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1NamespacedRoleBinding",
			OperationID:   "watchRbacAuthorizationV1NamespacedRoleBinding",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleBindingParams
			Response = WatchRbacAuthorizationV1NamespacedRoleBindingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleBindingParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBinding(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest handles watchRbacAuthorizationV1NamespacedRoleBindingList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleBindingListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleBindingList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleBindingList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleBindingList",
			ID:   "watchRbacAuthorizationV1NamespacedRoleBindingList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleBindingList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleBindingListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleBindingListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1NamespacedRoleBindingList",
			OperationID:   "watchRbacAuthorizationV1NamespacedRoleBindingList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleBindingListParams
			Response = WatchRbacAuthorizationV1NamespacedRoleBindingListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleBindingListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1NamespacedRoleBindingList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleBindingList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleBindingListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1NamespacedRoleListRequest handles watchRbacAuthorizationV1NamespacedRoleList operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles
func (s *Server) handleWatchRbacAuthorizationV1NamespacedRoleListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1NamespacedRoleList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1NamespacedRoleList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1NamespacedRoleList",
			ID:   "watchRbacAuthorizationV1NamespacedRoleList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1NamespacedRoleList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1NamespacedRoleListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1NamespacedRoleListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1NamespacedRoleList",
			OperationID:   "watchRbacAuthorizationV1NamespacedRoleList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1NamespacedRoleListParams
			Response = WatchRbacAuthorizationV1NamespacedRoleListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1NamespacedRoleListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1NamespacedRoleList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1NamespacedRoleList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1NamespacedRoleListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleBindingListForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/rolebindings
func (s *Server) handleWatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleBindingListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			ID:   "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			OperationID:   "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams
			Response = WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1RoleBindingListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1RoleBindingListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleBindingListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest handles watchRbacAuthorizationV1RoleListForAllNamespaces operation.
//
// GET /apis/rbac.authorization.k8s.io/v1/watch/roles
func (s *Server) handleWatchRbacAuthorizationV1RoleListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchRbacAuthorizationV1RoleListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchRbacAuthorizationV1RoleListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchRbacAuthorizationV1RoleListForAllNamespaces",
			ID:   "watchRbacAuthorizationV1RoleListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchRbacAuthorizationV1RoleListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchRbacAuthorizationV1RoleListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchRbacAuthorizationV1RoleListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchRbacAuthorizationV1RoleListForAllNamespaces",
			OperationID:   "watchRbacAuthorizationV1RoleListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchRbacAuthorizationV1RoleListForAllNamespacesParams
			Response = WatchRbacAuthorizationV1RoleListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchRbacAuthorizationV1RoleListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchRbacAuthorizationV1RoleListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchRbacAuthorizationV1RoleListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchSchedulingV1PriorityClassRequest handles watchSchedulingV1PriorityClass operation.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}
func (s *Server) handleWatchSchedulingV1PriorityClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchSchedulingV1PriorityClass",
			ID:   "watchSchedulingV1PriorityClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchSchedulingV1PriorityClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchSchedulingV1PriorityClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchSchedulingV1PriorityClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchSchedulingV1PriorityClass",
			OperationID:   "watchSchedulingV1PriorityClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchSchedulingV1PriorityClassParams
			Response = WatchSchedulingV1PriorityClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchSchedulingV1PriorityClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchSchedulingV1PriorityClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchSchedulingV1PriorityClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchSchedulingV1PriorityClassListRequest handles watchSchedulingV1PriorityClassList operation.
//
// GET /apis/scheduling.k8s.io/v1/watch/priorityclasses
func (s *Server) handleWatchSchedulingV1PriorityClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchSchedulingV1PriorityClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchSchedulingV1PriorityClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchSchedulingV1PriorityClassList",
			ID:   "watchSchedulingV1PriorityClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchSchedulingV1PriorityClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchSchedulingV1PriorityClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchSchedulingV1PriorityClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchSchedulingV1PriorityClassList",
			OperationID:   "watchSchedulingV1PriorityClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchSchedulingV1PriorityClassListParams
			Response = WatchSchedulingV1PriorityClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchSchedulingV1PriorityClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchSchedulingV1PriorityClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchSchedulingV1PriorityClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchSchedulingV1PriorityClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1CSIDriverRequest handles watchStorageV1CSIDriver operation.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers/{name}
func (s *Server) handleWatchStorageV1CSIDriverRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriver"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriver",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSIDriver",
			ID:   "watchStorageV1CSIDriver",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1CSIDriver", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1CSIDriverParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSIDriverRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1CSIDriver",
			OperationID:   "watchStorageV1CSIDriver",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSIDriverParams
			Response = WatchStorageV1CSIDriverRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSIDriverParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1CSIDriver(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSIDriver(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1CSIDriverListRequest handles watchStorageV1CSIDriverList operation.
//
// GET /apis/storage.k8s.io/v1/watch/csidrivers
func (s *Server) handleWatchStorageV1CSIDriverListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSIDriverList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSIDriverList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSIDriverList",
			ID:   "watchStorageV1CSIDriverList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1CSIDriverList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1CSIDriverListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSIDriverListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1CSIDriverList",
			OperationID:   "watchStorageV1CSIDriverList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSIDriverListParams
			Response = WatchStorageV1CSIDriverListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSIDriverListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1CSIDriverList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSIDriverList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSIDriverListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1CSINodeRequest handles watchStorageV1CSINode operation.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes/{name}
func (s *Server) handleWatchStorageV1CSINodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINode"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSINode",
			ID:   "watchStorageV1CSINode",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1CSINode", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1CSINodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSINodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1CSINode",
			OperationID:   "watchStorageV1CSINode",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSINodeParams
			Response = WatchStorageV1CSINodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSINodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1CSINode(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSINode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1CSINodeListRequest handles watchStorageV1CSINodeList operation.
//
// GET /apis/storage.k8s.io/v1/watch/csinodes
func (s *Server) handleWatchStorageV1CSINodeListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1CSINodeList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1CSINodeList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1CSINodeList",
			ID:   "watchStorageV1CSINodeList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1CSINodeList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1CSINodeListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1CSINodeListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1CSINodeList",
			OperationID:   "watchStorageV1CSINodeList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1CSINodeListParams
			Response = WatchStorageV1CSINodeListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1CSINodeListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1CSINodeList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1CSINodeList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1CSINodeListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1StorageClassRequest handles watchStorageV1StorageClass operation.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses/{name}
func (s *Server) handleWatchStorageV1StorageClassRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClass"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClass",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1StorageClass",
			ID:   "watchStorageV1StorageClass",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1StorageClass", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1StorageClassParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1StorageClassRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1StorageClass",
			OperationID:   "watchStorageV1StorageClass",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1StorageClassParams
			Response = WatchStorageV1StorageClassRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1StorageClassParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1StorageClass(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1StorageClass(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1StorageClassListRequest handles watchStorageV1StorageClassList operation.
//
// GET /apis/storage.k8s.io/v1/watch/storageclasses
func (s *Server) handleWatchStorageV1StorageClassListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1StorageClassList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1StorageClassList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1StorageClassList",
			ID:   "watchStorageV1StorageClassList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1StorageClassList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1StorageClassListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1StorageClassListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1StorageClassList",
			OperationID:   "watchStorageV1StorageClassList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1StorageClassListParams
			Response = WatchStorageV1StorageClassListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1StorageClassListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1StorageClassList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1StorageClassList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1StorageClassListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1VolumeAttachmentRequest handles watchStorageV1VolumeAttachment operation.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments/{name}
func (s *Server) handleWatchStorageV1VolumeAttachmentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1VolumeAttachment",
			ID:   "watchStorageV1VolumeAttachment",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1VolumeAttachment", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1VolumeAttachmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1VolumeAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1VolumeAttachment",
			OperationID:   "watchStorageV1VolumeAttachment",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1VolumeAttachmentParams
			Response = WatchStorageV1VolumeAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1VolumeAttachmentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1VolumeAttachment(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1VolumeAttachment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1VolumeAttachmentListRequest handles watchStorageV1VolumeAttachmentList operation.
//
// GET /apis/storage.k8s.io/v1/watch/volumeattachments
func (s *Server) handleWatchStorageV1VolumeAttachmentListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1VolumeAttachmentList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1VolumeAttachmentList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1VolumeAttachmentList",
			ID:   "watchStorageV1VolumeAttachmentList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1VolumeAttachmentList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1VolumeAttachmentListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1VolumeAttachmentListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1VolumeAttachmentList",
			OperationID:   "watchStorageV1VolumeAttachmentList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1VolumeAttachmentListParams
			Response = WatchStorageV1VolumeAttachmentListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1VolumeAttachmentListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1VolumeAttachmentList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1VolumeAttachmentList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1VolumeAttachmentListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			ID:   "watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			OperationID:   "watchStorageV1alpha1CSIStorageCapacityListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams
			Response = WatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1CSIStorageCapacityListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
			ID:   "watchStorageV1alpha1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1alpha1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1alpha1NamespacedCSIStorageCapacity",
			OperationID:   "watchStorageV1alpha1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1NamespacedCSIStorageCapacityParams
			Response = WatchStorageV1alpha1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest handles watchStorageV1alpha1NamespacedCSIStorageCapacityList operation.
//
// GET /apis/storage.k8s.io/v1alpha1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1alpha1NamespacedCSIStorageCapacityListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1alpha1NamespacedCSIStorageCapacityList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
			ID:   "watchStorageV1alpha1NamespacedCSIStorageCapacityList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1alpha1NamespacedCSIStorageCapacityList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1alpha1NamespacedCSIStorageCapacityListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1alpha1NamespacedCSIStorageCapacityList",
			OperationID:   "watchStorageV1alpha1NamespacedCSIStorageCapacityList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1alpha1NamespacedCSIStorageCapacityListParams
			Response = WatchStorageV1alpha1NamespacedCSIStorageCapacityListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1alpha1NamespacedCSIStorageCapacityListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacityList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1alpha1NamespacedCSIStorageCapacityList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1alpha1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest handles watchStorageV1beta1CSIStorageCapacityListForAllNamespaces operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1CSIStorageCapacityListForAllNamespaces"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			ID:   "watchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			OperationID:   "watchStorageV1beta1CSIStorageCapacityListForAllNamespaces",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams
			Response = WatchStorageV1beta1CSIStorageCapacityListForAllNamespacesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1CSIStorageCapacityListForAllNamespaces(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1CSIStorageCapacityListForAllNamespacesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest handles watchStorageV1beta1NamespacedCSIStorageCapacity operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacity",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1NamespacedCSIStorageCapacity",
			ID:   "watchStorageV1beta1NamespacedCSIStorageCapacity",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1beta1NamespacedCSIStorageCapacity", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1NamespacedCSIStorageCapacityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1beta1NamespacedCSIStorageCapacity",
			OperationID:   "watchStorageV1beta1NamespacedCSIStorageCapacity",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"name":                 params.Name,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1NamespacedCSIStorageCapacityParams
			Response = WatchStorageV1beta1NamespacedCSIStorageCapacityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1NamespacedCSIStorageCapacityParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacity(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest handles watchStorageV1beta1NamespacedCSIStorageCapacityList operation.
//
// GET /apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities
func (s *Server) handleWatchStorageV1beta1NamespacedCSIStorageCapacityListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("watchStorageV1beta1NamespacedCSIStorageCapacityList"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
			ID:   "watchStorageV1beta1NamespacedCSIStorageCapacityList",
		}
	)
	ctx, err = s.securityBearerToken(ctx, "WatchStorageV1beta1NamespacedCSIStorageCapacityList", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "BearerToken",
			Err:              err,
		}
		recordError("Security:BearerToken", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	params, err := decodeWatchStorageV1beta1NamespacedCSIStorageCapacityListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WatchStorageV1beta1NamespacedCSIStorageCapacityListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "WatchStorageV1beta1NamespacedCSIStorageCapacityList",
			OperationID:   "watchStorageV1beta1NamespacedCSIStorageCapacityList",
			Body:          nil,
			Params: map[string]any{
				"allowWatchBookmarks":  params.AllowWatchBookmarks,
				"continue":             params.Continue,
				"fieldSelector":        params.FieldSelector,
				"labelSelector":        params.LabelSelector,
				"limit":                params.Limit,
				"namespace":            params.Namespace,
				"pretty":               params.Pretty,
				"resourceVersion":      params.ResourceVersion,
				"resourceVersionMatch": params.ResourceVersionMatch,
				"timeoutSeconds":       params.TimeoutSeconds,
				"watch":                params.Watch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WatchStorageV1beta1NamespacedCSIStorageCapacityListParams
			Response = WatchStorageV1beta1NamespacedCSIStorageCapacityListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWatchStorageV1beta1NamespacedCSIStorageCapacityListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.WatchStorageV1beta1NamespacedCSIStorageCapacityList(ctx, params)
			},
		)
	} else {
		response, err = s.h.WatchStorageV1beta1NamespacedCSIStorageCapacityList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWatchStorageV1beta1NamespacedCSIStorageCapacityListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
