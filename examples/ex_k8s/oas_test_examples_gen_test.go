// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

import (
	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

var (
	_ = std.Marshal
	_ = testing.TB(nil)
	_ = require.NoError
)

func TestGetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhook_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1RuleWithOperations_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1RuleWithOperations
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1RuleWithOperations
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhook_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1WebhookClientConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1WebhookClientConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1WebhookClientConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1ServerStorageVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ControllerRevision_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ControllerRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ControllerRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ControllerRevisionList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ControllerRevisionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ControllerRevisionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetUpdateStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetUpdateStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetUpdateStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1Deployment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1Deployment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1Deployment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateDaemonSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateDaemonSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateDaemonSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateDeployment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateDeployment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateDeployment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetUpdateStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetUpdateStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetUpdateStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1Scale_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1Scale
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1Scale
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1ScaleSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1ScaleSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1ScaleSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1ScaleStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1ScaleStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1ScaleStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ExternalMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ExternalMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ExternalMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ExternalMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ExternalMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ExternalMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1MetricSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1MetricSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1MetricSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1MetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1MetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1MetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ObjectMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ObjectMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ObjectMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ObjectMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ObjectMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ObjectMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1PodsMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1PodsMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1PodsMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1PodsMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1PodsMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1PodsMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ExternalMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ExternalMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ExternalMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ExternalMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ExternalMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ExternalMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HPAScalingPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HPAScalingRules_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HPAScalingRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HPAScalingRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricIdentifier_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricIdentifier
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricIdentifier
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricTarget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricTarget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricTarget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricValueStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricValueStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricValueStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ObjectMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ObjectMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ObjectMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ObjectMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ObjectMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ObjectMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2PodsMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2PodsMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2PodsMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2PodsMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2PodsMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2PodsMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJob_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1Job_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1Job
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1Job
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1UncountedTerminatedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1UncountedTerminatedPods
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1UncountedTerminatedPods
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJob_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1JobTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1JobTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1JobTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra
	typ = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra
	typ2 = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1Lease_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1Lease
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1Lease
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1LeaseList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1LeaseList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1LeaseList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1LeaseSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1LeaseSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1LeaseSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Affinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Affinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Affinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AttachedVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AttachedVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AttachedVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureFilePersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureFilePersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureFilePersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureFileVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureFileVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureFileVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes
	typ = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes
	typ2 = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes
	typ = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes
	typ2 = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Capabilities_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Capabilities
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Capabilities
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CephFSPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CephFSPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CephFSPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CephFSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CephFSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CephFSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CinderPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CinderPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CinderPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CinderVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CinderVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CinderVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ClientIPConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ClientIPConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ClientIPConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentStatusList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentStatusList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentStatusList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMap_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMap
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMap
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapBinaryData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapBinaryData
	typ = make(IoK8sAPICoreV1ConfigMapBinaryData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapBinaryData
	typ2 = make(IoK8sAPICoreV1ConfigMapBinaryData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapData
	typ = make(IoK8sAPICoreV1ConfigMapData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapData
	typ2 = make(IoK8sAPICoreV1ConfigMapData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapEnvSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapEnvSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapEnvSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapKeySelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapKeySelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapKeySelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapNodeConfigSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapNodeConfigSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapNodeConfigSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Container_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Container
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Container
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerImage_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerState_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateRunning_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateRunning
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateRunning
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateTerminated_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateTerminated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateTerminated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateWaiting_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateWaiting
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateWaiting
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DaemonEndpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DaemonEndpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DaemonEndpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIVolumeFile_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIVolumeFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIVolumeFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EmptyDirVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EmptyDirVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EmptyDirVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointAddress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointSubset_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointSubset
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointSubset
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Endpoints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Endpoints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Endpoints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointsList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointsList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointsList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvFromSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvFromSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvFromSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvVar_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvVar
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvVar
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvVarSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvVarSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvVarSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EphemeralContainer_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EphemeralContainer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EphemeralContainer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EphemeralVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EphemeralVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EphemeralVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ExecAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ExecAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ExecAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FCVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FCVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FCVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexPersistentVolumeSourceOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexPersistentVolumeSourceOptions
	typ = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexPersistentVolumeSourceOptions
	typ2 = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexVolumeSourceOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexVolumeSourceOptions
	typ = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexVolumeSourceOptions
	typ2 = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlockerVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlockerVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlockerVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GCEPersistentDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GCEPersistentDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GCEPersistentDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GitRepoVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GitRepoVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GitRepoVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GlusterfsPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GlusterfsPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GlusterfsPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GlusterfsVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GlusterfsVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GlusterfsVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HTTPGetAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HTTPGetAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HTTPGetAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HTTPHeader_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HTTPHeader
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HTTPHeader
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Handler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Handler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Handler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HostAlias_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HostAlias
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HostAlias
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HostPathVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HostPathVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HostPathVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ISCSIPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ISCSIPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ISCSIPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ISCSIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ISCSIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ISCSIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1KeyToPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1KeyToPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1KeyToPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Lifecycle_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Lifecycle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Lifecycle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItem_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemDefault_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemDefault
	typ = make(IoK8sAPICoreV1LimitRangeItemDefault)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemDefault
	typ2 = make(IoK8sAPICoreV1LimitRangeItemDefault)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemDefaultRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemDefaultRequest
	typ = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemDefaultRequest
	typ2 = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMax_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMax
	typ = make(IoK8sAPICoreV1LimitRangeItemMax)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMax
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMax)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio
	typ = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMin_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMin
	typ = make(IoK8sAPICoreV1LimitRangeItemMin)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMin
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMin)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LoadBalancerIngress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LoadBalancerIngress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LoadBalancerIngress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LoadBalancerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LoadBalancerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LoadBalancerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LocalObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LocalObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LocalObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LocalVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LocalVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LocalVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NFSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NFSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NFSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Namespace_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Namespace
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Namespace
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Node_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeAddress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeConfigSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeConfigSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeConfigSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeConfigStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeConfigStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeConfigStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeDaemonEndpoints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeDaemonEndpoints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeDaemonEndpoints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelectorTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelectorTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelectorTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatusAllocatable_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatusAllocatable
	typ = make(IoK8sAPICoreV1NodeStatusAllocatable)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatusAllocatable
	typ2 = make(IoK8sAPICoreV1NodeStatusAllocatable)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatusCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatusCapacity
	typ = make(IoK8sAPICoreV1NodeStatusCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatusCapacity
	typ2 = make(IoK8sAPICoreV1NodeStatusCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSystemInfo_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSystemInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSystemInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ObjectFieldSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ObjectFieldSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ObjectFieldSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaim_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaim
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaim
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity
	typ = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity
	typ2 = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimTemplate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeSpecCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeSpecCapacity
	typ = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeSpecCapacity
	typ2 = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PhotonPersistentDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PhotonPersistentDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PhotonPersistentDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Pod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Pod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Pod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAffinityTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAffinityTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAffinityTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAntiAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAntiAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAntiAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodDNSConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodDNSConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodDNSConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodDNSConfigOption_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodDNSConfigOption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodDNSConfigOption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodIP_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodIP
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodIP
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodReadinessGate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodReadinessGate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodReadinessGate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSecurityContext_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSecurityContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSecurityContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpecNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpecNodeSelector
	typ = make(IoK8sAPICoreV1PodSpecNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpecNodeSelector
	typ2 = make(IoK8sAPICoreV1PodSpecNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpecOverhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpecOverhead
	typ = make(IoK8sAPICoreV1PodSpecOverhead)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpecOverhead
	typ2 = make(IoK8sAPICoreV1PodSpecOverhead)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplateList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplateList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplateList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PortStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PortStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PortStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PortworxVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PortworxVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PortworxVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PreferredSchedulingTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PreferredSchedulingTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PreferredSchedulingTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Probe_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Probe
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Probe
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ProjectedVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ProjectedVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ProjectedVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1QuobyteVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1QuobyteVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1QuobyteVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1RBDPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1RBDPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1RBDPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1RBDVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1RBDVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1RBDVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationController_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationController
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationController
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerSpecSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerSpecSelector
	typ = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerSpecSelector
	typ2 = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceFieldSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceFieldSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceFieldSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuota_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuota
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuota
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaSpecHard_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaSpecHard
	typ = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaSpecHard
	typ2 = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatusHard_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatusHard
	typ = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatusHard
	typ2 = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatusUsed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatusUsed
	typ = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatusUsed
	typ2 = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirements_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirements
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirements
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirementsLimits_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirementsLimits
	typ = make(IoK8sAPICoreV1ResourceRequirementsLimits)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirementsLimits
	typ2 = make(IoK8sAPICoreV1ResourceRequirementsLimits)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirementsRequests_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirementsRequests
	typ = make(IoK8sAPICoreV1ResourceRequirementsRequests)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirementsRequests
	typ2 = make(IoK8sAPICoreV1ResourceRequirementsRequests)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SELinuxOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SELinuxOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SELinuxOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScaleIOPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScaleIOPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScaleIOPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScaleIOVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScaleIOVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScaleIOVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScopeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScopeSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScopeSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScopedResourceSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScopedResourceSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScopedResourceSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SeccompProfile_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SeccompProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SeccompProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Secret_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Secret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Secret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretData
	typ = make(IoK8sAPICoreV1SecretData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretData
	typ2 = make(IoK8sAPICoreV1SecretData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretEnvSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretEnvSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretEnvSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretKeySelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretKeySelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretKeySelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretStringData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretStringData
	typ = make(IoK8sAPICoreV1SecretStringData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretStringData
	typ2 = make(IoK8sAPICoreV1SecretStringData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecurityContext_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecurityContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecurityContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Service_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Service
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Service
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccount_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccountList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccountList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccountList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccountTokenProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccountTokenProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccountTokenProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServicePort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServicePort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServicePort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceSpecSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceSpecSelector
	typ = make(IoK8sAPICoreV1ServiceSpecSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceSpecSelector
	typ2 = make(IoK8sAPICoreV1ServiceSpecSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SessionAffinityConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SessionAffinityConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SessionAffinityConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1StorageOSPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1StorageOSPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1StorageOSPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1StorageOSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1StorageOSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1StorageOSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Sysctl_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Sysctl
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Sysctl
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TCPSocketAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TCPSocketAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TCPSocketAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Taint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Taint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Taint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Toleration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Toleration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Toleration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySelectorLabelRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySelectorLabelRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySelectorLabelRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySelectorTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySelectorTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySelectorTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySpreadConstraint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySpreadConstraint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySpreadConstraint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TypedLocalObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TypedLocalObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TypedLocalObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Volume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Volume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Volume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeDevice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeMount_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeMount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeMount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeNodeAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeNodeAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeNodeAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VsphereVirtualDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VsphereVirtualDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VsphereVirtualDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1WeightedPodAffinityTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1WeightedPodAffinityTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1WeightedPodAffinityTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1WindowsSecurityContextOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1WindowsSecurityContextOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1WindowsSecurityContextOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1Endpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1Endpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1Endpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointConditions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointConditions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointConditions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointDeprecatedTopology_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointDeprecatedTopology
	typ = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointDeprecatedTopology
	typ2 = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointHints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointHints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointHints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointSlice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointSlice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointSlice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointSliceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointSliceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointSliceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1ForZone_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1ForZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1ForZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1Endpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1Endpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1Endpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointConditions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointConditions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointConditions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointHints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointHints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointHints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointSlice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointSlice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointSlice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointSliceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointSliceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointSliceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointTopology_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointTopology
	typ = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointTopology
	typ2 = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1ForZone_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1ForZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1ForZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchema_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchema
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchema
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1GroupSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1GroupSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1GroupSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1LimitResponse_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1LimitResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1LimitResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1QueuingConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1QueuingConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1QueuingConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1UserSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1UserSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1UserSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchema_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchema
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchema
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2GroupSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2GroupSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2GroupSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2LimitResponse_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2LimitResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2LimitResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2QueuingConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2QueuingConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2QueuingConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2UserSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2UserSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2UserSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1HTTPIngressPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1HTTPIngressPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1HTTPIngressPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1HTTPIngressRuleValue_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1HTTPIngressRuleValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1HTTPIngressRuleValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IPBlock_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IPBlock
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IPBlock
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1Ingress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1Ingress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1Ingress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressBackend_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressBackend
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressBackend
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassParametersReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassParametersReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassParametersReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressServiceBackend_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressServiceBackend
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressServiceBackend
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressTLS_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressTLS
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressTLS
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyEgressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyEgressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyEgressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyIngressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyIngressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyIngressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyPeer_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicySpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicySpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicySpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1ServiceBackendPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1ServiceBackendPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1ServiceBackendPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1OverheadPodFixed
	typ = make(IoK8sAPINodeV1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1OverheadPodFixed
	typ = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClassSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClassSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClassSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1OverheadPodFixed
	typ = make(IoK8sAPINodeV1beta1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1beta1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods
	typ = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods
	typ2 = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedCSIDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedCSIDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedCSIDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedFlexVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedFlexVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedFlexVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedHostPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedHostPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedHostPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1FSGroupStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1FSGroupStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1FSGroupStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1HostPortRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1HostPortRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1HostPortRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1IDRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1IDRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1IDRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods
	typ = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods
	typ2 = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicyList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicySpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicySpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicySpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1SELinuxStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1SELinuxStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1SELinuxStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1AggregationRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1AggregationRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1AggregationRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRole_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleBinding_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleBinding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleBinding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleBindingList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleBindingList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleBindingList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1PolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1PolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1PolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1Role_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1Role
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1Role
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleBinding_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleBinding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleBinding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleBindingList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleBindingList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleBindingList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleRef_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPISchedulingV1PriorityClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPISchedulingV1PriorityClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPISchedulingV1PriorityClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPISchedulingV1PriorityClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPISchedulingV1PriorityClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPISchedulingV1PriorityClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriverList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriverList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriverList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriverSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriverSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriverSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINode_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClassParameters_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClassParameters
	typ = make(IoK8sAPIStorageV1StorageClassParameters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClassParameters
	typ2 = make(IoK8sAPIStorageV1StorageClassParameters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1TokenRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1TokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1TokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata
	typ = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata
	typ2 = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeError_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeNodeResources_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeNodeResources
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeNodeResources
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1alpha1CSIStorageCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1alpha1CSIStorageCapacity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1alpha1CSIStorageCapacity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1alpha1CSIStorageCapacityList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1alpha1CSIStorageCapacityList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1alpha1CSIStorageCapacityList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1beta1CSIStorageCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1beta1CSIStorageCapacity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1beta1CSIStorageCapacity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1beta1CSIStorageCapacityList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1beta1CSIStorageCapacityList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1beta1CSIStorageCapacityList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgAPIResourceQuantity_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgAPIResourceQuantity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgAPIResourceQuantity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIGroup_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIGroupList_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIGroupList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIGroupList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIResource_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIResource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIResource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIResourceList_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIResourceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIResourceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIVersions_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIVersions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIVersions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1Condition_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1Condition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1Condition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1FieldsV1_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1FieldsV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1FieldsV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels
	typ = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels
	typ2 = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ListMeta_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ListMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ListMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1MicroTime_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1MicroTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1MicroTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMeta_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations
	typ = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations
	typ2 = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels
	typ = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels
	typ2 = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1OwnerReference_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1OwnerReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1OwnerReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1Time_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1Time
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1Time
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1WatchEvent_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1WatchEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1WatchEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgRuntimeRawExtension_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgRuntimeRawExtension
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgRuntimeRawExtension
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgUtilIntstrIntOrString_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgUtilIntstrIntOrString
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgUtilIntstrIntOrString
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgVersionInfo_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgVersionInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgVersionInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIService_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadCoreV1NamespacedPodLogOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReadCoreV1NamespacedPodLogOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadCoreV1NamespacedPodLogOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
