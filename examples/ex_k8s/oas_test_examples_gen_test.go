// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestGetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceAccountIssuerOpenIDKeysetOKApplicationJwkSetJSON_EncodeDecode(t *testing.T) {
	var typ GetServiceAccountIssuerOpenIDKeysetOKApplicationJwkSetJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceAccountIssuerOpenIDKeysetOKApplicationJwkSetJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhook_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1RuleWithOperations_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1RuleWithOperations
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1RuleWithOperations
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhook_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAdmissionregistrationV1WebhookClientConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAdmissionregistrationV1WebhookClientConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAdmissionregistrationV1WebhookClientConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1ServerStorageVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIApiserverinternalV1alpha1StorageVersionStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ControllerRevision_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ControllerRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ControllerRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ControllerRevisionList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ControllerRevisionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ControllerRevisionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DaemonSetUpdateStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DaemonSetUpdateStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DaemonSetUpdateStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1Deployment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1Deployment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1Deployment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1DeploymentStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1DeploymentStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1DeploymentStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1ReplicaSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1ReplicaSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1ReplicaSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateDaemonSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateDaemonSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateDaemonSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateDeployment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateDeployment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateDeployment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSet_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAppsV1StatefulSetUpdateStrategy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAppsV1StatefulSetUpdateStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAppsV1StatefulSetUpdateStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1Scale_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1Scale
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1Scale
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1ScaleSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1ScaleSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1ScaleSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV1ScaleStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV1ScaleStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV1ScaleStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ExternalMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ExternalMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ExternalMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ExternalMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ExternalMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ExternalMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1MetricSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1MetricSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1MetricSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1MetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1MetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1MetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ObjectMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ObjectMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ObjectMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ObjectMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ObjectMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ObjectMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1PodsMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1PodsMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1PodsMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1PodsMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1PodsMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1PodsMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta1ResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta1ResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta1ResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ExternalMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ExternalMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ExternalMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ExternalMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ExternalMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ExternalMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HPAScalingPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HPAScalingRules_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HPAScalingRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HPAScalingRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricIdentifier_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricIdentifier
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricIdentifier
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricTarget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricTarget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricTarget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2MetricValueStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2MetricValueStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2MetricValueStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ObjectMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ObjectMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ObjectMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ObjectMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ObjectMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ObjectMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2PodsMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2PodsMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2PodsMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2PodsMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2PodsMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2PodsMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ResourceMetricSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ResourceMetricSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ResourceMetricSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIAutoscalingV2beta2ResourceMetricStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIAutoscalingV2beta2ResourceMetricStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIAutoscalingV2beta2ResourceMetricStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJob_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1CronJobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1CronJobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1CronJobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1Job_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1Job
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1Job
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1JobTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1JobTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1JobTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1UncountedTerminatedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1UncountedTerminatedPods
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1UncountedTerminatedPods
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJob_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1CronJobStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1CronJobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1CronJobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIBatchV1beta1JobTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIBatchV1beta1JobTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIBatchV1beta1JobTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra
	typ = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra
	typ2 = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICertificatesV1CertificateSigningRequestStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICertificatesV1CertificateSigningRequestStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICertificatesV1CertificateSigningRequestStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1Lease_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1Lease
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1Lease
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1LeaseList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1LeaseList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1LeaseList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoordinationV1LeaseSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoordinationV1LeaseSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoordinationV1LeaseSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Affinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Affinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Affinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AttachedVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AttachedVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AttachedVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureFilePersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureFilePersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureFilePersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1AzureFileVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1AzureFileVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1AzureFileVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes
	typ = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes
	typ2 = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes
	typ = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes
	typ2 = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Capabilities_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Capabilities
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Capabilities
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CephFSPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CephFSPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CephFSPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CephFSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CephFSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CephFSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CinderPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CinderPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CinderPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1CinderVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1CinderVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1CinderVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ClientIPConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ClientIPConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ClientIPConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ComponentStatusList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ComponentStatusList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ComponentStatusList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMap_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMap
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMap
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapBinaryData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapBinaryData
	typ = make(IoK8sAPICoreV1ConfigMapBinaryData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapBinaryData
	typ2 = make(IoK8sAPICoreV1ConfigMapBinaryData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapData
	typ = make(IoK8sAPICoreV1ConfigMapData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapData
	typ2 = make(IoK8sAPICoreV1ConfigMapData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapEnvSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapEnvSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapEnvSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapKeySelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapKeySelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapKeySelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapNodeConfigSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapNodeConfigSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapNodeConfigSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ConfigMapVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ConfigMapVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ConfigMapVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Container_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Container
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Container
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerImage_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerState_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateRunning_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateRunning
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateRunning
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateTerminated_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateTerminated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateTerminated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStateWaiting_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStateWaiting
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStateWaiting
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ContainerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ContainerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ContainerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DaemonEndpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DaemonEndpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DaemonEndpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIVolumeFile_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIVolumeFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIVolumeFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1DownwardAPIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1DownwardAPIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1DownwardAPIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EmptyDirVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EmptyDirVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EmptyDirVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointAddress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointSubset_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointSubset
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointSubset
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Endpoints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Endpoints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Endpoints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EndpointsList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EndpointsList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EndpointsList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvFromSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvFromSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvFromSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvVar_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvVar
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvVar
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EnvVarSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EnvVarSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EnvVarSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EphemeralContainer_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EphemeralContainer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EphemeralContainer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EphemeralVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EphemeralVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EphemeralVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1EventSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1EventSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1EventSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ExecAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ExecAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ExecAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FCVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FCVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FCVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexPersistentVolumeSourceOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexPersistentVolumeSourceOptions
	typ = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexPersistentVolumeSourceOptions
	typ2 = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlexVolumeSourceOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlexVolumeSourceOptions
	typ = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlexVolumeSourceOptions
	typ2 = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1FlockerVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1FlockerVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1FlockerVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GCEPersistentDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GCEPersistentDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GCEPersistentDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GitRepoVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GitRepoVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GitRepoVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GlusterfsPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GlusterfsPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GlusterfsPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1GlusterfsVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1GlusterfsVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1GlusterfsVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HTTPGetAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HTTPGetAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HTTPGetAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HTTPHeader_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HTTPHeader
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HTTPHeader
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Handler_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Handler
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Handler
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HostAlias_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HostAlias
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HostAlias
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1HostPathVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1HostPathVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1HostPathVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ISCSIPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ISCSIPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ISCSIPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ISCSIVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ISCSIVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ISCSIVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1KeyToPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1KeyToPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1KeyToPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Lifecycle_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Lifecycle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Lifecycle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItem_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemDefault_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemDefault
	typ = make(IoK8sAPICoreV1LimitRangeItemDefault)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemDefault
	typ2 = make(IoK8sAPICoreV1LimitRangeItemDefault)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemDefaultRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemDefaultRequest
	typ = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemDefaultRequest
	typ2 = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMax_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMax
	typ = make(IoK8sAPICoreV1LimitRangeItemMax)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMax
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMax)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio
	typ = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeItemMin_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeItemMin
	typ = make(IoK8sAPICoreV1LimitRangeItemMin)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeItemMin
	typ2 = make(IoK8sAPICoreV1LimitRangeItemMin)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LimitRangeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LimitRangeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LimitRangeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LoadBalancerIngress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LoadBalancerIngress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LoadBalancerIngress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LoadBalancerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LoadBalancerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LoadBalancerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LocalObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LocalObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LocalObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1LocalVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1LocalVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1LocalVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NFSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NFSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NFSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Namespace_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Namespace
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Namespace
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NamespaceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NamespaceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NamespaceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Node_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeAddress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeAddress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeAddress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeConfigSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeConfigSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeConfigSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeConfigStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeConfigStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeConfigStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeDaemonEndpoints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeDaemonEndpoints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeDaemonEndpoints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSelectorTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSelectorTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSelectorTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatusAllocatable_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatusAllocatable
	typ = make(IoK8sAPICoreV1NodeStatusAllocatable)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatusAllocatable
	typ2 = make(IoK8sAPICoreV1NodeStatusAllocatable)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeStatusCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeStatusCapacity
	typ = make(IoK8sAPICoreV1NodeStatusCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeStatusCapacity
	typ2 = make(IoK8sAPICoreV1NodeStatusCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1NodeSystemInfo_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1NodeSystemInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1NodeSystemInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ObjectFieldSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ObjectFieldSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ObjectFieldSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaim_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaim
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaim
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity
	typ = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity
	typ2 = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimTemplate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeClaimVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeClaimVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeClaimVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeSpecCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeSpecCapacity
	typ = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeSpecCapacity
	typ2 = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PersistentVolumeStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PersistentVolumeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PersistentVolumeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PhotonPersistentDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PhotonPersistentDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PhotonPersistentDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Pod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Pod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Pod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAffinityTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAffinityTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAffinityTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodAntiAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodAntiAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodAntiAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodDNSConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodDNSConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodDNSConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodDNSConfigOption_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodDNSConfigOption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodDNSConfigOption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodIP_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodIP
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodIP
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodReadinessGate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodReadinessGate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodReadinessGate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSecurityContext_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSecurityContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSecurityContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpecNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpecNodeSelector
	typ = make(IoK8sAPICoreV1PodSpecNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpecNodeSelector
	typ2 = make(IoK8sAPICoreV1PodSpecNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodSpecOverhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodSpecOverhead
	typ = make(IoK8sAPICoreV1PodSpecOverhead)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodSpecOverhead
	typ2 = make(IoK8sAPICoreV1PodSpecOverhead)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplate_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplateList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplateList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplateList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PodTemplateSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PodTemplateSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PodTemplateSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PortStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PortStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PortStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PortworxVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PortworxVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PortworxVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1PreferredSchedulingTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1PreferredSchedulingTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1PreferredSchedulingTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Probe_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Probe
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Probe
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ProjectedVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ProjectedVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ProjectedVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1QuobyteVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1QuobyteVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1QuobyteVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1RBDPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1RBDPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1RBDPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1RBDVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1RBDVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1RBDVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationController_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationController
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationController
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerSpecSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerSpecSelector
	typ = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerSpecSelector
	typ2 = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ReplicationControllerStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ReplicationControllerStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ReplicationControllerStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceFieldSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceFieldSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceFieldSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuota_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuota
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuota
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaSpecHard_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaSpecHard
	typ = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaSpecHard
	typ2 = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatusHard_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatusHard
	typ = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatusHard
	typ2 = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceQuotaStatusUsed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceQuotaStatusUsed
	typ = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceQuotaStatusUsed
	typ2 = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirements_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirements
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirements
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirementsLimits_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirementsLimits
	typ = make(IoK8sAPICoreV1ResourceRequirementsLimits)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirementsLimits
	typ2 = make(IoK8sAPICoreV1ResourceRequirementsLimits)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ResourceRequirementsRequests_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ResourceRequirementsRequests
	typ = make(IoK8sAPICoreV1ResourceRequirementsRequests)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ResourceRequirementsRequests
	typ2 = make(IoK8sAPICoreV1ResourceRequirementsRequests)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SELinuxOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SELinuxOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SELinuxOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScaleIOPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScaleIOPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScaleIOPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScaleIOVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScaleIOVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScaleIOVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScopeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScopeSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScopeSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ScopedResourceSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ScopedResourceSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ScopedResourceSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SeccompProfile_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SeccompProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SeccompProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Secret_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Secret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Secret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretData
	typ = make(IoK8sAPICoreV1SecretData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretData
	typ2 = make(IoK8sAPICoreV1SecretData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretEnvSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretEnvSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretEnvSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretKeySelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretKeySelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretKeySelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretStringData_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretStringData
	typ = make(IoK8sAPICoreV1SecretStringData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretStringData
	typ2 = make(IoK8sAPICoreV1SecretStringData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecretVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecretVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecretVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SecurityContext_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SecurityContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SecurityContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Service_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Service
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Service
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccount_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccountList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccountList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccountList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceAccountTokenProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceAccountTokenProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceAccountTokenProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServicePort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServicePort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServicePort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceSpecSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceSpecSelector
	typ = make(IoK8sAPICoreV1ServiceSpecSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceSpecSelector
	typ2 = make(IoK8sAPICoreV1ServiceSpecSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1ServiceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1ServiceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1ServiceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1SessionAffinityConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1SessionAffinityConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1SessionAffinityConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1StorageOSPersistentVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1StorageOSPersistentVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1StorageOSPersistentVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1StorageOSVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1StorageOSVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1StorageOSVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Sysctl_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Sysctl
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Sysctl
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TCPSocketAction_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TCPSocketAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TCPSocketAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Taint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Taint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Taint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Toleration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Toleration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Toleration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySelectorLabelRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySelectorLabelRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySelectorLabelRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySelectorTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySelectorTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySelectorTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TopologySpreadConstraint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TopologySpreadConstraint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TopologySpreadConstraint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1TypedLocalObjectReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1TypedLocalObjectReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1TypedLocalObjectReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1Volume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1Volume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1Volume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeDevice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeMount_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeMount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeMount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeNodeAffinity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeNodeAffinity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeNodeAffinity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VolumeProjection_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VolumeProjection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VolumeProjection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1VsphereVirtualDiskVolumeSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1VsphereVirtualDiskVolumeSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1VsphereVirtualDiskVolumeSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1WeightedPodAffinityTerm_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1WeightedPodAffinityTerm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1WeightedPodAffinityTerm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPICoreV1WindowsSecurityContextOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPICoreV1WindowsSecurityContextOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPICoreV1WindowsSecurityContextOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1Endpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1Endpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1Endpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointConditions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointConditions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointConditions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointDeprecatedTopology_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointDeprecatedTopology
	typ = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointDeprecatedTopology
	typ2 = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointHints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointHints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointHints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointSlice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointSlice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointSlice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1EndpointSliceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1EndpointSliceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1EndpointSliceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1ForZone_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1ForZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1ForZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1Endpoint_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1Endpoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1Endpoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointConditions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointConditions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointConditions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointHints_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointHints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointHints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointSlice_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointSlice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointSlice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointSliceList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointSliceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointSliceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1EndpointTopology_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1EndpointTopology
	typ = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1EndpointTopology
	typ2 = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIDiscoveryV1beta1ForZone_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIDiscoveryV1beta1ForZone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIDiscoveryV1beta1ForZone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1Event_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1EventList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1EventList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1EventList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIEventsV1beta1EventSeries_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIEventsV1beta1EventSeries
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIEventsV1beta1EventSeries
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchema_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchema
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchema
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1GroupSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1GroupSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1GroupSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1LimitResponse_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1LimitResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1LimitResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1QueuingConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1QueuingConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1QueuingConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta1UserSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta1UserSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta1UserSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchema_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchema
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchema
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2GroupSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2GroupSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2GroupSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2LimitResponse_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2LimitResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2LimitResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2QueuingConfiguration_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2QueuingConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2QueuingConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIFlowcontrolV1beta2UserSubject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIFlowcontrolV1beta2UserSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIFlowcontrolV1beta2UserSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1HTTPIngressPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1HTTPIngressPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1HTTPIngressPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1HTTPIngressRuleValue_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1HTTPIngressRuleValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1HTTPIngressRuleValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IPBlock_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IPBlock
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IPBlock
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1Ingress_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1Ingress
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1Ingress
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressBackend_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressBackend
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressBackend
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassParametersReference_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassParametersReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassParametersReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressClassSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressClassSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressClassSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressServiceBackend_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressServiceBackend
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressServiceBackend
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1IngressTLS_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1IngressTLS
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1IngressTLS
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyEgressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyEgressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyEgressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyIngressRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyIngressRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyIngressRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyPeer_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyPeer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyPeer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicyPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicyPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicyPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1NetworkPolicySpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1NetworkPolicySpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1NetworkPolicySpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINetworkingV1ServiceBackendPort_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINetworkingV1ServiceBackendPort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINetworkingV1ServiceBackendPort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1OverheadPodFixed
	typ = make(IoK8sAPINodeV1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1OverheadPodFixed
	typ = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1RuntimeClassSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1RuntimeClassSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1RuntimeClassSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1alpha1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1alpha1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1alpha1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1Overhead_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1Overhead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1Overhead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1OverheadPodFixed_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1OverheadPodFixed
	typ = make(IoK8sAPINodeV1beta1OverheadPodFixed)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1OverheadPodFixed
	typ2 = make(IoK8sAPINodeV1beta1OverheadPodFixed)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1RuntimeClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1RuntimeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1RuntimeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1RuntimeClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1RuntimeClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1RuntimeClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1Scheduling_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1Scheduling
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1Scheduling
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPINodeV1beta1SchedulingNodeSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sAPINodeV1beta1SchedulingNodeSelector
	typ = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPINodeV1beta1SchedulingNodeSelector
	typ2 = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods
	typ = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods
	typ2 = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedCSIDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedCSIDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedCSIDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedFlexVolume_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedFlexVolume
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedFlexVolume
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1AllowedHostPath_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1AllowedHostPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1AllowedHostPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1FSGroupStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1FSGroupStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1FSGroupStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1HostPortRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1HostPortRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1HostPortRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1IDRange_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1IDRange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1IDRange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudget_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods
	typ = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods
	typ2 = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicy_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicyList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicyList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicyList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1PodSecurityPolicySpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1PodSecurityPolicySpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1PodSecurityPolicySpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1SELinuxStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1SELinuxStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1SELinuxStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1AggregationRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1AggregationRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1AggregationRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRole_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleBinding_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleBinding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleBinding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleBindingList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleBindingList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleBindingList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1ClusterRoleList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1ClusterRoleList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1ClusterRoleList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1PolicyRule_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1PolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1PolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1Role_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1Role
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1Role
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleBinding_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleBinding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleBinding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleBindingList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleBindingList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleBindingList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1RoleRef_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1RoleRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1RoleRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIRbacV1Subject_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIRbacV1Subject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIRbacV1Subject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPISchedulingV1PriorityClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPISchedulingV1PriorityClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPISchedulingV1PriorityClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPISchedulingV1PriorityClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPISchedulingV1PriorityClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPISchedulingV1PriorityClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriverList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriverList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriverList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSIDriverSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSIDriverSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSIDriverSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINode_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeDriver_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeDriver
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeDriver
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1CSINodeSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1CSINodeSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1CSINodeSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClass_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClassList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClassList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClassList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1StorageClassParameters_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1StorageClassParameters
	typ = make(IoK8sAPIStorageV1StorageClassParameters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1StorageClassParameters
	typ2 = make(IoK8sAPIStorageV1StorageClassParameters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1TokenRequest_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1TokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1TokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachment_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentSource_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata
	typ = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata
	typ2 = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeError_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1VolumeNodeResources_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1VolumeNodeResources
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1VolumeNodeResources
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1alpha1CSIStorageCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1alpha1CSIStorageCapacity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1alpha1CSIStorageCapacity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1alpha1CSIStorageCapacityList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1alpha1CSIStorageCapacityList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1alpha1CSIStorageCapacityList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1beta1CSIStorageCapacity_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1beta1CSIStorageCapacity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1beta1CSIStorageCapacity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sAPIStorageV1beta1CSIStorageCapacityList_EncodeDecode(t *testing.T) {
	var typ IoK8sAPIStorageV1beta1CSIStorageCapacityList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sAPIStorageV1beta1CSIStorageCapacityList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties
	typ = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties
	typ2 = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion_EncodeDecode(t *testing.T) {
	var typ IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgAPIResourceQuantity_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgAPIResourceQuantity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgAPIResourceQuantity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIGroup_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIGroupList_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIGroupList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIGroupList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIResource_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIResource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIResource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIResourceList_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIResourceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIResourceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1APIVersions_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1APIVersions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1APIVersions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1Condition_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1Condition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1Condition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1FieldsV1_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1FieldsV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1FieldsV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelector_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels
	typ = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels
	typ2 = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ListMeta_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ListMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ListMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1MicroTime_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1MicroTime
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1MicroTime
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMeta_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations
	typ = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations
	typ2 = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels
	typ = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels
	typ2 = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1OwnerReference_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1OwnerReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1OwnerReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1Patch_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1Patch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1Patch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1Time_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1Time
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1Time
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgApisMetaV1WatchEvent_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgApisMetaV1WatchEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgApisMetaV1WatchEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgRuntimeRawExtension_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgRuntimeRawExtension
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgRuntimeRawExtension
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgUtilIntstrIntOrString_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgUtilIntstrIntOrString
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgUtilIntstrIntOrString
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sApimachineryPkgVersionInfo_EncodeDecode(t *testing.T) {
	var typ IoK8sApimachineryPkgVersionInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sApimachineryPkgVersionInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIService_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference_EncodeDecode(t *testing.T) {
	var typ IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1MutatingWebhookConfigurationApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1MutatingWebhookConfigurationCreated_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1MutatingWebhookConfigurationCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1MutatingWebhookConfigurationCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1MutatingWebhookConfigurationOK_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1MutatingWebhookConfigurationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1MutatingWebhookConfigurationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1ValidatingWebhookConfigurationApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1ValidatingWebhookConfigurationCreated_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1ValidatingWebhookConfigurationCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1ValidatingWebhookConfigurationCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAdmissionregistrationV1ValidatingWebhookConfigurationOK_EncodeDecode(t *testing.T) {
	var typ PatchAdmissionregistrationV1ValidatingWebhookConfigurationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAdmissionregistrationV1ValidatingWebhookConfigurationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionCreated_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionOK_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiextensionsV1CustomResourceDefinitionStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchApiextensionsV1CustomResourceDefinitionStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiextensionsV1CustomResourceDefinitionStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceCreated_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceOK_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchApiregistrationV1APIServiceStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchApiregistrationV1APIServiceStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchApiregistrationV1APIServiceStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedControllerRevisionApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedControllerRevisionApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedControllerRevisionApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedControllerRevisionApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedControllerRevisionApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedControllerRevisionApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedControllerRevisionApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedControllerRevisionApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedControllerRevisionApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedControllerRevisionCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedControllerRevisionCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedControllerRevisionCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedControllerRevisionOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedControllerRevisionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedControllerRevisionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDaemonSetStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDaemonSetStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDaemonSetStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentScaleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentScaleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentScaleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentScaleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentScaleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentScaleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentScaleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentScaleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentScaleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentScaleCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentScaleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentScaleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentScaleOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentScaleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentScaleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedDeploymentStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedDeploymentStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedDeploymentStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetScaleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetScaleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetScaleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetScaleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetScaleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetScaleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetScaleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetScaleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetScaleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetScaleCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetScaleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetScaleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetScaleOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetScaleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetScaleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedReplicaSetStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedReplicaSetStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedReplicaSetStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetScaleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetScaleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetScaleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetScaleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetScaleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetScaleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetScaleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetScaleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetScaleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetScaleCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetScaleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetScaleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetScaleOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetScaleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetScaleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAppsV1NamespacedStatefulSetStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAppsV1NamespacedStatefulSetStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAppsV1NamespacedStatefulSetStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedCronJobStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedCronJobStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedCronJobStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1NamespacedJobStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1NamespacedJobStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1NamespacedJobStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchBatchV1beta1NamespacedCronJobStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchBatchV1beta1NamespacedCronJobStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchBatchV1beta1NamespacedCronJobStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApprovalApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApprovalApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApprovalApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApprovalApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApprovalApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApprovalApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApprovalApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApprovalApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApprovalApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApprovalCreated_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApprovalCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApprovalCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestApprovalOK_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestApprovalOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestApprovalOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestCreated_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestOK_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCertificatesV1CertificateSigningRequestStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCertificatesV1CertificateSigningRequestStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCertificatesV1CertificateSigningRequestStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoordinationV1NamespacedLeaseApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoordinationV1NamespacedLeaseApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoordinationV1NamespacedLeaseApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoordinationV1NamespacedLeaseApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoordinationV1NamespacedLeaseApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoordinationV1NamespacedLeaseApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoordinationV1NamespacedLeaseApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoordinationV1NamespacedLeaseApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoordinationV1NamespacedLeaseApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoordinationV1NamespacedLeaseCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoordinationV1NamespacedLeaseCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoordinationV1NamespacedLeaseCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoordinationV1NamespacedLeaseOK_EncodeDecode(t *testing.T) {
	var typ PatchCoordinationV1NamespacedLeaseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoordinationV1NamespacedLeaseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespaceStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespaceStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespaceStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedConfigMapApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedConfigMapApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedConfigMapApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedConfigMapApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedConfigMapApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedConfigMapApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedConfigMapApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedConfigMapApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedConfigMapApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedConfigMapCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedConfigMapCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedConfigMapCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedConfigMapOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedConfigMapOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedConfigMapOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEndpointsApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEndpointsApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEndpointsApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEndpointsApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEndpointsApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEndpointsApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEndpointsApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEndpointsApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEndpointsApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEndpointsCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEndpointsCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEndpointsCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEndpointsOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEndpointsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEndpointsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEventApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEventApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEventApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEventApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEventApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEventApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEventApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEventApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEventApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEventCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEventCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEventCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedEventOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedEventOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedEventOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedLimitRangeApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedLimitRangeApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedLimitRangeApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedLimitRangeApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedLimitRangeApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedLimitRangeApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedLimitRangeApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedLimitRangeApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedLimitRangeApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedLimitRangeCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedLimitRangeCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedLimitRangeCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedLimitRangeOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedLimitRangeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedLimitRangeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPersistentVolumeClaimStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPersistentVolumeClaimStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPersistentVolumeClaimStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodEphemeralcontainersApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodEphemeralcontainersApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodEphemeralcontainersApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodEphemeralcontainersApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodEphemeralcontainersApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodEphemeralcontainersApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodEphemeralcontainersApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodEphemeralcontainersApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodEphemeralcontainersApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodEphemeralcontainersCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodEphemeralcontainersCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodEphemeralcontainersCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodEphemeralcontainersOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodEphemeralcontainersOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodEphemeralcontainersOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodTemplateApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodTemplateApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodTemplateApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodTemplateApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodTemplateApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodTemplateApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodTemplateApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodTemplateApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodTemplateApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodTemplateCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodTemplateCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodTemplateCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedPodTemplateOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedPodTemplateOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedPodTemplateOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerScaleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerScaleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerScaleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerScaleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerScaleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerScaleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerScaleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerScaleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerScaleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerScaleCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerScaleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerScaleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerScaleOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerScaleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerScaleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedReplicationControllerStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedReplicationControllerStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedReplicationControllerStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedResourceQuotaStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedResourceQuotaStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedResourceQuotaStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedSecretApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedSecretApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedSecretApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedSecretApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedSecretApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedSecretApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedSecretApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedSecretApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedSecretApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedSecretCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedSecretCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedSecretCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedSecretOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedSecretOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedSecretOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceAccountApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceAccountApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceAccountApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceAccountApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceAccountApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceAccountApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceAccountApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceAccountApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceAccountApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceAccountCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceAccountCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceAccountCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceAccountOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceAccountOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceAccountOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NamespacedServiceStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NamespacedServiceStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NamespacedServiceStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1NodeStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1NodeStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1NodeStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchCoreV1PersistentVolumeStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchCoreV1PersistentVolumeStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchCoreV1PersistentVolumeStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1NamespacedEndpointSliceApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1NamespacedEndpointSliceApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1NamespacedEndpointSliceApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1NamespacedEndpointSliceApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1NamespacedEndpointSliceApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1NamespacedEndpointSliceApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1NamespacedEndpointSliceApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1NamespacedEndpointSliceApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1NamespacedEndpointSliceApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1NamespacedEndpointSliceCreated_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1NamespacedEndpointSliceCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1NamespacedEndpointSliceCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1NamespacedEndpointSliceOK_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1NamespacedEndpointSliceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1NamespacedEndpointSliceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1beta1NamespacedEndpointSliceApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1beta1NamespacedEndpointSliceApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1beta1NamespacedEndpointSliceApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1beta1NamespacedEndpointSliceApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1beta1NamespacedEndpointSliceCreated_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1beta1NamespacedEndpointSliceCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1beta1NamespacedEndpointSliceCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchDiscoveryV1beta1NamespacedEndpointSliceOK_EncodeDecode(t *testing.T) {
	var typ PatchDiscoveryV1beta1NamespacedEndpointSliceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchDiscoveryV1beta1NamespacedEndpointSliceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1NamespacedEventApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1NamespacedEventApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1NamespacedEventApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1NamespacedEventApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1NamespacedEventApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1NamespacedEventApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1NamespacedEventApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1NamespacedEventApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1NamespacedEventApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1NamespacedEventCreated_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1NamespacedEventCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1NamespacedEventCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1NamespacedEventOK_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1NamespacedEventOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1NamespacedEventOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1beta1NamespacedEventApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1beta1NamespacedEventApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1beta1NamespacedEventApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1beta1NamespacedEventApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1beta1NamespacedEventApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1beta1NamespacedEventApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1beta1NamespacedEventApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1beta1NamespacedEventApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1beta1NamespacedEventApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1beta1NamespacedEventCreated_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1beta1NamespacedEventCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1beta1NamespacedEventCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchEventsV1beta1NamespacedEventOK_EncodeDecode(t *testing.T) {
	var typ PatchEventsV1beta1NamespacedEventOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchEventsV1beta1NamespacedEventOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1FlowSchemaStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1FlowSchemaStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1FlowSchemaStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2FlowSchemaStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2FlowSchemaStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2FlowSchemaStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionCreated_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionOK_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchInternalApiserverV1alpha1StorageVersionStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchInternalApiserverV1alpha1StorageVersionStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchInternalApiserverV1alpha1StorageVersionStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1IngressClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1IngressClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1IngressClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1IngressClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1IngressClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1IngressClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1IngressClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1IngressClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1IngressClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1IngressClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1IngressClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1IngressClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1IngressClassOK_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1IngressClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1IngressClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressCreated_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressOK_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedIngressStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedIngressStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedIngressStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedNetworkPolicyApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedNetworkPolicyApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedNetworkPolicyApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedNetworkPolicyApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedNetworkPolicyApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedNetworkPolicyApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedNetworkPolicyApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedNetworkPolicyApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedNetworkPolicyApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedNetworkPolicyCreated_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedNetworkPolicyCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedNetworkPolicyCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNetworkingV1NamespacedNetworkPolicyOK_EncodeDecode(t *testing.T) {
	var typ PatchNetworkingV1NamespacedNetworkPolicyOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNetworkingV1NamespacedNetworkPolicyOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1RuntimeClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1RuntimeClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1RuntimeClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1RuntimeClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1RuntimeClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1RuntimeClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1RuntimeClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1RuntimeClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1RuntimeClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1RuntimeClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1RuntimeClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1RuntimeClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1RuntimeClassOK_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1RuntimeClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1RuntimeClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1alpha1RuntimeClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1alpha1RuntimeClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1alpha1RuntimeClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1alpha1RuntimeClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1alpha1RuntimeClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1alpha1RuntimeClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1alpha1RuntimeClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1alpha1RuntimeClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1alpha1RuntimeClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1alpha1RuntimeClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1alpha1RuntimeClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1alpha1RuntimeClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1alpha1RuntimeClassOK_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1alpha1RuntimeClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1alpha1RuntimeClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1beta1RuntimeClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1beta1RuntimeClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1beta1RuntimeClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1beta1RuntimeClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1beta1RuntimeClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1beta1RuntimeClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1beta1RuntimeClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1beta1RuntimeClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1beta1RuntimeClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1beta1RuntimeClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1beta1RuntimeClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1beta1RuntimeClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchNodeV1beta1RuntimeClassOK_EncodeDecode(t *testing.T) {
	var typ PatchNodeV1beta1RuntimeClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchNodeV1beta1RuntimeClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetCreated_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetOK_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1NamespacedPodDisruptionBudgetStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1NamespacedPodDisruptionBudgetStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1NamespacedPodDisruptionBudgetStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetCreated_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetOK_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1NamespacedPodDisruptionBudgetStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1PodSecurityPolicyApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1PodSecurityPolicyApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1PodSecurityPolicyApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1PodSecurityPolicyApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1PodSecurityPolicyApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1PodSecurityPolicyApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1PodSecurityPolicyApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1PodSecurityPolicyApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1PodSecurityPolicyApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1PodSecurityPolicyCreated_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1PodSecurityPolicyCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1PodSecurityPolicyCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchPolicyV1beta1PodSecurityPolicyOK_EncodeDecode(t *testing.T) {
	var typ PatchPolicyV1beta1PodSecurityPolicyOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchPolicyV1beta1PodSecurityPolicyOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleBindingApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleBindingApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleBindingApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleBindingApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleBindingApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleBindingApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleBindingApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleBindingApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleBindingApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleBindingCreated_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleBindingCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleBindingCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleBindingOK_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleBindingOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleBindingOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleCreated_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1ClusterRoleOK_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1ClusterRoleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1ClusterRoleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleBindingApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleBindingApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleBindingApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleBindingApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleBindingApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleBindingApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleBindingApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleBindingApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleBindingApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleBindingCreated_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleBindingCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleBindingCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleBindingOK_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleBindingOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleBindingOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleCreated_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRbacAuthorizationV1NamespacedRoleOK_EncodeDecode(t *testing.T) {
	var typ PatchRbacAuthorizationV1NamespacedRoleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRbacAuthorizationV1NamespacedRoleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchSchedulingV1PriorityClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchSchedulingV1PriorityClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchSchedulingV1PriorityClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchSchedulingV1PriorityClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchSchedulingV1PriorityClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchSchedulingV1PriorityClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchSchedulingV1PriorityClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchSchedulingV1PriorityClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchSchedulingV1PriorityClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchSchedulingV1PriorityClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchSchedulingV1PriorityClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchSchedulingV1PriorityClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchSchedulingV1PriorityClassOK_EncodeDecode(t *testing.T) {
	var typ PatchSchedulingV1PriorityClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchSchedulingV1PriorityClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSIDriverApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSIDriverApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSIDriverApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSIDriverApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSIDriverApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSIDriverApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSIDriverApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSIDriverApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSIDriverApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSIDriverCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSIDriverCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSIDriverCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSIDriverOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSIDriverOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSIDriverOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSINodeApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSINodeApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSINodeApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSINodeApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSINodeApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSINodeApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSINodeApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSINodeApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSINodeApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSINodeCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSINodeCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSINodeCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1CSINodeOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1CSINodeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1CSINodeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1StorageClassApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1StorageClassApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1StorageClassApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1StorageClassApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1StorageClassApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1StorageClassApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1StorageClassApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1StorageClassApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1StorageClassApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1StorageClassCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1StorageClassCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1StorageClassCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1StorageClassOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1StorageClassOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1StorageClassOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentStatusApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentStatusApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentStatusApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentStatusApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentStatusApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentStatusApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentStatusApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentStatusApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentStatusApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentStatusCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentStatusCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentStatusCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1VolumeAttachmentStatusOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1VolumeAttachmentStatusOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1VolumeAttachmentStatusOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1alpha1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1alpha1NamespacedCSIStorageCapacityCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1alpha1NamespacedCSIStorageCapacityCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1alpha1NamespacedCSIStorageCapacityCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1alpha1NamespacedCSIStorageCapacityOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1alpha1NamespacedCSIStorageCapacityOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1alpha1NamespacedCSIStorageCapacityOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1beta1NamespacedCSIStorageCapacityApplicationJSONPatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationJSONPatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationJSONPatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1beta1NamespacedCSIStorageCapacityApplicationMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1beta1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1beta1NamespacedCSIStorageCapacityApplicationStrategicMergePatchJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1beta1NamespacedCSIStorageCapacityCreated_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1beta1NamespacedCSIStorageCapacityCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1beta1NamespacedCSIStorageCapacityCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchStorageV1beta1NamespacedCSIStorageCapacityOK_EncodeDecode(t *testing.T) {
	var typ PatchStorageV1beta1NamespacedCSIStorageCapacityOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchStorageV1beta1NamespacedCSIStorageCapacityOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadCoreV1NamespacedPodLogOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReadCoreV1NamespacedPodLogOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadCoreV1NamespacedPodLogOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
