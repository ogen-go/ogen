// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON as json.
func (s GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON from json.
func (s *GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceAccountIssuerOpenIDConfigurationOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admissionReviewVersions")
		e.ArrStart()
		for _, elem := range s.AdmissionReviewVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("clientConfig")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.FieldStart("failurePolicy")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.FieldStart("matchPolicy")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.FieldStart("objectSelector")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.ReinvocationPolicy.Set {
			e.FieldStart("reinvocationPolicy")
			s.ReinvocationPolicy.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("sideEffects")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.FieldStart("timeoutSeconds")
			s.TimeoutSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook = [11]string{
	0:  "admissionReviewVersions",
	1:  "clientConfig",
	2:  "failurePolicy",
	3:  "matchPolicy",
	4:  "name",
	5:  "namespaceSelector",
	6:  "objectSelector",
	7:  "reinvocationPolicy",
	8:  "rules",
	9:  "sideEffects",
	10: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdmissionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admissionReviewVersions\"")
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "failurePolicy":
			if err := func() error {
				s.FailurePolicy.Reset()
				if err := s.FailurePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failurePolicy\"")
			}
		case "matchPolicy":
			if err := func() error {
				s.MatchPolicy.Reset()
				if err := s.MatchPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchPolicy\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "objectSelector":
			if err := func() error {
				s.ObjectSelector.Reset()
				if err := s.ObjectSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectSelector\"")
			}
		case "reinvocationPolicy":
			if err := func() error {
				s.ReinvocationPolicy.Reset()
				if err := s.ReinvocationPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reinvocationPolicy\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIAdmissionregistrationV1RuleWithOperations, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SideEffects = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sideEffects\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			e.FieldStart("webhooks")
			e.ArrStart()
			for _, elem := range s.Webhooks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks = make([]IoK8sAPIAdmissionregistrationV1MutatingWebhook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1MutatingWebhook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Webhooks = append(s.Webhooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1MutatingWebhookConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1MutatingWebhookConfigurationList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroups != nil {
			e.FieldStart("apiGroups")
			e.ArrStart()
			for _, elem := range s.ApiGroups {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersions != nil {
			e.FieldStart("apiVersions")
			e.ArrStart()
			for _, elem := range s.ApiVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Operations != nil {
			e.FieldStart("operations")
			e.ArrStart()
			for _, elem := range s.Operations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1RuleWithOperations = [5]string{
	0: "apiGroups",
	1: "apiVersions",
	2: "operations",
	3: "resources",
	4: "scope",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1RuleWithOperations from json.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1RuleWithOperations to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "apiVersions":
			if err := func() error {
				s.ApiVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiVersions = append(s.ApiVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersions\"")
			}
		case "operations":
			if err := func() error {
				s.Operations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1RuleWithOperations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1RuleWithOperations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ServiceReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ServiceReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admissionReviewVersions")
		e.ArrStart()
		for _, elem := range s.AdmissionReviewVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("clientConfig")
		s.ClientConfig.Encode(e)
	}
	{
		if s.FailurePolicy.Set {
			e.FieldStart("failurePolicy")
			s.FailurePolicy.Encode(e)
		}
	}
	{
		if s.MatchPolicy.Set {
			e.FieldStart("matchPolicy")
			s.MatchPolicy.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.ObjectSelector.Set {
			e.FieldStart("objectSelector")
			s.ObjectSelector.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("sideEffects")
		e.Str(s.SideEffects)
	}
	{
		if s.TimeoutSeconds.Set {
			e.FieldStart("timeoutSeconds")
			s.TimeoutSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook = [10]string{
	0: "admissionReviewVersions",
	1: "clientConfig",
	2: "failurePolicy",
	3: "matchPolicy",
	4: "name",
	5: "namespaceSelector",
	6: "objectSelector",
	7: "rules",
	8: "sideEffects",
	9: "timeoutSeconds",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhook from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admissionReviewVersions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdmissionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdmissionReviewVersions = append(s.AdmissionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admissionReviewVersions\"")
			}
		case "clientConfig":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "failurePolicy":
			if err := func() error {
				s.FailurePolicy.Reset()
				if err := s.FailurePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failurePolicy\"")
			}
		case "matchPolicy":
			if err := func() error {
				s.MatchPolicy.Reset()
				if err := s.MatchPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchPolicy\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "objectSelector":
			if err := func() error {
				s.ObjectSelector.Reset()
				if err := s.ObjectSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectSelector\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIAdmissionregistrationV1RuleWithOperations, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1RuleWithOperations
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "sideEffects":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SideEffects = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sideEffects\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Webhooks != nil {
			e.FieldStart("webhooks")
			e.ArrStart()
			for _, elem := range s.Webhooks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "webhooks",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks = make([]IoK8sAPIAdmissionregistrationV1ValidatingWebhook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Webhooks = append(s.Webhooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList from json.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1ValidatingWebhookConfigurationList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("caBundle")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAdmissionregistrationV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sAPIAdmissionregistrationV1WebhookClientConfig from json.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAdmissionregistrationV1WebhookClientConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAdmissionregistrationV1WebhookClientConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAdmissionregistrationV1WebhookClientConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) encodeFields(e *jx.Encoder) {
	{
		if s.ApiServerID.Set {
			e.FieldStart("apiServerID")
			s.ApiServerID.Encode(e)
		}
	}
	{
		if s.DecodableVersions != nil {
			e.FieldStart("decodableVersions")
			e.ArrStart()
			for _, elem := range s.DecodableVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EncodingVersion.Set {
			e.FieldStart("encodingVersion")
			s.EncodingVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1ServerStorageVersion = [3]string{
	0: "apiServerID",
	1: "decodableVersions",
	2: "encodingVersion",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiServerID":
			if err := func() error {
				s.ApiServerID.Reset()
				if err := s.ApiServerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiServerID\"")
			}
		case "decodableVersions":
			if err := func() error {
				s.DecodableVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DecodableVersions = append(s.DecodableVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decodableVersions\"")
			}
		case "encodingVersion":
			if err := func() error {
				s.EncodingVersion.Reset()
				if err := s.EncodingVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodingVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersion from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionList from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIApiserverinternalV1alpha1StorageVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1StorageVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList) {
					name = jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionSpec = [0]string{}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) encodeFields(e *jx.Encoder) {
	{
		if s.CommonEncodingVersion.Set {
			e.FieldStart("commonEncodingVersion")
			s.CommonEncodingVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StorageVersions != nil {
			e.FieldStart("storageVersions")
			e.ArrStart()
			for _, elem := range s.StorageVersions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIApiserverinternalV1alpha1StorageVersionStatus = [3]string{
	0: "commonEncodingVersion",
	1: "conditions",
	2: "storageVersions",
}

// Decode decodes IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus from json.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commonEncodingVersion":
			if err := func() error {
				s.CommonEncodingVersion.Reset()
				if err := s.CommonEncodingVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commonEncodingVersion\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1StorageVersionCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "storageVersions":
			if err := func() error {
				s.StorageVersions = make([]IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIApiserverinternalV1alpha1ServerStorageVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StorageVersions = append(s.StorageVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIApiserverinternalV1alpha1StorageVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ControllerRevision) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ControllerRevision) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("revision")
		e.Int64(s.Revision)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision = [5]string{
	0: "apiVersion",
	1: "data",
	2: "kind",
	3: "metadata",
	4: "revision",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevision from json.
func (s *IoK8sAPIAppsV1ControllerRevision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ControllerRevision to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem IoK8sApimachineryPkgRuntimeRawExtension
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "revision":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Revision = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revision\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ControllerRevision")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevision[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ControllerRevision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ControllerRevision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ControllerRevisionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ControllerRevisionList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ControllerRevisionList from json.
func (s *IoK8sAPIAppsV1ControllerRevisionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ControllerRevisionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1ControllerRevision, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ControllerRevision
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ControllerRevisionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ControllerRevisionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ControllerRevisionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ControllerRevisionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSet) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1DaemonSet from json.
func (s *IoK8sAPIAppsV1DaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSetCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetCondition from json.
func (s *IoK8sAPIAppsV1DaemonSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSetCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSetList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetList from json.
func (s *IoK8sAPIAppsV1DaemonSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1DaemonSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DaemonSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSetSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MinReadySeconds.Set {
			e.FieldStart("minReadySeconds")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			e.FieldStart("revisionHistoryLimit")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		e.FieldStart("selector")
		s.Selector.Encode(e)
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.FieldStart("updateStrategy")
			s.UpdateStrategy.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec = [5]string{
	0: "minReadySeconds",
	1: "revisionHistoryLimit",
	2: "selector",
	3: "template",
	4: "updateStrategy",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (s *IoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "updateStrategy":
			if err := func() error {
				s.UpdateStrategy.Reset()
				if err := s.UpdateStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSetStatus) encodeFields(e *jx.Encoder) {
	{
		if s.CollisionCount.Set {
			e.FieldStart("collisionCount")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("currentNumberScheduled")
		e.Int32(s.CurrentNumberScheduled)
	}
	{
		e.FieldStart("desiredNumberScheduled")
		e.Int32(s.DesiredNumberScheduled)
	}
	{
		if s.NumberAvailable.Set {
			e.FieldStart("numberAvailable")
			s.NumberAvailable.Encode(e)
		}
	}
	{
		e.FieldStart("numberMisscheduled")
		e.Int32(s.NumberMisscheduled)
	}
	{
		e.FieldStart("numberReady")
		e.Int32(s.NumberReady)
	}
	{
		if s.NumberUnavailable.Set {
			e.FieldStart("numberUnavailable")
			s.NumberUnavailable.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.UpdatedNumberScheduled.Set {
			e.FieldStart("updatedNumberScheduled")
			s.UpdatedNumberScheduled.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus = [10]string{
	0: "collisionCount",
	1: "conditions",
	2: "currentNumberScheduled",
	3: "desiredNumberScheduled",
	4: "numberAvailable",
	5: "numberMisscheduled",
	6: "numberReady",
	7: "numberUnavailable",
	8: "observedGeneration",
	9: "updatedNumberScheduled",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (s *IoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1DaemonSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DaemonSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentNumberScheduled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentNumberScheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentNumberScheduled\"")
			}
		case "desiredNumberScheduled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredNumberScheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredNumberScheduled\"")
			}
		case "numberAvailable":
			if err := func() error {
				s.NumberAvailable.Reset()
				if err := s.NumberAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberAvailable\"")
			}
		case "numberMisscheduled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.NumberMisscheduled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberMisscheduled\"")
			}
		case "numberReady":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.NumberReady = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberReady\"")
			}
		case "numberUnavailable":
			if err := func() error {
				s.NumberUnavailable.Reset()
				if err := s.NumberUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberUnavailable\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "updatedNumberScheduled":
			if err := func() error {
				s.UpdatedNumberScheduled.Reset()
				if err := s.UpdatedNumberScheduled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedNumberScheduled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.RollingUpdate.Set {
			e.FieldStart("rollingUpdate")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DaemonSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DaemonSetUpdateStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DaemonSetUpdateStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DaemonSetUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1Deployment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1Deployment) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1Deployment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1Deployment from json.
func (s *IoK8sAPIAppsV1Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1Deployment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1Deployment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1Deployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1Deployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DeploymentCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			e.FieldStart("lastUpdateTime")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentCondition from json.
func (s *IoK8sAPIAppsV1DeploymentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "lastUpdateTime":
			if err := func() error {
				s.LastUpdateTime.Reset()
				if err := s.LastUpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdateTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DeploymentCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DeploymentList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1DeploymentList from json.
func (s *IoK8sAPIAppsV1DeploymentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1Deployment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1Deployment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DeploymentList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DeploymentSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MinReadySeconds.Set {
			e.FieldStart("minReadySeconds")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Paused.Set {
			e.FieldStart("paused")
			s.Paused.Encode(e)
		}
	}
	{
		if s.ProgressDeadlineSeconds.Set {
			e.FieldStart("progressDeadlineSeconds")
			s.ProgressDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			e.FieldStart("revisionHistoryLimit")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		e.FieldStart("selector")
		s.Selector.Encode(e)
	}
	{
		if s.Strategy.Set {
			e.FieldStart("strategy")
			s.Strategy.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec = [8]string{
	0: "minReadySeconds",
	1: "paused",
	2: "progressDeadlineSeconds",
	3: "replicas",
	4: "revisionHistoryLimit",
	5: "selector",
	6: "strategy",
	7: "template",
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (s *IoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "paused":
			if err := func() error {
				s.Paused.Reset()
				if err := s.Paused.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "progressDeadlineSeconds":
			if err := func() error {
				s.ProgressDeadlineSeconds.Reset()
				if err := s.ProgressDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressDeadlineSeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "strategy":
			if err := func() error {
				s.Strategy.Reset()
				if err := s.Strategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1DeploymentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DeploymentSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DeploymentStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AvailableReplicas.Set {
			e.FieldStart("availableReplicas")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.CollisionCount.Set {
			e.FieldStart("collisionCount")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.FieldStart("readyReplicas")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.UnavailableReplicas.Set {
			e.FieldStart("unavailableReplicas")
			s.UnavailableReplicas.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			e.FieldStart("updatedReplicas")
			s.UpdatedReplicas.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStatus = [8]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
	6: "unavailableReplicas",
	7: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (s *IoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1DeploymentCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1DeploymentCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "unavailableReplicas":
			if err := func() error {
				s.UnavailableReplicas.Reset()
				if err := s.UnavailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unavailableReplicas\"")
			}
		case "updatedReplicas":
			if err := func() error {
				s.UpdatedReplicas.Reset()
				if err := s.UpdatedReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedReplicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DeploymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1DeploymentStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.RollingUpdate.Set {
			e.FieldStart("rollingUpdate")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1DeploymentStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (s *IoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1DeploymentStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1DeploymentStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1DeploymentStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1DeploymentStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ReplicaSet) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSet from json.
func (s *IoK8sAPIAppsV1ReplicaSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ReplicaSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetCondition from json.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ReplicaSetCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ReplicaSetList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetList from json.
func (s *IoK8sAPIAppsV1ReplicaSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1ReplicaSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ReplicaSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ReplicaSetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MinReadySeconds.Set {
			e.FieldStart("minReadySeconds")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
	{
		e.FieldStart("selector")
		s.Selector.Encode(e)
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ReplicaSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AvailableReplicas.Set {
			e.FieldStart("availableReplicas")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			e.FieldStart("fullyLabeledReplicas")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.FieldStart("readyReplicas")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("replicas")
		e.Int32(s.Replicas)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1ReplicaSetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1ReplicaSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1ReplicaSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "fullyLabeledReplicas":
			if err := func() error {
				s.FullyLabeledReplicas.Reset()
				if err := s.FullyLabeledReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullyLabeledReplicas\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1ReplicaSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1ReplicaSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1ReplicaSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) encodeFields(e *jx.Encoder) {
	{
		if s.MaxSurge.Set {
			e.FieldStart("maxSurge")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			e.FieldStart("maxUnavailable")
			s.MaxUnavailable.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDaemonSet = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDaemonSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			if err := func() error {
				s.MaxSurge.Reset()
				if err := s.MaxSurge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSurge\"")
			}
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateDaemonSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDaemonSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) encodeFields(e *jx.Encoder) {
	{
		if s.MaxSurge.Set {
			e.FieldStart("maxSurge")
			s.MaxSurge.Encode(e)
		}
	}
	{
		if s.MaxUnavailable.Set {
			e.FieldStart("maxUnavailable")
			s.MaxUnavailable.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateDeployment = [2]string{
	0: "maxSurge",
	1: "maxUnavailable",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateDeployment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxSurge":
			if err := func() error {
				s.MaxSurge.Reset()
				if err := s.MaxSurge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSurge\"")
			}
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateDeployment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1RollingUpdateDeployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.Partition.Set {
			e.FieldStart("partition")
			s.Partition.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy = [1]string{
	0: "partition",
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSet) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSet = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAppsV1StatefulSet from json.
func (s *IoK8sAPIAppsV1StatefulSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSetCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetCondition from json.
func (s *IoK8sAPIAppsV1StatefulSetCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSetCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSetList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetList from json.
func (s *IoK8sAPIAppsV1StatefulSetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAppsV1StatefulSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1StatefulSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSetSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MinReadySeconds.Set {
			e.FieldStart("minReadySeconds")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.PodManagementPolicy.Set {
			e.FieldStart("podManagementPolicy")
			s.PodManagementPolicy.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.RevisionHistoryLimit.Set {
			e.FieldStart("revisionHistoryLimit")
			s.RevisionHistoryLimit.Encode(e)
		}
	}
	{
		e.FieldStart("selector")
		s.Selector.Encode(e)
	}
	{
		e.FieldStart("serviceName")
		e.Str(s.ServiceName)
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
	{
		if s.UpdateStrategy.Set {
			e.FieldStart("updateStrategy")
			s.UpdateStrategy.Encode(e)
		}
	}
	{
		if s.VolumeClaimTemplates != nil {
			e.FieldStart("volumeClaimTemplates")
			e.ArrStart()
			for _, elem := range s.VolumeClaimTemplates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec = [9]string{
	0: "minReadySeconds",
	1: "podManagementPolicy",
	2: "replicas",
	3: "revisionHistoryLimit",
	4: "selector",
	5: "serviceName",
	6: "template",
	7: "updateStrategy",
	8: "volumeClaimTemplates",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (s *IoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "podManagementPolicy":
			if err := func() error {
				s.PodManagementPolicy.Reset()
				if err := s.PodManagementPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podManagementPolicy\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "revisionHistoryLimit":
			if err := func() error {
				s.RevisionHistoryLimit.Reset()
				if err := s.RevisionHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionHistoryLimit\"")
			}
		case "selector":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "serviceName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ServiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceName\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "updateStrategy":
			if err := func() error {
				s.UpdateStrategy.Reset()
				if err := s.UpdateStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateStrategy\"")
			}
		case "volumeClaimTemplates":
			if err := func() error {
				s.VolumeClaimTemplates = make([]IoK8sAPICoreV1PersistentVolumeClaim, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaim
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeClaimTemplates = append(s.VolumeClaimTemplates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeClaimTemplates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSetStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("availableReplicas")
		e.Int32(s.AvailableReplicas)
	}
	{
		if s.CollisionCount.Set {
			e.FieldStart("collisionCount")
			s.CollisionCount.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CurrentReplicas.Set {
			e.FieldStart("currentReplicas")
			s.CurrentReplicas.Encode(e)
		}
	}
	{
		if s.CurrentRevision.Set {
			e.FieldStart("currentRevision")
			s.CurrentRevision.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.FieldStart("readyReplicas")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("replicas")
		e.Int32(s.Replicas)
	}
	{
		if s.UpdateRevision.Set {
			e.FieldStart("updateRevision")
			s.UpdateRevision.Encode(e)
		}
	}
	{
		if s.UpdatedReplicas.Set {
			e.FieldStart("updatedReplicas")
			s.UpdatedReplicas.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus = [10]string{
	0: "availableReplicas",
	1: "collisionCount",
	2: "conditions",
	3: "currentReplicas",
	4: "currentRevision",
	5: "observedGeneration",
	6: "readyReplicas",
	7: "replicas",
	8: "updateRevision",
	9: "updatedReplicas",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (s *IoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.AvailableReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "collisionCount":
			if err := func() error {
				s.CollisionCount.Reset()
				if err := s.CollisionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collisionCount\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAppsV1StatefulSetCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAppsV1StatefulSetCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentReplicas":
			if err := func() error {
				s.CurrentReplicas.Reset()
				if err := s.CurrentReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "currentRevision":
			if err := func() error {
				s.CurrentRevision.Reset()
				if err := s.CurrentRevision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentRevision\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "updateRevision":
			if err := func() error {
				s.UpdateRevision.Reset()
				if err := s.UpdateRevision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateRevision\"")
			}
		case "updatedReplicas":
			if err := func() error {
				s.UpdatedReplicas.Reset()
				if err := s.UpdatedReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedReplicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus) {
					name = jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.RollingUpdate.Set {
			e.FieldStart("rollingUpdate")
			s.RollingUpdate.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAppsV1StatefulSetUpdateStrategy = [2]string{
	0: "rollingUpdate",
	1: "type",
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAppsV1StatefulSetUpdateStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rollingUpdate":
			if err := func() error {
				s.RollingUpdate.Reset()
				if err := s.RollingUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rollingUpdate\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAppsV1StatefulSetUpdateStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAppsV1StatefulSetUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1CrossVersionObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscaler")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscaler) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV1HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV1HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxReplicas")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.MinReplicas.Set {
			e.FieldStart("minReplicas")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("scaleTargetRef")
		s.ScaleTargetRef.Encode(e)
	}
	{
		if s.TargetCPUUtilizationPercentage.Set {
			e.FieldStart("targetCPUUtilizationPercentage")
			s.TargetCPUUtilizationPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "minReplicas",
	2: "scaleTargetRef",
	3: "targetCPUUtilizationPercentage",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		case "targetCPUUtilizationPercentage":
			if err := func() error {
				s.TargetCPUUtilizationPercentage.Reset()
				if err := s.TargetCPUUtilizationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetCPUUtilizationPercentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentCPUUtilizationPercentage.Set {
			e.FieldStart("currentCPUUtilizationPercentage")
			s.CurrentCPUUtilizationPercentage.Encode(e)
		}
	}
	{
		e.FieldStart("currentReplicas")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.FieldStart("desiredReplicas")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.FieldStart("lastScaleTime")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus = [5]string{
	0: "currentCPUUtilizationPercentage",
	1: "currentReplicas",
	2: "desiredReplicas",
	3: "lastScaleTime",
	4: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentCPUUtilizationPercentage":
			if err := func() error {
				s.CurrentCPUUtilizationPercentage.Reset()
				if err := s.CurrentCPUUtilizationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentCPUUtilizationPercentage\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1Scale) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1Scale) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1Scale = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV1Scale from json.
func (s *IoK8sAPIAutoscalingV1Scale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1Scale to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1Scale")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1Scale) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1Scale) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleSpec = [1]string{
	0: "replicas",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1ScaleSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1ScaleSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1ScaleSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("replicas")
		e.Int32(s.Replicas)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus = [2]string{
	0: "replicas",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV1ScaleStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "replicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV1ScaleStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV1ScaleStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV1ScaleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("container")
		e.Str(s.Container)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.FieldStart("targetAverageUtilization")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.FieldStart("targetAverageValue")
			s.TargetAverageValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource = [4]string{
	0: "container",
	1: "name",
	2: "targetAverageUtilization",
	3: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "targetAverageUtilization":
			if err := func() error {
				s.TargetAverageUtilization.Reset()
				if err := s.TargetAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageUtilization\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("container")
		e.Str(s.Container)
	}
	{
		if s.CurrentAverageUtilization.Set {
			e.FieldStart("currentAverageUtilization")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		e.FieldStart("currentAverageValue")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus = [4]string{
	0: "container",
	1: "currentAverageUtilization",
	2: "currentAverageValue",
	3: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "currentAverageUtilization":
			if err := func() error {
				s.CurrentAverageUtilization.Reset()
				if err := s.CurrentAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageUtilization\"")
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1CrossVersionObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.FieldStart("metricSelector")
			s.MetricSelector.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.FieldStart("targetAverageValue")
			s.TargetAverageValue.Encode(e)
		}
	}
	{
		if s.TargetValue.Set {
			e.FieldStart("targetValue")
			s.TargetValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource = [4]string{
	0: "metricName",
	1: "metricSelector",
	2: "targetAverageValue",
	3: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "metricSelector":
			if err := func() error {
				s.MetricSelector.Reset()
				if err := s.MetricSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricSelector\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		case "targetValue":
			if err := func() error {
				s.TargetValue.Reset()
				if err := s.TargetValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ExternalMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentAverageValue.Set {
			e.FieldStart("currentAverageValue")
			s.CurrentAverageValue.Encode(e)
		}
	}
	{
		e.FieldStart("currentValue")
		s.CurrentValue.Encode(e)
	}
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.MetricSelector.Set {
			e.FieldStart("metricSelector")
			s.MetricSelector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus = [4]string{
	0: "currentAverageValue",
	1: "currentValue",
	2: "metricName",
	3: "metricSelector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			if err := func() error {
				s.CurrentAverageValue.Reset()
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "metricSelector":
			if err := func() error {
				s.MetricSelector.Reset()
				if err := s.MetricSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricSelector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ExternalMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ExternalMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxReplicas")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.FieldStart("metrics")
			e.ArrStart()
			for _, elem := range s.Metrics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.FieldStart("minReplicas")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("scaleTargetRef")
		s.ScaleTargetRef.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec = [4]string{
	0: "maxReplicas",
	1: "metrics",
	2: "minReplicas",
	3: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics = make([]IoK8sAPIAutoscalingV2beta1MetricSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1MetricSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.FieldStart("currentMetrics")
			e.ArrStart()
			for _, elem := range s.CurrentMetrics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("currentReplicas")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.FieldStart("desiredReplicas")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.FieldStart("lastScaleTime")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentMetrics":
			if err := func() error {
				s.CurrentMetrics = make([]IoK8sAPIAutoscalingV2beta1MetricStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta1MetricStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentMetrics = append(s.CurrentMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMetrics\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerResource.Set {
			e.FieldStart("containerResource")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			e.FieldStart("external")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			e.FieldStart("pods")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1MetricSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerResource.Set {
			e.FieldStart("containerResource")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			e.FieldStart("external")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			e.FieldStart("pods")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1MetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1MetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1MetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) encodeFields(e *jx.Encoder) {
	{
		if s.AverageValue.Set {
			e.FieldStart("averageValue")
			s.AverageValue.Encode(e)
		}
	}
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	{
		e.FieldStart("targetValue")
		s.TargetValue.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource = [5]string{
	0: "averageValue",
	1: "metricName",
	2: "selector",
	3: "target",
	4: "targetValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "targetValue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TargetValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ObjectMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AverageValue.Set {
			e.FieldStart("averageValue")
			s.AverageValue.Encode(e)
		}
	}
	{
		e.FieldStart("currentValue")
		s.CurrentValue.Encode(e)
	}
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus = [5]string{
	0: "averageValue",
	1: "currentValue",
	2: "metricName",
	3: "selector",
	4: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "currentValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ObjectMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ObjectMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		e.FieldStart("targetAverageValue")
		s.TargetAverageValue.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource = [3]string{
	0: "metricName",
	1: "selector",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metricName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "targetAverageValue":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1PodsMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currentAverageValue")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.FieldStart("metricName")
		e.Str(s.MetricName)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus = [3]string{
	0: "currentAverageValue",
	1: "metricName",
	2: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "metricName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MetricName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricName\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1PodsMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1PodsMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.TargetAverageUtilization.Set {
			e.FieldStart("targetAverageUtilization")
			s.TargetAverageUtilization.Encode(e)
		}
	}
	{
		if s.TargetAverageValue.Set {
			e.FieldStart("targetAverageValue")
			s.TargetAverageValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource = [3]string{
	0: "name",
	1: "targetAverageUtilization",
	2: "targetAverageValue",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "targetAverageUtilization":
			if err := func() error {
				s.TargetAverageUtilization.Reset()
				if err := s.TargetAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageUtilization\"")
			}
		case "targetAverageValue":
			if err := func() error {
				s.TargetAverageValue.Reset()
				if err := s.TargetAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAverageValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentAverageUtilization.Set {
			e.FieldStart("currentAverageUtilization")
			s.CurrentAverageUtilization.Encode(e)
		}
	}
	{
		e.FieldStart("currentAverageValue")
		s.CurrentAverageValue.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus = [3]string{
	0: "currentAverageUtilization",
	1: "currentAverageValue",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentAverageUtilization":
			if err := func() error {
				s.CurrentAverageUtilization.Reset()
				if err := s.CurrentAverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageUtilization\"")
			}
		case "currentAverageValue":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CurrentAverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentAverageValue\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta1ResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta1ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta1ResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("container")
		e.Str(s.Container)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource = [3]string{
	0: "container",
	1: "name",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("container")
		e.Str(s.Container)
	}
	{
		e.FieldStart("current")
		s.Current.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus = [3]string{
	0: "container",
	1: "current",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Container = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference = [3]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference from json.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2CrossVersionObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2CrossVersionObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ExternalMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		s.Current.Encode(e)
	}
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ExternalMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ExternalMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ExternalMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("periodSeconds")
		e.Int32(s.PeriodSeconds)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("value")
		e.Int32(s.Value)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy = [3]string{
	0: "periodSeconds",
	1: "type",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingPolicy from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "periodSeconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PeriodSeconds = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"periodSeconds\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Value = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HPAScalingPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) encodeFields(e *jx.Encoder) {
	{
		if s.Policies != nil {
			e.FieldStart("policies")
			e.ArrStart()
			for _, elem := range s.Policies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SelectPolicy.Set {
			e.FieldStart("selectPolicy")
			s.SelectPolicy.Encode(e)
		}
	}
	{
		if s.StabilizationWindowSeconds.Set {
			e.FieldStart("stabilizationWindowSeconds")
			s.StabilizationWindowSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HPAScalingRules = [3]string{
	0: "policies",
	1: "selectPolicy",
	2: "stabilizationWindowSeconds",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HPAScalingRules to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "policies":
			if err := func() error {
				s.Policies = make([]IoK8sAPIAutoscalingV2beta2HPAScalingPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HPAScalingPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Policies = append(s.Policies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policies\"")
			}
		case "selectPolicy":
			if err := func() error {
				s.SelectPolicy.Reset()
				if err := s.SelectPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selectPolicy\"")
			}
		case "stabilizationWindowSeconds":
			if err := func() error {
				s.StabilizationWindowSeconds.Reset()
				if err := s.StabilizationWindowSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stabilizationWindowSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HPAScalingRules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HPAScalingRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) encodeFields(e *jx.Encoder) {
	{
		if s.ScaleDown.Set {
			e.FieldStart("scaleDown")
			s.ScaleDown.Encode(e)
		}
	}
	{
		if s.ScaleUp.Set {
			e.FieldStart("scaleUp")
			s.ScaleUp.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior = [2]string{
	0: "scaleDown",
	1: "scaleUp",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scaleDown":
			if err := func() error {
				s.ScaleDown.Reset()
				if err := s.ScaleDown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleDown\"")
			}
		case "scaleUp":
			if err := func() error {
				s.ScaleUp.Reset()
				if err := s.ScaleUp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleUp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscaler
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Behavior.Set {
			e.FieldStart("behavior")
			s.Behavior.Encode(e)
		}
	}
	{
		e.FieldStart("maxReplicas")
		e.Int32(s.MaxReplicas)
	}
	{
		if s.Metrics != nil {
			e.FieldStart("metrics")
			e.ArrStart()
			for _, elem := range s.Metrics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MinReplicas.Set {
			e.FieldStart("minReplicas")
			s.MinReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("scaleTargetRef")
		s.ScaleTargetRef.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec = [5]string{
	0: "behavior",
	1: "maxReplicas",
	2: "metrics",
	3: "minReplicas",
	4: "scaleTargetRef",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "behavior":
			if err := func() error {
				s.Behavior.Reset()
				if err := s.Behavior.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behavior\"")
			}
		case "maxReplicas":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxReplicas\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics = make([]IoK8sAPIAutoscalingV2beta2MetricSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2MetricSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "minReplicas":
			if err := func() error {
				s.MinReplicas.Reset()
				if err := s.MinReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReplicas\"")
			}
		case "scaleTargetRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ScaleTargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleTargetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.CurrentMetrics != nil {
			e.FieldStart("currentMetrics")
			e.ArrStart()
			for _, elem := range s.CurrentMetrics {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("currentReplicas")
		e.Int32(s.CurrentReplicas)
	}
	{
		e.FieldStart("desiredReplicas")
		e.Int32(s.DesiredReplicas)
	}
	{
		if s.LastScaleTime.Set {
			e.FieldStart("lastScaleTime")
			s.LastScaleTime.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus = [6]string{
	0: "conditions",
	1: "currentMetrics",
	2: "currentReplicas",
	3: "desiredReplicas",
	4: "lastScaleTime",
	5: "observedGeneration",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Conditions = make([]IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentMetrics":
			if err := func() error {
				s.CurrentMetrics = make([]IoK8sAPIAutoscalingV2beta2MetricStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIAutoscalingV2beta2MetricStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentMetrics = append(s.CurrentMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMetrics\"")
			}
		case "currentReplicas":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CurrentReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentReplicas\"")
			}
		case "desiredReplicas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DesiredReplicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredReplicas\"")
			}
		case "lastScaleTime":
			if err := func() error {
				s.LastScaleTime.Reset()
				if err := s.LastScaleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScaleTime\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier = [2]string{
	0: "name",
	1: "selector",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricIdentifier from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerResource.Set {
			e.FieldStart("containerResource")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			e.FieldStart("external")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			e.FieldStart("pods")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricSpec from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerResource.Set {
			e.FieldStart("containerResource")
			s.ContainerResource.Encode(e)
		}
	}
	{
		if s.External.Set {
			e.FieldStart("external")
			s.External.Encode(e)
		}
	}
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		if s.Pods.Set {
			e.FieldStart("pods")
			s.Pods.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus = [6]string{
	0: "containerResource",
	1: "external",
	2: "object",
	3: "pods",
	4: "resource",
	5: "type",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerResource":
			if err := func() error {
				s.ContainerResource.Reset()
				if err := s.ContainerResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerResource\"")
			}
		case "external":
			if err := func() error {
				s.External.Reset()
				if err := s.External.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external\"")
			}
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "pods":
			if err := func() error {
				s.Pods.Reset()
				if err := s.Pods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pods\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) encodeFields(e *jx.Encoder) {
	{
		if s.AverageUtilization.Set {
			e.FieldStart("averageUtilization")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			e.FieldStart("averageValue")
			s.AverageValue.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget = [4]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "type",
	3: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricTarget from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricTarget to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			if err := func() error {
				s.AverageUtilization.Reset()
				if err := s.AverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageUtilization\"")
			}
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricTarget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricTarget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AverageUtilization.Set {
			e.FieldStart("averageUtilization")
			s.AverageUtilization.Encode(e)
		}
	}
	{
		if s.AverageValue.Set {
			e.FieldStart("averageValue")
			s.AverageValue.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2MetricValueStatus = [3]string{
	0: "averageUtilization",
	1: "averageValue",
	2: "value",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2MetricValueStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2MetricValueStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageUtilization":
			if err := func() error {
				s.AverageUtilization.Reset()
				if err := s.AverageUtilization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageUtilization\"")
			}
		case "averageValue":
			if err := func() error {
				s.AverageValue.Reset()
				if err := s.AverageValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageValue\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2MetricValueStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2MetricValueStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("describedObject")
		s.DescribedObject.Encode(e)
	}
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource = [3]string{
	0: "describedObject",
	1: "metric",
	2: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "describedObject":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DescribedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"describedObject\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ObjectMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		s.Current.Encode(e)
	}
	{
		e.FieldStart("describedObject")
		s.DescribedObject.Encode(e)
	}
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus = [3]string{
	0: "current",
	1: "describedObject",
	2: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "describedObject":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DescribedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"describedObject\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ObjectMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ObjectMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ObjectMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource = [2]string{
	0: "metric",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2PodsMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		s.Current.Encode(e)
	}
	{
		e.FieldStart("metric")
		s.Metric.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus = [2]string{
	0: "current",
	1: "metric",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "metric":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Metric.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2PodsMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2PodsMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2PodsMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource = [2]string{
	0: "name",
	1: "target",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ResourceMetricSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		s.Current.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus = [2]string{
	0: "current",
	1: "name",
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIAutoscalingV2beta2ResourceMetricStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) {
					name = jsonFieldsNameOfIoK8sAPIAutoscalingV2beta2ResourceMetricStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIAutoscalingV2beta2ResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1CronJob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1CronJob) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1CronJob from json.
func (s *IoK8sAPIBatchV1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJob to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJob")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1CronJob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1CronJob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1CronJobList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1CronJobList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1CronJobList from json.
func (s *IoK8sAPIBatchV1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1CronJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1CronJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1CronJobList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1CronJobList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1CronJobSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ConcurrencyPolicy.Set {
			e.FieldStart("concurrencyPolicy")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			e.FieldStart("failedJobsHistoryLimit")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		e.FieldStart("jobTemplate")
		s.JobTemplate.Encode(e)
	}
	{
		e.FieldStart("schedule")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.FieldStart("startingDeadlineSeconds")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.FieldStart("successfulJobsHistoryLimit")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.FieldStart("suspend")
			s.Suspend.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (s *IoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			if err := func() error {
				s.ConcurrencyPolicy.Reset()
				if err := s.ConcurrencyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrencyPolicy\"")
			}
		case "failedJobsHistoryLimit":
			if err := func() error {
				s.FailedJobsHistoryLimit.Reset()
				if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedJobsHistoryLimit\"")
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.JobTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobTemplate\"")
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Schedule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "startingDeadlineSeconds":
			if err := func() error {
				s.StartingDeadlineSeconds.Reset()
				if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingDeadlineSeconds\"")
			}
		case "successfulJobsHistoryLimit":
			if err := func() error {
				s.SuccessfulJobsHistoryLimit.Reset()
				if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulJobsHistoryLimit\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1CronJobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1CronJobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1CronJobStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Active != nil {
			e.FieldStart("active")
			e.ArrStart()
			for _, elem := range s.Active {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			e.FieldStart("lastScheduleTime")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			e.FieldStart("lastSuccessfulTime")
			s.LastSuccessfulTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (s *IoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1CronJobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Active = append(s.Active, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "lastScheduleTime":
			if err := func() error {
				s.LastScheduleTime.Reset()
				if err := s.LastScheduleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScheduleTime\"")
			}
		case "lastSuccessfulTime":
			if err := func() error {
				s.LastSuccessfulTime.Reset()
				if err := s.LastSuccessfulTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSuccessfulTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1CronJobStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1CronJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1CronJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1Job) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1Job) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1Job = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1Job from json.
func (s *IoK8sAPIBatchV1Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1Job to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1Job")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1Job) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1Job) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1JobCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1JobCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastProbeTime.Set {
			e.FieldStart("lastProbeTime")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPIBatchV1JobCondition from json.
func (s *IoK8sAPIBatchV1JobCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobCondition) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1JobCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1JobCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1JobList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1JobList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1JobList from json.
func (s *IoK8sAPIBatchV1JobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1Job, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1Job
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1JobList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1JobList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1JobSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1JobSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveDeadlineSeconds.Set {
			e.FieldStart("activeDeadlineSeconds")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.BackoffLimit.Set {
			e.FieldStart("backoffLimit")
			s.BackoffLimit.Encode(e)
		}
	}
	{
		if s.CompletionMode.Set {
			e.FieldStart("completionMode")
			s.CompletionMode.Encode(e)
		}
	}
	{
		if s.Completions.Set {
			e.FieldStart("completions")
			s.Completions.Encode(e)
		}
	}
	{
		if s.ManualSelector.Set {
			e.FieldStart("manualSelector")
			s.ManualSelector.Encode(e)
		}
	}
	{
		if s.Parallelism.Set {
			e.FieldStart("parallelism")
			s.Parallelism.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.FieldStart("suspend")
			s.Suspend.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		s.Template.Encode(e)
	}
	{
		if s.TtlSecondsAfterFinished.Set {
			e.FieldStart("ttlSecondsAfterFinished")
			s.TtlSecondsAfterFinished.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobSpec = [10]string{
	0: "activeDeadlineSeconds",
	1: "backoffLimit",
	2: "completionMode",
	3: "completions",
	4: "manualSelector",
	5: "parallelism",
	6: "selector",
	7: "suspend",
	8: "template",
	9: "ttlSecondsAfterFinished",
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (s *IoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobSpec to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			if err := func() error {
				s.ActiveDeadlineSeconds.Reset()
				if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeDeadlineSeconds\"")
			}
		case "backoffLimit":
			if err := func() error {
				s.BackoffLimit.Reset()
				if err := s.BackoffLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backoffLimit\"")
			}
		case "completionMode":
			if err := func() error {
				s.CompletionMode.Reset()
				if err := s.CompletionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionMode\"")
			}
		case "completions":
			if err := func() error {
				s.Completions.Reset()
				if err := s.Completions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completions\"")
			}
		case "manualSelector":
			if err := func() error {
				s.ManualSelector.Reset()
				if err := s.ManualSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manualSelector\"")
			}
		case "parallelism":
			if err := func() error {
				s.Parallelism.Reset()
				if err := s.Parallelism.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelism\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		case "template":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "ttlSecondsAfterFinished":
			if err := func() error {
				s.TtlSecondsAfterFinished.Reset()
				if err := s.TtlSecondsAfterFinished.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttlSecondsAfterFinished\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1JobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1JobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1JobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1JobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1JobStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1JobStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.CompletedIndexes.Set {
			e.FieldStart("completedIndexes")
			s.CompletedIndexes.Encode(e)
		}
	}
	{
		if s.CompletionTime.Set {
			e.FieldStart("completionTime")
			s.CompletionTime.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Failed.Set {
			e.FieldStart("failed")
			s.Failed.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("startTime")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Succeeded.Set {
			e.FieldStart("succeeded")
			s.Succeeded.Encode(e)
		}
	}
	{
		if s.UncountedTerminatedPods.Set {
			e.FieldStart("uncountedTerminatedPods")
			s.UncountedTerminatedPods.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobStatus = [8]string{
	0: "active",
	1: "completedIndexes",
	2: "completionTime",
	3: "conditions",
	4: "failed",
	5: "startTime",
	6: "succeeded",
	7: "uncountedTerminatedPods",
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (s *IoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "completedIndexes":
			if err := func() error {
				s.CompletedIndexes.Reset()
				if err := s.CompletedIndexes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedIndexes\"")
			}
		case "completionTime":
			if err := func() error {
				s.CompletionTime.Reset()
				if err := s.CompletionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionTime\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIBatchV1JobCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1JobCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "failed":
			if err := func() error {
				s.Failed.Reset()
				if err := s.Failed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "succeeded":
			if err := func() error {
				s.Succeeded.Reset()
				if err := s.Succeeded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"succeeded\"")
			}
		case "uncountedTerminatedPods":
			if err := func() error {
				s.UncountedTerminatedPods.Reset()
				if err := s.UncountedTerminatedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uncountedTerminatedPods\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1JobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1JobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1JobTemplateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1JobTemplateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1JobTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1JobTemplateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1JobTemplateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1JobTemplateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) encodeFields(e *jx.Encoder) {
	{
		if s.Failed != nil {
			e.FieldStart("failed")
			e.ArrStart()
			for _, elem := range s.Failed {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Succeeded != nil {
			e.FieldStart("succeeded")
			e.ArrStart()
			for _, elem := range s.Succeeded {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1UncountedTerminatedPods = [2]string{
	0: "failed",
	1: "succeeded",
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1UncountedTerminatedPods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failed":
			if err := func() error {
				s.Failed = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Failed = append(s.Failed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed\"")
			}
		case "succeeded":
			if err := func() error {
				s.Succeeded = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Succeeded = append(s.Succeeded, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"succeeded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1UncountedTerminatedPods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1UncountedTerminatedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1beta1CronJob) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJob = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJob from json.
func (s *IoK8sAPIBatchV1beta1CronJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJob to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJob")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1beta1CronJob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1beta1CronJobList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobList from json.
func (s *IoK8sAPIBatchV1beta1CronJobList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIBatchV1beta1CronJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIBatchV1beta1CronJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1beta1CronJobList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ConcurrencyPolicy.Set {
			e.FieldStart("concurrencyPolicy")
			s.ConcurrencyPolicy.Encode(e)
		}
	}
	{
		if s.FailedJobsHistoryLimit.Set {
			e.FieldStart("failedJobsHistoryLimit")
			s.FailedJobsHistoryLimit.Encode(e)
		}
	}
	{
		e.FieldStart("jobTemplate")
		s.JobTemplate.Encode(e)
	}
	{
		e.FieldStart("schedule")
		e.Str(s.Schedule)
	}
	{
		if s.StartingDeadlineSeconds.Set {
			e.FieldStart("startingDeadlineSeconds")
			s.StartingDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.SuccessfulJobsHistoryLimit.Set {
			e.FieldStart("successfulJobsHistoryLimit")
			s.SuccessfulJobsHistoryLimit.Encode(e)
		}
	}
	{
		if s.Suspend.Set {
			e.FieldStart("suspend")
			s.Suspend.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec = [7]string{
	0: "concurrencyPolicy",
	1: "failedJobsHistoryLimit",
	2: "jobTemplate",
	3: "schedule",
	4: "startingDeadlineSeconds",
	5: "successfulJobsHistoryLimit",
	6: "suspend",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrencyPolicy":
			if err := func() error {
				s.ConcurrencyPolicy.Reset()
				if err := s.ConcurrencyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrencyPolicy\"")
			}
		case "failedJobsHistoryLimit":
			if err := func() error {
				s.FailedJobsHistoryLimit.Reset()
				if err := s.FailedJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedJobsHistoryLimit\"")
			}
		case "jobTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.JobTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobTemplate\"")
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Schedule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		case "startingDeadlineSeconds":
			if err := func() error {
				s.StartingDeadlineSeconds.Reset()
				if err := s.StartingDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingDeadlineSeconds\"")
			}
		case "successfulJobsHistoryLimit":
			if err := func() error {
				s.SuccessfulJobsHistoryLimit.Reset()
				if err := s.SuccessfulJobsHistoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfulJobsHistoryLimit\"")
			}
		case "suspend":
			if err := func() error {
				s.Suspend.Reset()
				if err := s.Suspend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec) {
					name = jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1beta1CronJobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Active != nil {
			e.FieldStart("active")
			e.ArrStart()
			for _, elem := range s.Active {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastScheduleTime.Set {
			e.FieldStart("lastScheduleTime")
			s.LastScheduleTime.Encode(e)
		}
	}
	{
		if s.LastSuccessfulTime.Set {
			e.FieldStart("lastSuccessfulTime")
			s.LastSuccessfulTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1CronJobStatus = [3]string{
	0: "active",
	1: "lastScheduleTime",
	2: "lastSuccessfulTime",
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1CronJobStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Active = append(s.Active, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "lastScheduleTime":
			if err := func() error {
				s.LastScheduleTime.Reset()
				if err := s.LastScheduleTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastScheduleTime\"")
			}
		case "lastSuccessfulTime":
			if err := func() error {
				s.LastSuccessfulTime.Reset()
				if err := s.LastSuccessfulTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSuccessfulTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1CronJobStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1beta1CronJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIBatchV1beta1JobTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPIBatchV1beta1JobTemplateSpec from json.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIBatchV1beta1JobTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIBatchV1beta1JobTemplateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIBatchV1beta1JobTemplateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequest from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.LastUpdateTime.Set {
			e.FieldStart("lastUpdateTime")
			s.LastUpdateTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition = [6]string{
	0: "lastTransitionTime",
	1: "lastUpdateTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestCondition from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "lastUpdateTime":
			if err := func() error {
				s.LastUpdateTime.Reset()
				if err := s.LastUpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdateTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestList from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICertificatesV1CertificateSigningRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICertificatesV1CertificateSigningRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ExpirationSeconds.Set {
			e.FieldStart("expirationSeconds")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		if s.Extra.Set {
			e.FieldStart("extra")
			s.Extra.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("request")
		e.Base64(s.Request)
	}
	{
		e.FieldStart("signerName")
		e.Str(s.SignerName)
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.Usages != nil {
			e.FieldStart("usages")
			e.ArrStart()
			for _, elem := range s.Usages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec = [8]string{
	0: "expirationSeconds",
	1: "extra",
	2: "groups",
	3: "request",
	4: "signerName",
	5: "uid",
	6: "usages",
	7: "username",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpec from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		case "extra":
			if err := func() error {
				s.Extra.Reset()
				if err := s.Extra.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extra\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "request":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Base64()
				s.Request = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "signerName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SignerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signerName\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "usages":
			if err := func() error {
				s.Usages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Usages = append(s.Usages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usages\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec) {
					name = jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("certificate")
		e.Base64(s.Certificate)
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICertificatesV1CertificateSigningRequestStatus = [2]string{
	0: "certificate",
	1: "conditions",
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICertificatesV1CertificateSigningRequestStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				v, err := d.Base64()
				s.Certificate = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICertificatesV1CertificateSigningRequestCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICertificatesV1CertificateSigningRequestCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICertificatesV1CertificateSigningRequestStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICertificatesV1CertificateSigningRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoordinationV1Lease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoordinationV1Lease) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoordinationV1Lease = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoordinationV1Lease from json.
func (s *IoK8sAPICoordinationV1Lease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1Lease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1Lease")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoordinationV1Lease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoordinationV1Lease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoordinationV1LeaseList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoordinationV1LeaseList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoordinationV1LeaseList from json.
func (s *IoK8sAPICoordinationV1LeaseList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1LeaseList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoordinationV1Lease, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoordinationV1Lease
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1LeaseList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList) {
					name = jsonFieldsNameOfIoK8sAPICoordinationV1LeaseList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoordinationV1LeaseList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoordinationV1LeaseList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoordinationV1LeaseSpec) encodeFields(e *jx.Encoder) {
	{
		if s.AcquireTime.Set {
			e.FieldStart("acquireTime")
			s.AcquireTime.Encode(e)
		}
	}
	{
		if s.HolderIdentity.Set {
			e.FieldStart("holderIdentity")
			s.HolderIdentity.Encode(e)
		}
	}
	{
		if s.LeaseDurationSeconds.Set {
			e.FieldStart("leaseDurationSeconds")
			s.LeaseDurationSeconds.Encode(e)
		}
	}
	{
		if s.LeaseTransitions.Set {
			e.FieldStart("leaseTransitions")
			s.LeaseTransitions.Encode(e)
		}
	}
	{
		if s.RenewTime.Set {
			e.FieldStart("renewTime")
			s.RenewTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoordinationV1LeaseSpec = [5]string{
	0: "acquireTime",
	1: "holderIdentity",
	2: "leaseDurationSeconds",
	3: "leaseTransitions",
	4: "renewTime",
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (s *IoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoordinationV1LeaseSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acquireTime":
			if err := func() error {
				s.AcquireTime.Reset()
				if err := s.AcquireTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acquireTime\"")
			}
		case "holderIdentity":
			if err := func() error {
				s.HolderIdentity.Reset()
				if err := s.HolderIdentity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"holderIdentity\"")
			}
		case "leaseDurationSeconds":
			if err := func() error {
				s.LeaseDurationSeconds.Reset()
				if err := s.LeaseDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaseDurationSeconds\"")
			}
		case "leaseTransitions":
			if err := func() error {
				s.LeaseTransitions.Reset()
				if err := s.LeaseTransitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaseTransitions\"")
			}
		case "renewTime":
			if err := func() error {
				s.RenewTime.Reset()
				if err := s.RenewTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"renewTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoordinationV1LeaseSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoordinationV1LeaseSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoordinationV1LeaseSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			e.FieldStart("partition")
			s.Partition.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("volumeID")
		e.Str(s.VolumeID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "readOnly",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Affinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Affinity) encodeFields(e *jx.Encoder) {
	{
		if s.NodeAffinity.Set {
			e.FieldStart("nodeAffinity")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PodAffinity.Set {
			e.FieldStart("podAffinity")
			s.PodAffinity.Encode(e)
		}
	}
	{
		if s.PodAntiAffinity.Set {
			e.FieldStart("podAntiAffinity")
			s.PodAntiAffinity.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Affinity = [3]string{
	0: "nodeAffinity",
	1: "podAffinity",
	2: "podAntiAffinity",
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (s *IoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Affinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "podAffinity":
			if err := func() error {
				s.PodAffinity.Reset()
				if err := s.PodAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinity\"")
			}
		case "podAntiAffinity":
			if err := func() error {
				s.PodAntiAffinity.Reset()
				if err := s.PodAntiAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAntiAffinity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Affinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Affinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Affinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1AttachedVolume) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1AttachedVolume) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("devicePath")
		e.Str(s.DevicePath)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1AttachedVolume from json.
func (s *IoK8sAPICoreV1AttachedVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AttachedVolume to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DevicePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devicePath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AttachedVolume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AttachedVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1AttachedVolume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1AttachedVolume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.CachingMode.Set {
			e.FieldStart("cachingMode")
			s.CachingMode.Encode(e)
		}
	}
	{
		e.FieldStart("diskName")
		e.Str(s.DiskName)
	}
	{
		e.FieldStart("diskURI")
		e.Str(s.DiskURI)
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource = [6]string{
	0: "cachingMode",
	1: "diskName",
	2: "diskURI",
	3: "fsType",
	4: "kind",
	5: "readOnly",
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cachingMode":
			if err := func() error {
				s.CachingMode.Reset()
				if err := s.CachingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cachingMode\"")
			}
		case "diskName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DiskName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskName\"")
			}
		case "diskURI":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DiskURI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskURI\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1AzureDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("secretName")
		e.Str(s.SecretName)
	}
	{
		if s.SecretNamespace.Set {
			e.FieldStart("secretNamespace")
			s.SecretNamespace.Encode(e)
		}
	}
	{
		e.FieldStart("shareName")
		e.Str(s.ShareName)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource = [4]string{
	0: "readOnly",
	1: "secretName",
	2: "secretNamespace",
	3: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureFilePersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		case "secretNamespace":
			if err := func() error {
				s.SecretNamespace.Reset()
				if err := s.SecretNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretNamespace\"")
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ShareName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureFilePersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFilePersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1AzureFilePersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("secretName")
		e.Str(s.SecretName)
	}
	{
		e.FieldStart("shareName")
		e.Str(s.ShareName)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource = [3]string{
	0: "readOnly",
	1: "secretName",
	2: "shareName",
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1AzureFileVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		case "shareName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShareName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1AzureFileVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1AzureFileVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1AzureFileVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.ControllerExpandSecretRef.Set {
			e.FieldStart("controllerExpandSecretRef")
			s.ControllerExpandSecretRef.Encode(e)
		}
	}
	{
		if s.ControllerPublishSecretRef.Set {
			e.FieldStart("controllerPublishSecretRef")
			s.ControllerPublishSecretRef.Encode(e)
		}
	}
	{
		e.FieldStart("driver")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.FieldStart("nodePublishSecretRef")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.NodeStageSecretRef.Set {
			e.FieldStart("nodeStageSecretRef")
			s.NodeStageSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.FieldStart("volumeAttributes")
			s.VolumeAttributes.Encode(e)
		}
	}
	{
		e.FieldStart("volumeHandle")
		e.Str(s.VolumeHandle)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource = [9]string{
	0: "controllerExpandSecretRef",
	1: "controllerPublishSecretRef",
	2: "driver",
	3: "fsType",
	4: "nodePublishSecretRef",
	5: "nodeStageSecretRef",
	6: "readOnly",
	7: "volumeAttributes",
	8: "volumeHandle",
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controllerExpandSecretRef":
			if err := func() error {
				s.ControllerExpandSecretRef.Reset()
				if err := s.ControllerExpandSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllerExpandSecretRef\"")
			}
		case "controllerPublishSecretRef":
			if err := func() error {
				s.ControllerPublishSecretRef.Reset()
				if err := s.ControllerPublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllerPublishSecretRef\"")
			}
		case "driver":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "nodePublishSecretRef":
			if err := func() error {
				s.NodePublishSecretRef.Reset()
				if err := s.NodePublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePublishSecretRef\"")
			}
		case "nodeStageSecretRef":
			if err := func() error {
				s.NodeStageSecretRef.Reset()
				if err := s.NodeStageSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeStageSecretRef\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeAttributes":
			if err := func() error {
				s.VolumeAttributes.Reset()
				if err := s.VolumeAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeAttributes\"")
			}
		case "volumeHandle":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VolumeHandle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeHandle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes from json.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CSIVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("driver")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.NodePublishSecretRef.Set {
			e.FieldStart("nodePublishSecretRef")
			s.NodePublishSecretRef.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.VolumeAttributes.Set {
			e.FieldStart("volumeAttributes")
			s.VolumeAttributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "nodePublishSecretRef",
	3: "readOnly",
	4: "volumeAttributes",
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (s *IoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "nodePublishSecretRef":
			if err := func() error {
				s.NodePublishSecretRef.Reset()
				if err := s.NodePublishSecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePublishSecretRef\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeAttributes":
			if err := func() error {
				s.VolumeAttributes.Reset()
				if err := s.VolumeAttributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeAttributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CSIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CSIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes from json.
func (s *IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Capabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Capabilities) encodeFields(e *jx.Encoder) {
	{
		if s.Add != nil {
			e.FieldStart("add")
			e.ArrStart()
			for _, elem := range s.Add {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Drop != nil {
			e.FieldStart("drop")
			e.ArrStart()
			for _, elem := range s.Drop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Capabilities = [2]string{
	0: "add",
	1: "drop",
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (s *IoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Capabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "add":
			if err := func() error {
				s.Add = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Add = append(s.Add, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Capabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Capabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Capabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("monitors")
		e.ArrStart()
		for _, elem := range s.Monitors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.FieldStart("secretFile")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CephFSPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretFile":
			if err := func() error {
				s.SecretFile.Reset()
				if err := s.SecretFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretFile\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CephFSPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CephFSPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CephFSVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("monitors")
		e.ArrStart()
		for _, elem := range s.Monitors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretFile.Set {
			e.FieldStart("secretFile")
			s.SecretFile.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource = [6]string{
	0: "monitors",
	1: "path",
	2: "readOnly",
	3: "secretFile",
	4: "secretRef",
	5: "user",
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (s *IoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CephFSVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "monitors":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretFile":
			if err := func() error {
				s.SecretFile.Reset()
				if err := s.SecretFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretFile\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CephFSVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CephFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CephFSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CephFSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.FieldStart("volumeID")
		e.Str(s.VolumeID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CinderPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CinderPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CinderPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1CinderVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.FieldStart("volumeID")
		e.Str(s.VolumeID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource = [4]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeID",
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (s *IoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1CinderVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1CinderVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1CinderVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1CinderVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1CinderVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ClientIPConfig) encodeFields(e *jx.Encoder) {
	{
		if s.TimeoutSeconds.Set {
			e.FieldStart("timeoutSeconds")
			s.TimeoutSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ClientIPConfig = [1]string{
	0: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (s *IoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ClientIPConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ClientIPConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ClientIPConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ClientIPConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ComponentCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ComponentCondition) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition = [4]string{
	0: "error",
	1: "message",
	2: "status",
	3: "type",
}

// Decode decodes IoK8sAPICoreV1ComponentCondition from json.
func (s *IoK8sAPICoreV1ComponentCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ComponentCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ComponentCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ComponentStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ComponentStatus) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatus = [4]string{
	0: "apiVersion",
	1: "conditions",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatus from json.
func (s *IoK8sAPICoreV1ComponentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1ComponentCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ComponentCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ComponentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ComponentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ComponentStatusList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ComponentStatusList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ComponentStatusList from json.
func (s *IoK8sAPICoreV1ComponentStatusList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ComponentStatusList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ComponentStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ComponentStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ComponentStatusList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ComponentStatusList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ComponentStatusList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ComponentStatusList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMap) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.BinaryData.Set {
			e.FieldStart("binaryData")
			s.BinaryData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			e.FieldStart("immutable")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMap = [6]string{
	0: "apiVersion",
	1: "binaryData",
	2: "data",
	3: "immutable",
	4: "kind",
	5: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMap from json.
func (s *IoK8sAPICoreV1ConfigMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMap to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "binaryData":
			if err := func() error {
				s.BinaryData.Reset()
				if err := s.BinaryData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"binaryData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "immutable":
			if err := func() error {
				s.Immutable.Reset()
				if err := s.Immutable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immutable\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapBinaryData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapBinaryData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Base64(elem)
	}
}

// Decode decodes IoK8sAPICoreV1ConfigMapBinaryData from json.
func (s *IoK8sAPICoreV1ConfigMapBinaryData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapBinaryData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []byte
		if err := func() error {
			v, err := d.Base64()
			elem = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapBinaryData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ConfigMapBinaryData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapBinaryData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ConfigMapData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1ConfigMapData from json.
func (s *IoK8sAPICoreV1ConfigMapData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ConfigMapData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapEnvSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapEnvSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapEnvSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapKeySelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapKeySelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapKeySelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ConfigMapList from json.
func (s *IoK8sAPICoreV1ConfigMapList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ConfigMap, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ConfigMap
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("kubeletConfigKey")
		e.Str(s.KubeletConfigKey)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource = [5]string{
	0: "kubeletConfigKey",
	1: "name",
	2: "namespace",
	3: "resourceVersion",
	4: "uid",
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapNodeConfigSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletConfigKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KubeletConfigKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletConfigKey\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapNodeConfigSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ConfigMapNodeConfigSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapNodeConfigSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapProjection) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (s *IoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapProjection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultMode.Set {
			e.FieldStart("defaultMode")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ConfigMapVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "name",
	3: "optional",
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ConfigMapVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ConfigMapVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ConfigMapVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Container) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Container) encodeFields(e *jx.Encoder) {
	{
		if s.Args != nil {
			e.FieldStart("args")
			e.ArrStart()
			for _, elem := range s.Args {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			e.FieldStart("command")
			e.ArrStart()
			for _, elem := range s.Command {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			e.FieldStart("env")
			e.ArrStart()
			for _, elem := range s.Env {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			e.FieldStart("envFrom")
			e.ArrStart()
			for _, elem := range s.EnvFrom {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			e.FieldStart("imagePullPolicy")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			e.FieldStart("lifecycle")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			e.FieldStart("livenessProbe")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.FieldStart("readinessProbe")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.FieldStart("securityContext")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.FieldStart("startupProbe")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.FieldStart("stdin")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.FieldStart("stdinOnce")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.FieldStart("terminationMessagePath")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.FieldStart("terminationMessagePolicy")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.FieldStart("tty")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.FieldStart("volumeDevices")
			e.ArrStart()
			for _, elem := range s.VolumeDevices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.FieldStart("volumeMounts")
			e.ArrStart()
			for _, elem := range s.VolumeMounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.FieldStart("workingDir")
			s.WorkingDir.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Container = [22]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "terminationMessagePath",
	17: "terminationMessagePolicy",
	18: "tty",
	19: "volumeDevices",
	20: "volumeMounts",
	21: "workingDir",
}

// Decode decodes IoK8sAPICoreV1Container from json.
func (s *IoK8sAPICoreV1Container) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Container to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			if err := func() error {
				s.Args = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Args = append(s.Args, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]IoK8sAPICoreV1EnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "envFrom":
			if err := func() error {
				s.EnvFrom = make([]IoK8sAPICoreV1EnvFromSource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvFromSource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EnvFrom = append(s.EnvFrom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envFrom\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "lifecycle":
			if err := func() error {
				s.Lifecycle.Reset()
				if err := s.Lifecycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycle\"")
			}
		case "livenessProbe":
			if err := func() error {
				s.LivenessProbe.Reset()
				if err := s.LivenessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livenessProbe\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ContainerPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "readinessProbe":
			if err := func() error {
				s.ReadinessProbe.Reset()
				if err := s.ReadinessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessProbe\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "startupProbe":
			if err := func() error {
				s.StartupProbe.Reset()
				if err := s.StartupProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startupProbe\"")
			}
		case "stdin":
			if err := func() error {
				s.Stdin.Reset()
				if err := s.Stdin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdin\"")
			}
		case "stdinOnce":
			if err := func() error {
				s.StdinOnce.Reset()
				if err := s.StdinOnce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdinOnce\"")
			}
		case "terminationMessagePath":
			if err := func() error {
				s.TerminationMessagePath.Reset()
				if err := s.TerminationMessagePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePath\"")
			}
		case "terminationMessagePolicy":
			if err := func() error {
				s.TerminationMessagePolicy.Reset()
				if err := s.TerminationMessagePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePolicy\"")
			}
		case "tty":
			if err := func() error {
				s.Tty.Reset()
				if err := s.Tty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tty\"")
			}
		case "volumeDevices":
			if err := func() error {
				s.VolumeDevices = make([]IoK8sAPICoreV1VolumeDevice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeDevice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeDevices = append(s.VolumeDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeDevices\"")
			}
		case "volumeMounts":
			if err := func() error {
				s.VolumeMounts = make([]IoK8sAPICoreV1VolumeMount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeMount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeMounts = append(s.VolumeMounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMounts\"")
			}
		case "workingDir":
			if err := func() error {
				s.WorkingDir.Reset()
				if err := s.WorkingDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workingDir\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Container")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Container) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Container[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Container) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Container) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerImage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerImage) encodeFields(e *jx.Encoder) {
	{
		if s.Names != nil {
			e.FieldStart("names")
			e.ArrStart()
			for _, elem := range s.Names {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SizeBytes.Set {
			e.FieldStart("sizeBytes")
			s.SizeBytes.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerImage = [2]string{
	0: "names",
	1: "sizeBytes",
}

// Decode decodes IoK8sAPICoreV1ContainerImage from json.
func (s *IoK8sAPICoreV1ContainerImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerImage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "sizeBytes":
			if err := func() error {
				s.SizeBytes.Reset()
				if err := s.SizeBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerImage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerPort) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("containerPort")
		e.Int32(s.ContainerPort)
	}
	{
		if s.HostIP.Set {
			e.FieldStart("hostIP")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.HostPort.Set {
			e.FieldStart("hostPort")
			s.HostPort.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerPort = [5]string{
	0: "containerPort",
	1: "hostIP",
	2: "hostPort",
	3: "name",
	4: "protocol",
}

// Decode decodes IoK8sAPICoreV1ContainerPort from json.
func (s *IoK8sAPICoreV1ContainerPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerPort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerPort":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ContainerPort = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerPort\"")
			}
		case "hostIP":
			if err := func() error {
				s.HostIP.Reset()
				if err := s.HostIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIP\"")
			}
		case "hostPort":
			if err := func() error {
				s.HostPort.Reset()
				if err := s.HostPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPort\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerPort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerState) encodeFields(e *jx.Encoder) {
	{
		if s.Running.Set {
			e.FieldStart("running")
			s.Running.Encode(e)
		}
	}
	{
		if s.Terminated.Set {
			e.FieldStart("terminated")
			s.Terminated.Encode(e)
		}
	}
	{
		if s.Waiting.Set {
			e.FieldStart("waiting")
			s.Waiting.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerState = [3]string{
	0: "running",
	1: "terminated",
	2: "waiting",
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (s *IoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerState to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "running":
			if err := func() error {
				s.Running.Reset()
				if err := s.Running.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running\"")
			}
		case "terminated":
			if err := func() error {
				s.Terminated.Reset()
				if err := s.Terminated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminated\"")
			}
		case "waiting":
			if err := func() error {
				s.Waiting.Reset()
				if err := s.Waiting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"waiting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerState")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerStateRunning) encodeFields(e *jx.Encoder) {
	{
		if s.StartedAt.Set {
			e.FieldStart("startedAt")
			s.StartedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateRunning = [1]string{
	0: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (s *IoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateRunning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startedAt":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateRunning")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateRunning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerStateRunning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerStateTerminated) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerID.Set {
			e.FieldStart("containerID")
			s.ContainerID.Encode(e)
		}
	}
	{
		e.FieldStart("exitCode")
		e.Int32(s.ExitCode)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finishedAt")
			s.FinishedAt.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signal.Set {
			e.FieldStart("signal")
			s.Signal.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("startedAt")
			s.StartedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated = [7]string{
	0: "containerID",
	1: "exitCode",
	2: "finishedAt",
	3: "message",
	4: "reason",
	5: "signal",
	6: "startedAt",
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (s *IoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateTerminated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerID\"")
			}
		case "exitCode":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ExitCode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exitCode\"")
			}
		case "finishedAt":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finishedAt\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signal":
			if err := func() error {
				s.Signal.Reset()
				if err := s.Signal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal\"")
			}
		case "startedAt":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateTerminated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStateTerminated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateTerminated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerStateTerminated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerStateWaiting) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStateWaiting = [2]string{
	0: "message",
	1: "reason",
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (s *IoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStateWaiting to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStateWaiting")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerStateWaiting) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerStateWaiting) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ContainerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ContainerStatus) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerID.Set {
			e.FieldStart("containerID")
			s.ContainerID.Encode(e)
		}
	}
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		e.FieldStart("imageID")
		e.Str(s.ImageID)
	}
	{
		if s.LastState.Set {
			e.FieldStart("lastState")
			s.LastState.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("ready")
		e.Bool(s.Ready)
	}
	{
		e.FieldStart("restartCount")
		e.Int32(s.RestartCount)
	}
	{
		if s.Started.Set {
			e.FieldStart("started")
			s.Started.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus = [9]string{
	0: "containerID",
	1: "image",
	2: "imageID",
	3: "lastState",
	4: "name",
	5: "ready",
	6: "restartCount",
	7: "started",
	8: "state",
}

// Decode decodes IoK8sAPICoreV1ContainerStatus from json.
func (s *IoK8sAPICoreV1ContainerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ContainerStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerID":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerID\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imageID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ImageID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageID\"")
			}
		case "lastState":
			if err := func() error {
				s.LastState.Reset()
				if err := s.LastState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastState\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ready":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Ready = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "restartCount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.RestartCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restartCount\"")
			}
		case "started":
			if err := func() error {
				s.Started.Reset()
				if err := s.Started.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ContainerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ContainerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ContainerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ContainerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1DaemonEndpoint) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Port")
		e.Int32(s.Port)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint = [1]string{
	0: "Port",
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (s *IoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DaemonEndpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Port":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DaemonEndpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DaemonEndpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1DaemonEndpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1DaemonEndpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1DownwardAPIProjection) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIProjection = [1]string{
	0: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (s *IoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1DownwardAPIVolumeFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1DownwardAPIVolumeFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIProjection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1DownwardAPIProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) encodeFields(e *jx.Encoder) {
	{
		if s.FieldRef.Set {
			e.FieldStart("fieldRef")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.ResourceFieldRef.Set {
			e.FieldStart("resourceFieldRef")
			s.ResourceFieldRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile = [4]string{
	0: "fieldRef",
	1: "mode",
	2: "path",
	3: "resourceFieldRef",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeFile from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldRef":
			if err := func() error {
				s.FieldRef.Reset()
				if err := s.FieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldRef\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "resourceFieldRef":
			if err := func() error {
				s.ResourceFieldRef.Reset()
				if err := s.ResourceFieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFieldRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIVolumeFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultMode.Set {
			e.FieldStart("defaultMode")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1DownwardAPIVolumeSource = [2]string{
	0: "defaultMode",
	1: "items",
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1DownwardAPIVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1DownwardAPIVolumeFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1DownwardAPIVolumeFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1DownwardAPIVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1DownwardAPIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.Medium.Set {
			e.FieldStart("medium")
			s.Medium.Encode(e)
		}
	}
	{
		if s.SizeLimit.Set {
			e.FieldStart("sizeLimit")
			s.SizeLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EmptyDirVolumeSource = [2]string{
	0: "medium",
	1: "sizeLimit",
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EmptyDirVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "medium":
			if err := func() error {
				s.Medium.Reset()
				if err := s.Medium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"medium\"")
			}
		case "sizeLimit":
			if err := func() error {
				s.SizeLimit.Reset()
				if err := s.SizeLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sizeLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EmptyDirVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EmptyDirVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EndpointAddress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EndpointAddress) encodeFields(e *jx.Encoder) {
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		e.FieldStart("ip")
		e.Str(s.IP)
	}
	{
		if s.NodeName.Set {
			e.FieldStart("nodeName")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.FieldStart("targetRef")
			s.TargetRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress = [4]string{
	0: "hostname",
	1: "ip",
	2: "nodeName",
	3: "targetRef",
}

// Decode decodes IoK8sAPICoreV1EndpointAddress from json.
func (s *IoK8sAPICoreV1EndpointAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "ip":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EndpointAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EndpointAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EndpointPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EndpointPort) encodeFields(e *jx.Encoder) {
	{
		if s.AppProtocol.Set {
			e.FieldStart("appProtocol")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPICoreV1EndpointPort from json.
func (s *IoK8sAPICoreV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointPort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointPort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointPort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointPort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EndpointPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EndpointPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EndpointSubset) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EndpointSubset) encodeFields(e *jx.Encoder) {
	{
		if s.Addresses != nil {
			e.FieldStart("addresses")
			e.ArrStart()
			for _, elem := range s.Addresses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NotReadyAddresses != nil {
			e.FieldStart("notReadyAddresses")
			e.ArrStart()
			for _, elem := range s.NotReadyAddresses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointSubset = [3]string{
	0: "addresses",
	1: "notReadyAddresses",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1EndpointSubset from json.
func (s *IoK8sAPICoreV1EndpointSubset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointSubset to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			if err := func() error {
				s.Addresses = make([]IoK8sAPICoreV1EndpointAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "notReadyAddresses":
			if err := func() error {
				s.NotReadyAddresses = make([]IoK8sAPICoreV1EndpointAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NotReadyAddresses = append(s.NotReadyAddresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notReadyAddresses\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointSubset")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EndpointSubset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EndpointSubset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Endpoints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Endpoints) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Subsets != nil {
			e.FieldStart("subsets")
			e.ArrStart()
			for _, elem := range s.Subsets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Endpoints = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "subsets",
}

// Decode decodes IoK8sAPICoreV1Endpoints from json.
func (s *IoK8sAPICoreV1Endpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Endpoints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "subsets":
			if err := func() error {
				s.Subsets = make([]IoK8sAPICoreV1EndpointSubset, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EndpointSubset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subsets = append(s.Subsets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subsets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Endpoints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Endpoints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Endpoints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EndpointsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EndpointsList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EndpointsList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EndpointsList from json.
func (s *IoK8sAPICoreV1EndpointsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EndpointsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Endpoints, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Endpoints
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EndpointsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EndpointsList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EndpointsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EndpointsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EndpointsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EnvFromSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EnvFromSource) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigMapRef.Set {
			e.FieldStart("configMapRef")
			s.ConfigMapRef.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvFromSource = [3]string{
	0: "configMapRef",
	1: "prefix",
	2: "secretRef",
}

// Decode decodes IoK8sAPICoreV1EnvFromSource from json.
func (s *IoK8sAPICoreV1EnvFromSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvFromSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapRef":
			if err := func() error {
				s.ConfigMapRef.Reset()
				if err := s.ConfigMapRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMapRef\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvFromSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EnvFromSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EnvFromSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EnvVar) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EnvVar) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValueFrom.Set {
			e.FieldStart("valueFrom")
			s.ValueFrom.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVar = [3]string{
	0: "name",
	1: "value",
	2: "valueFrom",
}

// Decode decodes IoK8sAPICoreV1EnvVar from json.
func (s *IoK8sAPICoreV1EnvVar) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvVar to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "valueFrom":
			if err := func() error {
				s.ValueFrom.Reset()
				if err := s.ValueFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueFrom\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvVar")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EnvVar) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EnvVar[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EnvVar) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EnvVar) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EnvVarSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EnvVarSource) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigMapKeyRef.Set {
			e.FieldStart("configMapKeyRef")
			s.ConfigMapKeyRef.Encode(e)
		}
	}
	{
		if s.FieldRef.Set {
			e.FieldStart("fieldRef")
			s.FieldRef.Encode(e)
		}
	}
	{
		if s.ResourceFieldRef.Set {
			e.FieldStart("resourceFieldRef")
			s.ResourceFieldRef.Encode(e)
		}
	}
	{
		if s.SecretKeyRef.Set {
			e.FieldStart("secretKeyRef")
			s.SecretKeyRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EnvVarSource = [4]string{
	0: "configMapKeyRef",
	1: "fieldRef",
	2: "resourceFieldRef",
	3: "secretKeyRef",
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (s *IoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EnvVarSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMapKeyRef":
			if err := func() error {
				s.ConfigMapKeyRef.Reset()
				if err := s.ConfigMapKeyRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMapKeyRef\"")
			}
		case "fieldRef":
			if err := func() error {
				s.FieldRef.Reset()
				if err := s.FieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldRef\"")
			}
		case "resourceFieldRef":
			if err := func() error {
				s.ResourceFieldRef.Reset()
				if err := s.ResourceFieldRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceFieldRef\"")
			}
		case "secretKeyRef":
			if err := func() error {
				s.SecretKeyRef.Reset()
				if err := s.SecretKeyRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretKeyRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EnvVarSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EnvVarSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EnvVarSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EphemeralContainer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EphemeralContainer) encodeFields(e *jx.Encoder) {
	{
		if s.Args != nil {
			e.FieldStart("args")
			e.ArrStart()
			for _, elem := range s.Args {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Command != nil {
			e.FieldStart("command")
			e.ArrStart()
			for _, elem := range s.Command {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Env != nil {
			e.FieldStart("env")
			e.ArrStart()
			for _, elem := range s.Env {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EnvFrom != nil {
			e.FieldStart("envFrom")
			e.ArrStart()
			for _, elem := range s.EnvFrom {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.ImagePullPolicy.Set {
			e.FieldStart("imagePullPolicy")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			e.FieldStart("lifecycle")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.LivenessProbe.Set {
			e.FieldStart("livenessProbe")
			s.LivenessProbe.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadinessProbe.Set {
			e.FieldStart("readinessProbe")
			s.ReadinessProbe.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.FieldStart("securityContext")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.StartupProbe.Set {
			e.FieldStart("startupProbe")
			s.StartupProbe.Encode(e)
		}
	}
	{
		if s.Stdin.Set {
			e.FieldStart("stdin")
			s.Stdin.Encode(e)
		}
	}
	{
		if s.StdinOnce.Set {
			e.FieldStart("stdinOnce")
			s.StdinOnce.Encode(e)
		}
	}
	{
		if s.TargetContainerName.Set {
			e.FieldStart("targetContainerName")
			s.TargetContainerName.Encode(e)
		}
	}
	{
		if s.TerminationMessagePath.Set {
			e.FieldStart("terminationMessagePath")
			s.TerminationMessagePath.Encode(e)
		}
	}
	{
		if s.TerminationMessagePolicy.Set {
			e.FieldStart("terminationMessagePolicy")
			s.TerminationMessagePolicy.Encode(e)
		}
	}
	{
		if s.Tty.Set {
			e.FieldStart("tty")
			s.Tty.Encode(e)
		}
	}
	{
		if s.VolumeDevices != nil {
			e.FieldStart("volumeDevices")
			e.ArrStart()
			for _, elem := range s.VolumeDevices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeMounts != nil {
			e.FieldStart("volumeMounts")
			e.ArrStart()
			for _, elem := range s.VolumeMounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkingDir.Set {
			e.FieldStart("workingDir")
			s.WorkingDir.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer = [23]string{
	0:  "args",
	1:  "command",
	2:  "env",
	3:  "envFrom",
	4:  "image",
	5:  "imagePullPolicy",
	6:  "lifecycle",
	7:  "livenessProbe",
	8:  "name",
	9:  "ports",
	10: "readinessProbe",
	11: "resources",
	12: "securityContext",
	13: "startupProbe",
	14: "stdin",
	15: "stdinOnce",
	16: "targetContainerName",
	17: "terminationMessagePath",
	18: "terminationMessagePolicy",
	19: "tty",
	20: "volumeDevices",
	21: "volumeMounts",
	22: "workingDir",
}

// Decode decodes IoK8sAPICoreV1EphemeralContainer from json.
func (s *IoK8sAPICoreV1EphemeralContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EphemeralContainer to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "args":
			if err := func() error {
				s.Args = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Args = append(s.Args, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]IoK8sAPICoreV1EnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "envFrom":
			if err := func() error {
				s.EnvFrom = make([]IoK8sAPICoreV1EnvFromSource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EnvFromSource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EnvFrom = append(s.EnvFrom, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envFrom\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "lifecycle":
			if err := func() error {
				s.Lifecycle.Reset()
				if err := s.Lifecycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycle\"")
			}
		case "livenessProbe":
			if err := func() error {
				s.LivenessProbe.Reset()
				if err := s.LivenessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livenessProbe\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ContainerPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "readinessProbe":
			if err := func() error {
				s.ReadinessProbe.Reset()
				if err := s.ReadinessProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessProbe\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "startupProbe":
			if err := func() error {
				s.StartupProbe.Reset()
				if err := s.StartupProbe.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startupProbe\"")
			}
		case "stdin":
			if err := func() error {
				s.Stdin.Reset()
				if err := s.Stdin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdin\"")
			}
		case "stdinOnce":
			if err := func() error {
				s.StdinOnce.Reset()
				if err := s.StdinOnce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stdinOnce\"")
			}
		case "targetContainerName":
			if err := func() error {
				s.TargetContainerName.Reset()
				if err := s.TargetContainerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetContainerName\"")
			}
		case "terminationMessagePath":
			if err := func() error {
				s.TerminationMessagePath.Reset()
				if err := s.TerminationMessagePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePath\"")
			}
		case "terminationMessagePolicy":
			if err := func() error {
				s.TerminationMessagePolicy.Reset()
				if err := s.TerminationMessagePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationMessagePolicy\"")
			}
		case "tty":
			if err := func() error {
				s.Tty.Reset()
				if err := s.Tty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tty\"")
			}
		case "volumeDevices":
			if err := func() error {
				s.VolumeDevices = make([]IoK8sAPICoreV1VolumeDevice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeDevice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeDevices = append(s.VolumeDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeDevices\"")
			}
		case "volumeMounts":
			if err := func() error {
				s.VolumeMounts = make([]IoK8sAPICoreV1VolumeMount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeMount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumeMounts = append(s.VolumeMounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMounts\"")
			}
		case "workingDir":
			if err := func() error {
				s.WorkingDir.Reset()
				if err := s.WorkingDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workingDir\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EphemeralContainer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EphemeralContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EphemeralContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EphemeralContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.VolumeClaimTemplate.Set {
			e.FieldStart("volumeClaimTemplate")
			s.VolumeClaimTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EphemeralVolumeSource = [1]string{
	0: "volumeClaimTemplate",
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EphemeralVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "volumeClaimTemplate":
			if err := func() error {
				s.VolumeClaimTemplate.Reset()
				if err := s.VolumeClaimTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeClaimTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EphemeralVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EphemeralVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Event) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.EventTime.Set {
			e.FieldStart("eventTime")
			s.EventTime.Encode(e)
		}
	}
	{
		if s.FirstTimestamp.Set {
			e.FieldStart("firstTimestamp")
			s.FirstTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("involvedObject")
		s.InvolvedObject.Encode(e)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.LastTimestamp.Set {
			e.FieldStart("lastTimestamp")
			s.LastTimestamp.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.FieldStart("related")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingComponent.Set {
			e.FieldStart("reportingComponent")
			s.ReportingComponent.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.FieldStart("reportingInstance")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.FieldStart("series")
			s.Series.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "count",
	3:  "eventTime",
	4:  "firstTimestamp",
	5:  "involvedObject",
	6:  "kind",
	7:  "lastTimestamp",
	8:  "message",
	9:  "metadata",
	10: "reason",
	11: "related",
	12: "reportingComponent",
	13: "reportingInstance",
	14: "series",
	15: "source",
	16: "type",
}

// Decode decodes IoK8sAPICoreV1Event from json.
func (s *IoK8sAPICoreV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "eventTime":
			if err := func() error {
				s.EventTime.Reset()
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "firstTimestamp":
			if err := func() error {
				s.FirstTimestamp.Reset()
				if err := s.FirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTimestamp\"")
			}
		case "involvedObject":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.InvolvedObject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"involvedObject\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "lastTimestamp":
			if err := func() error {
				s.LastTimestamp.Reset()
				if err := s.LastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTimestamp\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingComponent":
			if err := func() error {
				s.ReportingComponent.Reset()
				if err := s.ReportingComponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingComponent\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100000,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Event) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EventList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EventList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1EventList from json.
func (s *IoK8sAPICoreV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1EventList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EventList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EventList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EventSeries) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EventSeries) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.LastObservedTime.Set {
			e.FieldStart("lastObservedTime")
			s.LastObservedTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (s *IoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventSeries to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			if err := func() error {
				s.LastObservedTime.Reset()
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventSeries")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1EventSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1EventSource) encodeFields(e *jx.Encoder) {
	{
		if s.Component.Set {
			e.FieldStart("component")
			s.Component.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1EventSource = [2]string{
	0: "component",
	1: "host",
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (s *IoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1EventSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			if err := func() error {
				s.Component.Reset()
				if err := s.Component.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1EventSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1EventSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1EventSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ExecAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ExecAction) encodeFields(e *jx.Encoder) {
	{
		if s.Command != nil {
			e.FieldStart("command")
			e.ArrStart()
			for _, elem := range s.Command {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ExecAction = [1]string{
	0: "command",
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (s *IoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ExecAction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ExecAction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ExecAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ExecAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1FCVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Lun.Set {
			e.FieldStart("lun")
			s.Lun.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.TargetWWNs != nil {
			e.FieldStart("targetWWNs")
			e.ArrStart()
			for _, elem := range s.TargetWWNs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Wwids != nil {
			e.FieldStart("wwids")
			e.ArrStart()
			for _, elem := range s.Wwids {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1FCVolumeSource = [5]string{
	0: "fsType",
	1: "lun",
	2: "readOnly",
	3: "targetWWNs",
	4: "wwids",
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (s *IoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FCVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "lun":
			if err := func() error {
				s.Lun.Reset()
				if err := s.Lun.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "targetWWNs":
			if err := func() error {
				s.TargetWWNs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TargetWWNs = append(s.TargetWWNs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetWWNs\"")
			}
		case "wwids":
			if err := func() error {
				s.Wwids = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Wwids = append(s.Wwids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wwids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FCVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1FCVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FCVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("driver")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions from json.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexPersistentVolumeSourceOptions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexPersistentVolumeSourceOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FlexPersistentVolumeSourceOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1FlexVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("driver")
		e.Str(s.Driver)
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource = [5]string{
	0: "driver",
	1: "fsType",
	2: "options",
	3: "readOnly",
	4: "secretRef",
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (s *IoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1FlexVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1FlexVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FlexVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSourceOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSourceOptions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSourceOptions from json.
func (s *IoK8sAPICoreV1FlexVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlexVolumeSourceOptions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlexVolumeSourceOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1FlexVolumeSourceOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FlexVolumeSourceOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1FlockerVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.DatasetName.Set {
			e.FieldStart("datasetName")
			s.DatasetName.Encode(e)
		}
	}
	{
		if s.DatasetUUID.Set {
			e.FieldStart("datasetUUID")
			s.DatasetUUID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1FlockerVolumeSource = [2]string{
	0: "datasetName",
	1: "datasetUUID",
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (s *IoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1FlockerVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datasetName":
			if err := func() error {
				s.DatasetName.Reset()
				if err := s.DatasetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datasetName\"")
			}
		case "datasetUUID":
			if err := func() error {
				s.DatasetUUID.Reset()
				if err := s.DatasetUUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datasetUUID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1FlockerVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1FlockerVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1FlockerVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.Partition.Set {
			e.FieldStart("partition")
			s.Partition.Encode(e)
		}
	}
	{
		e.FieldStart("pdName")
		e.Str(s.PdName)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource = [4]string{
	0: "fsType",
	1: "partition",
	2: "pdName",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "partition":
			if err := func() error {
				s.Partition.Reset()
				if err := s.Partition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partition\"")
			}
		case "pdName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PdName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdName\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GCEPersistentDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GCEPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1GCEPersistentDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.Directory.Set {
			e.FieldStart("directory")
			s.Directory.Encode(e)
		}
	}
	{
		e.FieldStart("repository")
		e.Str(s.Repository)
	}
	{
		if s.Revision.Set {
			e.FieldStart("revision")
			s.Revision.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource = [3]string{
	0: "directory",
	1: "repository",
	2: "revision",
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GitRepoVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "directory":
			if err := func() error {
				s.Directory.Reset()
				if err := s.Directory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directory\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Repository = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "revision":
			if err := func() error {
				s.Revision.Reset()
				if err := s.Revision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revision\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GitRepoVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GitRepoVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1GitRepoVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("endpoints")
		e.Str(s.Endpoints)
	}
	{
		if s.EndpointsNamespace.Set {
			e.FieldStart("endpointsNamespace")
			s.EndpointsNamespace.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource = [4]string{
	0: "endpoints",
	1: "endpointsNamespace",
	2: "path",
	3: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Endpoints = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "endpointsNamespace":
			if err := func() error {
				s.EndpointsNamespace.Reset()
				if err := s.EndpointsNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpointsNamespace\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GlusterfsPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1GlusterfsPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("endpoints")
		e.Str(s.Endpoints)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource = [3]string{
	0: "endpoints",
	1: "path",
	2: "readOnly",
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1GlusterfsVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoints":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Endpoints = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1GlusterfsVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1GlusterfsVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1GlusterfsVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1HTTPGetAction) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.HttpHeaders != nil {
			e.FieldStart("httpHeaders")
			e.ArrStart()
			for _, elem := range s.HttpHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if s.Scheme.Set {
			e.FieldStart("scheme")
			s.Scheme.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction = [5]string{
	0: "host",
	1: "httpHeaders",
	2: "path",
	3: "port",
	4: "scheme",
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (s *IoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HTTPGetAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "httpHeaders":
			if err := func() error {
				s.HttpHeaders = make([]IoK8sAPICoreV1HTTPHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1HTTPHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HttpHeaders = append(s.HttpHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpHeaders\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "scheme":
			if err := func() error {
				s.Scheme.Reset()
				if err := s.Scheme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheme\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HTTPGetAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPGetAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1HTTPGetAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1HTTPGetAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1HTTPHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1HTTPHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1HTTPHeader from json.
func (s *IoK8sAPICoreV1HTTPHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HTTPHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HTTPHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HTTPHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1HTTPHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1HTTPHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Handler) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Handler) encodeFields(e *jx.Encoder) {
	{
		if s.Exec.Set {
			e.FieldStart("exec")
			s.Exec.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			e.FieldStart("httpGet")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			e.FieldStart("tcpSocket")
			s.TcpSocket.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Handler = [3]string{
	0: "exec",
	1: "httpGet",
	2: "tcpSocket",
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (s *IoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Handler to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			if err := func() error {
				s.Exec.Reset()
				if err := s.Exec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exec\"")
			}
		case "httpGet":
			if err := func() error {
				s.HttpGet.Reset()
				if err := s.HttpGet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpGet\"")
			}
		case "tcpSocket":
			if err := func() error {
				s.TcpSocket.Reset()
				if err := s.TcpSocket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tcpSocket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Handler")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Handler) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Handler) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1HostAlias) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1HostAlias) encodeFields(e *jx.Encoder) {
	{
		if s.Hostnames != nil {
			e.FieldStart("hostnames")
			e.ArrStart()
			for _, elem := range s.Hostnames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1HostAlias = [2]string{
	0: "hostnames",
	1: "ip",
}

// Decode decodes IoK8sAPICoreV1HostAlias from json.
func (s *IoK8sAPICoreV1HostAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HostAlias to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostnames":
			if err := func() error {
				s.Hostnames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostnames = append(s.Hostnames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostnames\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HostAlias")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1HostAlias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1HostAlias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1HostPathVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource = [2]string{
	0: "path",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (s *IoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1HostPathVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1HostPathVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1HostPathVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1HostPathVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1HostPathVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.ChapAuthDiscovery.Set {
			e.FieldStart("chapAuthDiscovery")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			e.FieldStart("chapAuthSession")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			e.FieldStart("initiatorName")
			s.InitiatorName.Encode(e)
		}
	}
	{
		e.FieldStart("iqn")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.FieldStart("iscsiInterface")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.FieldStart("lun")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.FieldStart("portals")
			e.ArrStart()
			for _, elem := range s.Portals {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.FieldStart("targetPortal")
		e.Str(s.TargetPortal)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ISCSIPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			if err := func() error {
				s.ChapAuthDiscovery.Reset()
				if err := s.ChapAuthDiscovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthDiscovery\"")
			}
		case "chapAuthSession":
			if err := func() error {
				s.ChapAuthSession.Reset()
				if err := s.ChapAuthSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthSession\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "initiatorName":
			if err := func() error {
				s.InitiatorName.Reset()
				if err := s.InitiatorName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiatorName\"")
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Iqn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iqn\"")
			}
		case "iscsiInterface":
			if err := func() error {
				s.IscsiInterface.Reset()
				if err := s.IscsiInterface.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsiInterface\"")
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Lun = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "portals":
			if err := func() error {
				s.Portals = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Portals = append(s.Portals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portals\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetPortal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPortal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ISCSIPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ISCSIPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.ChapAuthDiscovery.Set {
			e.FieldStart("chapAuthDiscovery")
			s.ChapAuthDiscovery.Encode(e)
		}
	}
	{
		if s.ChapAuthSession.Set {
			e.FieldStart("chapAuthSession")
			s.ChapAuthSession.Encode(e)
		}
	}
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.InitiatorName.Set {
			e.FieldStart("initiatorName")
			s.InitiatorName.Encode(e)
		}
	}
	{
		e.FieldStart("iqn")
		e.Str(s.Iqn)
	}
	{
		if s.IscsiInterface.Set {
			e.FieldStart("iscsiInterface")
			s.IscsiInterface.Encode(e)
		}
	}
	{
		e.FieldStart("lun")
		e.Int32(s.Lun)
	}
	{
		if s.Portals != nil {
			e.FieldStart("portals")
			e.ArrStart()
			for _, elem := range s.Portals {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		e.FieldStart("targetPortal")
		e.Str(s.TargetPortal)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource = [11]string{
	0:  "chapAuthDiscovery",
	1:  "chapAuthSession",
	2:  "fsType",
	3:  "initiatorName",
	4:  "iqn",
	5:  "iscsiInterface",
	6:  "lun",
	7:  "portals",
	8:  "readOnly",
	9:  "secretRef",
	10: "targetPortal",
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ISCSIVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapAuthDiscovery":
			if err := func() error {
				s.ChapAuthDiscovery.Reset()
				if err := s.ChapAuthDiscovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthDiscovery\"")
			}
		case "chapAuthSession":
			if err := func() error {
				s.ChapAuthSession.Reset()
				if err := s.ChapAuthSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapAuthSession\"")
			}
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "initiatorName":
			if err := func() error {
				s.InitiatorName.Reset()
				if err := s.InitiatorName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiatorName\"")
			}
		case "iqn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Iqn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iqn\"")
			}
		case "iscsiInterface":
			if err := func() error {
				s.IscsiInterface.Reset()
				if err := s.IscsiInterface.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsiInterface\"")
			}
		case "lun":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Lun = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lun\"")
			}
		case "portals":
			if err := func() error {
				s.Portals = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Portals = append(s.Portals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portals\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "targetPortal":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetPortal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPortal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ISCSIVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ISCSIVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ISCSIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1KeyToPath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1KeyToPath) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1KeyToPath = [3]string{
	0: "key",
	1: "mode",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1KeyToPath from json.
func (s *IoK8sAPICoreV1KeyToPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1KeyToPath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1KeyToPath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1KeyToPath) {
					name = jsonFieldsNameOfIoK8sAPICoreV1KeyToPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1KeyToPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1KeyToPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Lifecycle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Lifecycle) encodeFields(e *jx.Encoder) {
	{
		if s.PostStart.Set {
			e.FieldStart("postStart")
			s.PostStart.Encode(e)
		}
	}
	{
		if s.PreStop.Set {
			e.FieldStart("preStop")
			s.PreStop.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Lifecycle = [2]string{
	0: "postStart",
	1: "preStop",
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (s *IoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Lifecycle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "postStart":
			if err := func() error {
				s.PostStart.Reset()
				if err := s.PostStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postStart\"")
			}
		case "preStop":
			if err := func() error {
				s.PreStop.Reset()
				if err := s.PreStop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preStop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Lifecycle")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Lifecycle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Lifecycle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LimitRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LimitRange) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRange = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPICoreV1LimitRange from json.
func (s *IoK8sAPICoreV1LimitRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LimitRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LimitRangeItem) encodeFields(e *jx.Encoder) {
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.DefaultRequest.Set {
			e.FieldStart("defaultRequest")
			s.DefaultRequest.Encode(e)
		}
	}
	{
		if s.Max.Set {
			e.FieldStart("max")
			s.Max.Encode(e)
		}
	}
	{
		if s.MaxLimitRequestRatio.Set {
			e.FieldStart("maxLimitRequestRatio")
			s.MaxLimitRequestRatio.Encode(e)
		}
	}
	{
		if s.Min.Set {
			e.FieldStart("min")
			s.Min.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem = [6]string{
	0: "default",
	1: "defaultRequest",
	2: "max",
	3: "maxLimitRequestRatio",
	4: "min",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1LimitRangeItem from json.
func (s *IoK8sAPICoreV1LimitRangeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "defaultRequest":
			if err := func() error {
				s.DefaultRequest.Reset()
				if err := s.DefaultRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRequest\"")
			}
		case "max":
			if err := func() error {
				s.Max.Reset()
				if err := s.Max.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "maxLimitRequestRatio":
			if err := func() error {
				s.MaxLimitRequestRatio.Reset()
				if err := s.MaxLimitRequestRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLimitRequestRatio\"")
			}
		case "min":
			if err := func() error {
				s.Min.Reset()
				if err := s.Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefault) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefault) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefault from json.
func (s *IoK8sAPICoreV1LimitRangeItemDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemDefault to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemDefault")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItemDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefaultRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefaultRequest) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefaultRequest from json.
func (s *IoK8sAPICoreV1LimitRangeItemDefaultRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemDefaultRequest to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemDefaultRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemDefaultRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItemDefaultRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMax) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMax) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMax from json.
func (s *IoK8sAPICoreV1LimitRangeItemMax) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMax to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMax")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMax) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItemMax) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio from json.
func (s *IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMin) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMin) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMin from json.
func (s *IoK8sAPICoreV1LimitRangeItemMin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeItemMin to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeItemMin")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1LimitRangeItemMin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeItemMin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LimitRangeList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1LimitRangeList from json.
func (s *IoK8sAPICoreV1LimitRangeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1LimitRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LimitRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LimitRangeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("limits")
		e.ArrStart()
		for _, elem := range s.Limits {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec = [1]string{
	0: "limits",
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (s *IoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LimitRangeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Limits = make([]IoK8sAPICoreV1LimitRangeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LimitRangeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Limits = append(s.Limits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LimitRangeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LimitRangeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LimitRangeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LimitRangeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LoadBalancerIngress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LoadBalancerIngress) encodeFields(e *jx.Encoder) {
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerIngress = [3]string{
	0: "hostname",
	1: "ip",
	2: "ports",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerIngress from json.
func (s *IoK8sAPICoreV1LoadBalancerIngress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LoadBalancerIngress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1PortStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PortStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LoadBalancerIngress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LoadBalancerIngress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LoadBalancerIngress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LoadBalancerStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Ingress != nil {
			e.FieldStart("ingress")
			e.ArrStart()
			for _, elem := range s.Ingress {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LoadBalancerStatus = [1]string{
	0: "ingress",
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (s *IoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LoadBalancerStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ingress":
			if err := func() error {
				s.Ingress = make([]IoK8sAPICoreV1LoadBalancerIngress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LoadBalancerIngress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ingress = append(s.Ingress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LoadBalancerStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LoadBalancerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LoadBalancerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LocalObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalObjectReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (s *IoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LocalObjectReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LocalObjectReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LocalObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LocalObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1LocalVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource = [2]string{
	0: "fsType",
	1: "path",
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (s *IoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1LocalVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1LocalVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1LocalVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1LocalVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1LocalVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NFSVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("server")
		e.Str(s.Server)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource = [3]string{
	0: "path",
	1: "readOnly",
	2: "server",
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (s *IoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NFSVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "server":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Server = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NFSVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NFSVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NFSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NFSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Namespace) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Namespace) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Namespace = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Namespace from json.
func (s *IoK8sAPICoreV1Namespace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Namespace to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Namespace")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Namespace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Namespace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NamespaceCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NamespaceCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1NamespaceCondition from json.
func (s *IoK8sAPICoreV1NamespaceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NamespaceCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NamespaceCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NamespaceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NamespaceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NamespaceList from json.
func (s *IoK8sAPICoreV1NamespaceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Namespace, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Namespace
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NamespaceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NamespaceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NamespaceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NamespaceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NamespaceSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Finalizers != nil {
			e.FieldStart("finalizers")
			e.ArrStart()
			for _, elem := range s.Finalizers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceSpec = [1]string{
	0: "finalizers",
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (s *IoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "finalizers":
			if err := func() error {
				s.Finalizers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Finalizers = append(s.Finalizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalizers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NamespaceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NamespaceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NamespaceStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NamespaceStatus = [2]string{
	0: "conditions",
	1: "phase",
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (s *IoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NamespaceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1NamespaceCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NamespaceCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NamespaceStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NamespaceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NamespaceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Node) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Node) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Node = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Node from json.
func (s *IoK8sAPICoreV1Node) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Node to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Node")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Node) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Node) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeAddress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeAddress) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAddress = [2]string{
	0: "address",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1NodeAddress from json.
func (s *IoK8sAPICoreV1NodeAddress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeAddress to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeAddress")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeAddress) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeAddress[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeAddress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeAddress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			s.RequiredDuringSchedulingIgnoredDuringExecution.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (s *IoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PreferredSchedulingTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PreferredSchedulingTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution.Reset()
				if err := s.RequiredDuringSchedulingIgnoredDuringExecution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastHeartbeatTime.Set {
			e.FieldStart("lastHeartbeatTime")
			s.LastHeartbeatTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeCondition = [6]string{
	0: "lastHeartbeatTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1NodeCondition from json.
func (s *IoK8sAPICoreV1NodeCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastHeartbeatTime":
			if err := func() error {
				s.LastHeartbeatTime.Reset()
				if err := s.LastHeartbeatTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastHeartbeatTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeConfigSource) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigMap.Set {
			e.FieldStart("configMap")
			s.ConfigMap.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigSource = [1]string{
	0: "configMap",
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (s *IoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeConfigSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeConfigSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeConfigSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeConfigSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeConfigStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Assigned.Set {
			e.FieldStart("assigned")
			s.Assigned.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.LastKnownGood.Set {
			e.FieldStart("lastKnownGood")
			s.LastKnownGood.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeConfigStatus = [4]string{
	0: "active",
	1: "assigned",
	2: "error",
	3: "lastKnownGood",
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (s *IoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeConfigStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "assigned":
			if err := func() error {
				s.Assigned.Reset()
				if err := s.Assigned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "lastKnownGood":
			if err := func() error {
				s.LastKnownGood.Reset()
				if err := s.LastKnownGood.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastKnownGood\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeConfigStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeConfigStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeConfigStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) encodeFields(e *jx.Encoder) {
	{
		if s.KubeletEndpoint.Set {
			e.FieldStart("kubeletEndpoint")
			s.KubeletEndpoint.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeDaemonEndpoints = [1]string{
	0: "kubeletEndpoint",
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeDaemonEndpoints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeletEndpoint":
			if err := func() error {
				s.KubeletEndpoint.Reset()
				if err := s.KubeletEndpoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletEndpoint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeDaemonEndpoints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeDaemonEndpoints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1NodeList from json.
func (s *IoK8sAPICoreV1NodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Node, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Node
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeSelector) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeSelectorTerms")
		e.ArrStart()
		for _, elem := range s.NodeSelectorTerms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelector = [1]string{
	0: "nodeSelectorTerms",
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (s *IoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelectorTerms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NodeSelectorTerms = make([]IoK8sAPICoreV1NodeSelectorTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeSelectorTerms = append(s.NodeSelectorTerms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelectorTerms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorRequirement from json.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeSelectorRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeSelectorTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeSelectorTerm) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			e.FieldStart("matchFields")
			e.ArrStart()
			for _, elem := range s.MatchFields {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSelectorTerm = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes IoK8sAPICoreV1NodeSelectorTerm from json.
func (s *IoK8sAPICoreV1NodeSelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSelectorTerm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sAPICoreV1NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchFields":
			if err := func() error {
				s.MatchFields = make([]IoK8sAPICoreV1NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchFields = append(s.MatchFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSelectorTerm")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeSelectorTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeSelectorTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigSource.Set {
			e.FieldStart("configSource")
			s.ConfigSource.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			e.FieldStart("externalID")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.PodCIDR.Set {
			e.FieldStart("podCIDR")
			s.PodCIDR.Encode(e)
		}
	}
	{
		if s.PodCIDRs != nil {
			e.FieldStart("podCIDRs")
			e.ArrStart()
			for _, elem := range s.PodCIDRs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProviderID.Set {
			e.FieldStart("providerID")
			s.ProviderID.Encode(e)
		}
	}
	{
		if s.Taints != nil {
			e.FieldStart("taints")
			e.ArrStart()
			for _, elem := range s.Taints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Unschedulable.Set {
			e.FieldStart("unschedulable")
			s.Unschedulable.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSpec = [7]string{
	0: "configSource",
	1: "externalID",
	2: "podCIDR",
	3: "podCIDRs",
	4: "providerID",
	5: "taints",
	6: "unschedulable",
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (s *IoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configSource":
			if err := func() error {
				s.ConfigSource.Reset()
				if err := s.ConfigSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configSource\"")
			}
		case "externalID":
			if err := func() error {
				s.ExternalID.Reset()
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalID\"")
			}
		case "podCIDR":
			if err := func() error {
				s.PodCIDR.Reset()
				if err := s.PodCIDR.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podCIDR\"")
			}
		case "podCIDRs":
			if err := func() error {
				s.PodCIDRs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PodCIDRs = append(s.PodCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podCIDRs\"")
			}
		case "providerID":
			if err := func() error {
				s.ProviderID.Reset()
				if err := s.ProviderID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerID\"")
			}
		case "taints":
			if err := func() error {
				s.Taints = make([]IoK8sAPICoreV1Taint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Taint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Taints = append(s.Taints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taints\"")
			}
		case "unschedulable":
			if err := func() error {
				s.Unschedulable.Reset()
				if err := s.Unschedulable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unschedulable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Addresses != nil {
			e.FieldStart("addresses")
			e.ArrStart()
			for _, elem := range s.Addresses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Allocatable.Set {
			e.FieldStart("allocatable")
			s.Allocatable.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.DaemonEndpoints.Set {
			e.FieldStart("daemonEndpoints")
			s.DaemonEndpoints.Encode(e)
		}
	}
	{
		if s.Images != nil {
			e.FieldStart("images")
			e.ArrStart()
			for _, elem := range s.Images {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeInfo.Set {
			e.FieldStart("nodeInfo")
			s.NodeInfo.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
	{
		if s.VolumesAttached != nil {
			e.FieldStart("volumesAttached")
			e.ArrStart()
			for _, elem := range s.VolumesAttached {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumesInUse != nil {
			e.FieldStart("volumesInUse")
			e.ArrStart()
			for _, elem := range s.VolumesInUse {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeStatus = [11]string{
	0:  "addresses",
	1:  "allocatable",
	2:  "capacity",
	3:  "conditions",
	4:  "config",
	5:  "daemonEndpoints",
	6:  "images",
	7:  "nodeInfo",
	8:  "phase",
	9:  "volumesAttached",
	10: "volumesInUse",
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (s *IoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			if err := func() error {
				s.Addresses = make([]IoK8sAPICoreV1NodeAddress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeAddress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "allocatable":
			if err := func() error {
				s.Allocatable.Reset()
				if err := s.Allocatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocatable\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1NodeCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1NodeCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "daemonEndpoints":
			if err := func() error {
				s.DaemonEndpoints.Reset()
				if err := s.DaemonEndpoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daemonEndpoints\"")
			}
		case "images":
			if err := func() error {
				s.Images = make([]IoK8sAPICoreV1ContainerImage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerImage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Images = append(s.Images, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"images\"")
			}
		case "nodeInfo":
			if err := func() error {
				s.NodeInfo.Reset()
				if err := s.NodeInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeInfo\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "volumesAttached":
			if err := func() error {
				s.VolumesAttached = make([]IoK8sAPICoreV1AttachedVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1AttachedVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VolumesAttached = append(s.VolumesAttached, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumesAttached\"")
			}
		case "volumesInUse":
			if err := func() error {
				s.VolumesInUse = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VolumesInUse = append(s.VolumesInUse, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumesInUse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusAllocatable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusAllocatable) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1NodeStatusAllocatable from json.
func (s *IoK8sAPICoreV1NodeStatusAllocatable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatusAllocatable to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatusAllocatable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1NodeStatusAllocatable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeStatusAllocatable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusCapacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1NodeStatusCapacity) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1NodeStatusCapacity from json.
func (s *IoK8sAPICoreV1NodeStatusCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeStatusCapacity to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeStatusCapacity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1NodeStatusCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeStatusCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1NodeSystemInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("architecture")
		e.Str(s.Architecture)
	}
	{
		e.FieldStart("bootID")
		e.Str(s.BootID)
	}
	{
		e.FieldStart("containerRuntimeVersion")
		e.Str(s.ContainerRuntimeVersion)
	}
	{
		e.FieldStart("kernelVersion")
		e.Str(s.KernelVersion)
	}
	{
		e.FieldStart("kubeProxyVersion")
		e.Str(s.KubeProxyVersion)
	}
	{
		e.FieldStart("kubeletVersion")
		e.Str(s.KubeletVersion)
	}
	{
		e.FieldStart("machineID")
		e.Str(s.MachineID)
	}
	{
		e.FieldStart("operatingSystem")
		e.Str(s.OperatingSystem)
	}
	{
		e.FieldStart("osImage")
		e.Str(s.OsImage)
	}
	{
		e.FieldStart("systemUUID")
		e.Str(s.SystemUUID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo = [10]string{
	0: "architecture",
	1: "bootID",
	2: "containerRuntimeVersion",
	3: "kernelVersion",
	4: "kubeProxyVersion",
	5: "kubeletVersion",
	6: "machineID",
	7: "operatingSystem",
	8: "osImage",
	9: "systemUUID",
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (s *IoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1NodeSystemInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Architecture = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "bootID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BootID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bootID\"")
			}
		case "containerRuntimeVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContainerRuntimeVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerRuntimeVersion\"")
			}
		case "kernelVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KernelVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kernelVersion\"")
			}
		case "kubeProxyVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.KubeProxyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeProxyVersion\"")
			}
		case "kubeletVersion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.KubeletVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeletVersion\"")
			}
		case "machineID":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MachineID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machineID\"")
			}
		case "operatingSystem":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.OperatingSystem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operatingSystem\"")
			}
		case "osImage":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OsImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osImage\"")
			}
		case "systemUUID":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SystemUUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemUUID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1NodeSystemInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo) {
					name = jsonFieldsNameOfIoK8sAPICoreV1NodeSystemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1NodeSystemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1NodeSystemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ObjectFieldSelector) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("fieldPath")
		e.Str(s.FieldPath)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector = [2]string{
	0: "apiVersion",
	1: "fieldPath",
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (s *IoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ObjectFieldSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FieldPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ObjectFieldSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ObjectFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ObjectFieldSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ObjectFieldSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldPath.Set {
			e.FieldStart("fieldPath")
			s.FieldPath.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ObjectReference = [7]string{
	0: "apiVersion",
	1: "fieldPath",
	2: "kind",
	3: "name",
	4: "namespace",
	5: "resourceVersion",
	6: "uid",
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (s *IoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ObjectReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldPath":
			if err := func() error {
				s.FieldPath.Reset()
				if err := s.FieldPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldPath\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ObjectReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolume) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolume) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolume = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolume from json.
func (s *IoK8sAPICoreV1PersistentVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolume to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolume")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaim = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaim from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaim to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaim")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastProbeTime.Set {
			e.FieldStart("lastProbeTime")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimCondition from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimList from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PersistentVolumeClaim, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaim
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) encodeFields(e *jx.Encoder) {
	{
		if s.AccessModes != nil {
			e.FieldStart("accessModes")
			e.ArrStart()
			for _, elem := range s.AccessModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.DataSourceRef.Set {
			e.FieldStart("dataSourceRef")
			s.DataSourceRef.Encode(e)
		}
	}
	{
		if s.Resources.Set {
			e.FieldStart("resources")
			s.Resources.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			e.FieldStart("storageClassName")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			e.FieldStart("volumeMode")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimSpec = [8]string{
	0: "accessModes",
	1: "dataSource",
	2: "dataSourceRef",
	3: "resources",
	4: "selector",
	5: "storageClassName",
	6: "volumeMode",
	7: "volumeName",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "dataSourceRef":
			if err := func() error {
				s.DataSourceRef.Reset()
				if err := s.DataSourceRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceRef\"")
			}
		case "resources":
			if err := func() error {
				s.Resources.Reset()
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		case "volumeMode":
			if err := func() error {
				s.VolumeMode.Reset()
				if err := s.VolumeMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMode\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AccessModes != nil {
			e.FieldStart("accessModes")
			e.ArrStart()
			for _, elem := range s.AccessModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimStatus = [4]string{
	0: "accessModes",
	1: "capacity",
	2: "conditions",
	3: "phase",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1PersistentVolumeClaimCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolumeClaimCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("claimName")
		e.Str(s.ClaimName)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource = [2]string{
	0: "claimName",
	1: "readOnly",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "claimName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClaimName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimName\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeClaimVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeClaimVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeClaimVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeList from json.
func (s *IoK8sAPICoreV1PersistentVolumeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PersistentVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PersistentVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) encodeFields(e *jx.Encoder) {
	{
		if s.AccessModes != nil {
			e.FieldStart("accessModes")
			e.ArrStart()
			for _, elem := range s.AccessModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AwsElasticBlockStore.Set {
			e.FieldStart("awsElasticBlockStore")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			e.FieldStart("azureDisk")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			e.FieldStart("azureFile")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			e.FieldStart("cephfs")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			e.FieldStart("cinder")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ClaimRef.Set {
			e.FieldStart("claimRef")
			s.ClaimRef.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			e.FieldStart("csi")
			s.Csi.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			e.FieldStart("fc")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			e.FieldStart("flexVolume")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			e.FieldStart("flocker")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			e.FieldStart("gcePersistentDisk")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			e.FieldStart("glusterfs")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			e.FieldStart("hostPath")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			e.FieldStart("iscsi")
			s.Iscsi.Encode(e)
		}
	}
	{
		if s.Local.Set {
			e.FieldStart("local")
			s.Local.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			e.FieldStart("mountOptions")
			e.ArrStart()
			for _, elem := range s.MountOptions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Nfs.Set {
			e.FieldStart("nfs")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.NodeAffinity.Set {
			e.FieldStart("nodeAffinity")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PersistentVolumeReclaimPolicy.Set {
			e.FieldStart("persistentVolumeReclaimPolicy")
			s.PersistentVolumeReclaimPolicy.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			e.FieldStart("photonPersistentDisk")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			e.FieldStart("portworxVolume")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			e.FieldStart("quobyte")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			e.FieldStart("rbd")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			e.FieldStart("scaleIO")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.StorageClassName.Set {
			e.FieldStart("storageClassName")
			s.StorageClassName.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			e.FieldStart("storageos")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VolumeMode.Set {
			e.FieldStart("volumeMode")
			s.VolumeMode.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			e.FieldStart("vsphereVolume")
			s.VsphereVolume.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeSpec = [30]string{
	0:  "accessModes",
	1:  "awsElasticBlockStore",
	2:  "azureDisk",
	3:  "azureFile",
	4:  "capacity",
	5:  "cephfs",
	6:  "cinder",
	7:  "claimRef",
	8:  "csi",
	9:  "fc",
	10: "flexVolume",
	11: "flocker",
	12: "gcePersistentDisk",
	13: "glusterfs",
	14: "hostPath",
	15: "iscsi",
	16: "local",
	17: "mountOptions",
	18: "nfs",
	19: "nodeAffinity",
	20: "persistentVolumeReclaimPolicy",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "quobyte",
	24: "rbd",
	25: "scaleIO",
	26: "storageClassName",
	27: "storageos",
	28: "volumeMode",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessModes":
			if err := func() error {
				s.AccessModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AccessModes = append(s.AccessModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessModes\"")
			}
		case "awsElasticBlockStore":
			if err := func() error {
				s.AwsElasticBlockStore.Reset()
				if err := s.AwsElasticBlockStore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"awsElasticBlockStore\"")
			}
		case "azureDisk":
			if err := func() error {
				s.AzureDisk.Reset()
				if err := s.AzureDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureDisk\"")
			}
		case "azureFile":
			if err := func() error {
				s.AzureFile.Reset()
				if err := s.AzureFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureFile\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "cephfs":
			if err := func() error {
				s.Cephfs.Reset()
				if err := s.Cephfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cephfs\"")
			}
		case "cinder":
			if err := func() error {
				s.Cinder.Reset()
				if err := s.Cinder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cinder\"")
			}
		case "claimRef":
			if err := func() error {
				s.ClaimRef.Reset()
				if err := s.ClaimRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimRef\"")
			}
		case "csi":
			if err := func() error {
				s.Csi.Reset()
				if err := s.Csi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csi\"")
			}
		case "fc":
			if err := func() error {
				s.Fc.Reset()
				if err := s.Fc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fc\"")
			}
		case "flexVolume":
			if err := func() error {
				s.FlexVolume.Reset()
				if err := s.FlexVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flexVolume\"")
			}
		case "flocker":
			if err := func() error {
				s.Flocker.Reset()
				if err := s.Flocker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flocker\"")
			}
		case "gcePersistentDisk":
			if err := func() error {
				s.GcePersistentDisk.Reset()
				if err := s.GcePersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gcePersistentDisk\"")
			}
		case "glusterfs":
			if err := func() error {
				s.Glusterfs.Reset()
				if err := s.Glusterfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"glusterfs\"")
			}
		case "hostPath":
			if err := func() error {
				s.HostPath.Reset()
				if err := s.HostPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPath\"")
			}
		case "iscsi":
			if err := func() error {
				s.Iscsi.Reset()
				if err := s.Iscsi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsi\"")
			}
		case "local":
			if err := func() error {
				s.Local.Reset()
				if err := s.Local.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"local\"")
			}
		case "mountOptions":
			if err := func() error {
				s.MountOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MountOptions = append(s.MountOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountOptions\"")
			}
		case "nfs":
			if err := func() error {
				s.Nfs.Reset()
				if err := s.Nfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nfs\"")
			}
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "persistentVolumeReclaimPolicy":
			if err := func() error {
				s.PersistentVolumeReclaimPolicy.Reset()
				if err := s.PersistentVolumeReclaimPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeReclaimPolicy\"")
			}
		case "photonPersistentDisk":
			if err := func() error {
				s.PhotonPersistentDisk.Reset()
				if err := s.PhotonPersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photonPersistentDisk\"")
			}
		case "portworxVolume":
			if err := func() error {
				s.PortworxVolume.Reset()
				if err := s.PortworxVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portworxVolume\"")
			}
		case "quobyte":
			if err := func() error {
				s.Quobyte.Reset()
				if err := s.Quobyte.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quobyte\"")
			}
		case "rbd":
			if err := func() error {
				s.Rbd.Reset()
				if err := s.Rbd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rbd\"")
			}
		case "scaleIO":
			if err := func() error {
				s.ScaleIO.Reset()
				if err := s.ScaleIO.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleIO\"")
			}
		case "storageClassName":
			if err := func() error {
				s.StorageClassName.Reset()
				if err := s.StorageClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		case "storageos":
			if err := func() error {
				s.Storageos.Reset()
				if err := s.Storageos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageos\"")
			}
		case "volumeMode":
			if err := func() error {
				s.VolumeMode.Reset()
				if err := s.VolumeMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeMode\"")
			}
		case "vsphereVolume":
			if err := func() error {
				s.VsphereVolume.Reset()
				if err := s.VsphereVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereVolume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpecCapacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpecCapacity) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpecCapacity from json.
func (s *IoK8sAPICoreV1PersistentVolumeSpecCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeSpecCapacity to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeSpecCapacity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1PersistentVolumeSpecCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeSpecCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PersistentVolumeStatus = [3]string{
	0: "message",
	1: "phase",
	2: "reason",
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PersistentVolumeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PersistentVolumeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PersistentVolumeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("pdID")
		e.Str(s.PdID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource = [2]string{
	0: "fsType",
	1: "pdID",
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "pdID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PdID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PhotonPersistentDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PhotonPersistentDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PhotonPersistentDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Pod) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Pod) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Pod = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Pod from json.
func (s *IoK8sAPICoreV1Pod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Pod to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Pod")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Pod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Pod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (s *IoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1WeightedPodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1WeightedPodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm = [4]string{
	0: "labelSelector",
	1: "namespaceSelector",
	2: "namespaces",
	3: "topologyKey",
}

// Decode decodes IoK8sAPICoreV1PodAffinityTerm from json.
func (s *IoK8sAPICoreV1PodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodAntiAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodAntiAffinity = [2]string{
	0: "preferredDuringSchedulingIgnoredDuringExecution",
	1: "requiredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (s *IoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodAntiAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1WeightedPodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1WeightedPodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]IoK8sAPICoreV1PodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodAntiAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodAntiAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodAntiAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastProbeTime.Set {
			e.FieldStart("lastProbeTime")
			s.LastProbeTime.Encode(e)
		}
	}
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodCondition = [6]string{
	0: "lastProbeTime",
	1: "lastTransitionTime",
	2: "message",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sAPICoreV1PodCondition from json.
func (s *IoK8sAPICoreV1PodCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastProbeTime":
			if err := func() error {
				s.LastProbeTime.Reset()
				if err := s.LastProbeTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastProbeTime\"")
			}
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodDNSConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Nameservers != nil {
			e.FieldStart("nameservers")
			e.ArrStart()
			for _, elem := range s.Nameservers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Options != nil {
			e.FieldStart("options")
			e.ArrStart()
			for _, elem := range s.Options {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Searches != nil {
			e.FieldStart("searches")
			e.ArrStart()
			for _, elem := range s.Searches {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfig = [3]string{
	0: "nameservers",
	1: "options",
	2: "searches",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (s *IoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodDNSConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nameservers":
			if err := func() error {
				s.Nameservers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nameservers = append(s.Nameservers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "options":
			if err := func() error {
				s.Options = make([]IoK8sAPICoreV1PodDNSConfigOption, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodDNSConfigOption
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "searches":
			if err := func() error {
				s.Searches = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Searches = append(s.Searches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"searches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodDNSConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodDNSConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodDNSConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodDNSConfigOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodDNSConfigOption) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodDNSConfigOption = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1PodDNSConfigOption from json.
func (s *IoK8sAPICoreV1PodDNSConfigOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodDNSConfigOption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodDNSConfigOption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodDNSConfigOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodDNSConfigOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodIP) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodIP) encodeFields(e *jx.Encoder) {
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodIP = [1]string{
	0: "ip",
}

// Decode decodes IoK8sAPICoreV1PodIP from json.
func (s *IoK8sAPICoreV1PodIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodIP to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodIP")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodIP) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodIP) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodList from json.
func (s *IoK8sAPICoreV1PodList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Pod, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Pod
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodReadinessGate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodReadinessGate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conditionType")
		e.Str(s.ConditionType)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate = [1]string{
	0: "conditionType",
}

// Decode decodes IoK8sAPICoreV1PodReadinessGate from json.
func (s *IoK8sAPICoreV1PodReadinessGate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodReadinessGate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ConditionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditionType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodReadinessGate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodReadinessGate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodReadinessGate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodReadinessGate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodSecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.FsGroup.Set {
			e.FieldStart("fsGroup")
			s.FsGroup.Encode(e)
		}
	}
	{
		if s.FsGroupChangePolicy.Set {
			e.FieldStart("fsGroupChangePolicy")
			s.FsGroupChangePolicy.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.SupplementalGroups != nil {
			e.FieldStart("supplementalGroups")
			e.ArrStart()
			for _, elem := range s.SupplementalGroups {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sysctls != nil {
			e.FieldStart("sysctls")
			e.ArrStart()
			for _, elem := range s.Sysctls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSecurityContext = [10]string{
	0: "fsGroup",
	1: "fsGroupChangePolicy",
	2: "runAsGroup",
	3: "runAsNonRoot",
	4: "runAsUser",
	5: "seLinuxOptions",
	6: "seccompProfile",
	7: "supplementalGroups",
	8: "sysctls",
	9: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (s *IoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsGroup":
			if err := func() error {
				s.FsGroup.Reset()
				if err := s.FsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroup\"")
			}
		case "fsGroupChangePolicy":
			if err := func() error {
				s.FsGroupChangePolicy.Reset()
				if err := s.FsGroupChangePolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroupChangePolicy\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "supplementalGroups":
			if err := func() error {
				s.SupplementalGroups = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.SupplementalGroups = append(s.SupplementalGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementalGroups\"")
			}
		case "sysctls":
			if err := func() error {
				s.Sysctls = make([]IoK8sAPICoreV1Sysctl, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Sysctl
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sysctls = append(s.Sysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sysctls\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodSpec) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveDeadlineSeconds.Set {
			e.FieldStart("activeDeadlineSeconds")
			s.ActiveDeadlineSeconds.Encode(e)
		}
	}
	{
		if s.Affinity.Set {
			e.FieldStart("affinity")
			s.Affinity.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			e.FieldStart("automountServiceAccountToken")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		e.FieldStart("containers")
		e.ArrStart()
		for _, elem := range s.Containers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DnsConfig.Set {
			e.FieldStart("dnsConfig")
			s.DnsConfig.Encode(e)
		}
	}
	{
		if s.DnsPolicy.Set {
			e.FieldStart("dnsPolicy")
			s.DnsPolicy.Encode(e)
		}
	}
	{
		if s.EnableServiceLinks.Set {
			e.FieldStart("enableServiceLinks")
			s.EnableServiceLinks.Encode(e)
		}
	}
	{
		if s.EphemeralContainers != nil {
			e.FieldStart("ephemeralContainers")
			e.ArrStart()
			for _, elem := range s.EphemeralContainers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostAliases != nil {
			e.FieldStart("hostAliases")
			e.ArrStart()
			for _, elem := range s.HostAliases {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIPC.Set {
			e.FieldStart("hostIPC")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.FieldStart("hostNetwork")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.FieldStart("hostPID")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			e.FieldStart("imagePullSecrets")
			e.ArrStart()
			for _, elem := range s.ImagePullSecrets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InitContainers != nil {
			e.FieldStart("initContainers")
			e.ArrStart()
			for _, elem := range s.InitContainers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeName.Set {
			e.FieldStart("nodeName")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.FieldStart("overhead")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			e.FieldStart("preemptionPolicy")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.PriorityClassName.Set {
			e.FieldStart("priorityClassName")
			s.PriorityClassName.Encode(e)
		}
	}
	{
		if s.ReadinessGates != nil {
			e.FieldStart("readinessGates")
			e.ArrStart()
			for _, elem := range s.ReadinessGates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RestartPolicy.Set {
			e.FieldStart("restartPolicy")
			s.RestartPolicy.Encode(e)
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.FieldStart("runtimeClassName")
			s.RuntimeClassName.Encode(e)
		}
	}
	{
		if s.SchedulerName.Set {
			e.FieldStart("schedulerName")
			s.SchedulerName.Encode(e)
		}
	}
	{
		if s.SecurityContext.Set {
			e.FieldStart("securityContext")
			s.SecurityContext.Encode(e)
		}
	}
	{
		if s.ServiceAccount.Set {
			e.FieldStart("serviceAccount")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.ServiceAccountName.Set {
			e.FieldStart("serviceAccountName")
			s.ServiceAccountName.Encode(e)
		}
	}
	{
		if s.SetHostnameAsFQDN.Set {
			e.FieldStart("setHostnameAsFQDN")
			s.SetHostnameAsFQDN.Encode(e)
		}
	}
	{
		if s.ShareProcessNamespace.Set {
			e.FieldStart("shareProcessNamespace")
			s.ShareProcessNamespace.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			e.FieldStart("subdomain")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			e.FieldStart("terminationGracePeriodSeconds")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TopologySpreadConstraints != nil {
			e.FieldStart("topologySpreadConstraints")
			e.ArrStart()
			for _, elem := range s.TopologySpreadConstraints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Volumes != nil {
			e.FieldStart("volumes")
			e.ArrStart()
			for _, elem := range s.Volumes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodSpec = [35]string{
	0:  "activeDeadlineSeconds",
	1:  "affinity",
	2:  "automountServiceAccountToken",
	3:  "containers",
	4:  "dnsConfig",
	5:  "dnsPolicy",
	6:  "enableServiceLinks",
	7:  "ephemeralContainers",
	8:  "hostAliases",
	9:  "hostIPC",
	10: "hostNetwork",
	11: "hostPID",
	12: "hostname",
	13: "imagePullSecrets",
	14: "initContainers",
	15: "nodeName",
	16: "nodeSelector",
	17: "overhead",
	18: "preemptionPolicy",
	19: "priority",
	20: "priorityClassName",
	21: "readinessGates",
	22: "restartPolicy",
	23: "runtimeClassName",
	24: "schedulerName",
	25: "securityContext",
	26: "serviceAccount",
	27: "serviceAccountName",
	28: "setHostnameAsFQDN",
	29: "shareProcessNamespace",
	30: "subdomain",
	31: "terminationGracePeriodSeconds",
	32: "tolerations",
	33: "topologySpreadConstraints",
	34: "volumes",
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (s *IoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpec to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeDeadlineSeconds":
			if err := func() error {
				s.ActiveDeadlineSeconds.Reset()
				if err := s.ActiveDeadlineSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeDeadlineSeconds\"")
			}
		case "affinity":
			if err := func() error {
				s.Affinity.Reset()
				if err := s.Affinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affinity\"")
			}
		case "automountServiceAccountToken":
			if err := func() error {
				s.AutomountServiceAccountToken.Reset()
				if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automountServiceAccountToken\"")
			}
		case "containers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Containers = make([]IoK8sAPICoreV1Container, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Container
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Containers = append(s.Containers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containers\"")
			}
		case "dnsConfig":
			if err := func() error {
				s.DnsConfig.Reset()
				if err := s.DnsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsConfig\"")
			}
		case "dnsPolicy":
			if err := func() error {
				s.DnsPolicy.Reset()
				if err := s.DnsPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dnsPolicy\"")
			}
		case "enableServiceLinks":
			if err := func() error {
				s.EnableServiceLinks.Reset()
				if err := s.EnableServiceLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enableServiceLinks\"")
			}
		case "ephemeralContainers":
			if err := func() error {
				s.EphemeralContainers = make([]IoK8sAPICoreV1EphemeralContainer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1EphemeralContainer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EphemeralContainers = append(s.EphemeralContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeralContainers\"")
			}
		case "hostAliases":
			if err := func() error {
				s.HostAliases = make([]IoK8sAPICoreV1HostAlias, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1HostAlias
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostAliases = append(s.HostAliases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostAliases\"")
			}
		case "hostIPC":
			if err := func() error {
				s.HostIPC.Reset()
				if err := s.HostIPC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIPC\"")
			}
		case "hostNetwork":
			if err := func() error {
				s.HostNetwork.Reset()
				if err := s.HostNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetwork\"")
			}
		case "hostPID":
			if err := func() error {
				s.HostPID.Reset()
				if err := s.HostPID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPID\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "imagePullSecrets":
			if err := func() error {
				s.ImagePullSecrets = make([]IoK8sAPICoreV1LocalObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LocalObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullSecrets\"")
			}
		case "initContainers":
			if err := func() error {
				s.InitContainers = make([]IoK8sAPICoreV1Container, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Container
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InitContainers = append(s.InitContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initContainers\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "preemptionPolicy":
			if err := func() error {
				s.PreemptionPolicy.Reset()
				if err := s.PreemptionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preemptionPolicy\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "priorityClassName":
			if err := func() error {
				s.PriorityClassName.Reset()
				if err := s.PriorityClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityClassName\"")
			}
		case "readinessGates":
			if err := func() error {
				s.ReadinessGates = make([]IoK8sAPICoreV1PodReadinessGate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodReadinessGate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadinessGates = append(s.ReadinessGates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessGates\"")
			}
		case "restartPolicy":
			if err := func() error {
				s.RestartPolicy.Reset()
				if err := s.RestartPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restartPolicy\"")
			}
		case "runtimeClassName":
			if err := func() error {
				s.RuntimeClassName.Reset()
				if err := s.RuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClassName\"")
			}
		case "schedulerName":
			if err := func() error {
				s.SchedulerName.Reset()
				if err := s.SchedulerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedulerName\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "serviceAccountName":
			if err := func() error {
				s.ServiceAccountName.Reset()
				if err := s.ServiceAccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountName\"")
			}
		case "setHostnameAsFQDN":
			if err := func() error {
				s.SetHostnameAsFQDN.Reset()
				if err := s.SetHostnameAsFQDN.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setHostnameAsFQDN\"")
			}
		case "shareProcessNamespace":
			if err := func() error {
				s.ShareProcessNamespace.Reset()
				if err := s.ShareProcessNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareProcessNamespace\"")
			}
		case "subdomain":
			if err := func() error {
				s.Subdomain.Reset()
				if err := s.Subdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdomain\"")
			}
		case "terminationGracePeriodSeconds":
			if err := func() error {
				s.TerminationGracePeriodSeconds.Reset()
				if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationGracePeriodSeconds\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		case "topologySpreadConstraints":
			if err := func() error {
				s.TopologySpreadConstraints = make([]IoK8sAPICoreV1TopologySpreadConstraint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySpreadConstraint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopologySpreadConstraints = append(s.TopologySpreadConstraints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologySpreadConstraints\"")
			}
		case "volumes":
			if err := func() error {
				s.Volumes = make([]IoK8sAPICoreV1Volume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Volume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Volumes = append(s.Volumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodSpec) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1PodSpecNodeSelector from json.
func (s *IoK8sAPICoreV1PodSpecNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpecNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpecNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1PodSpecNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodSpecNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecOverhead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1PodSpecOverhead) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1PodSpecOverhead from json.
func (s *IoK8sAPICoreV1PodSpecOverhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodSpecOverhead to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodSpecOverhead")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1PodSpecOverhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodSpecOverhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContainerStatuses != nil {
			e.FieldStart("containerStatuses")
			e.ArrStart()
			for _, elem := range s.ContainerStatuses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EphemeralContainerStatuses != nil {
			e.FieldStart("ephemeralContainerStatuses")
			e.ArrStart()
			for _, elem := range s.EphemeralContainerStatuses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HostIP.Set {
			e.FieldStart("hostIP")
			s.HostIP.Encode(e)
		}
	}
	{
		if s.InitContainerStatuses != nil {
			e.FieldStart("initContainerStatuses")
			e.ArrStart()
			for _, elem := range s.InitContainerStatuses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.NominatedNodeName.Set {
			e.FieldStart("nominatedNodeName")
			s.NominatedNodeName.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
	{
		if s.PodIP.Set {
			e.FieldStart("podIP")
			s.PodIP.Encode(e)
		}
	}
	{
		if s.PodIPs != nil {
			e.FieldStart("podIPs")
			e.ArrStart()
			for _, elem := range s.PodIPs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.QosClass.Set {
			e.FieldStart("qosClass")
			s.QosClass.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("startTime")
			s.StartTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodStatus = [13]string{
	0:  "conditions",
	1:  "containerStatuses",
	2:  "ephemeralContainerStatuses",
	3:  "hostIP",
	4:  "initContainerStatuses",
	5:  "message",
	6:  "nominatedNodeName",
	7:  "phase",
	8:  "podIP",
	9:  "podIPs",
	10: "qosClass",
	11: "reason",
	12: "startTime",
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (s *IoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1PodCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "containerStatuses":
			if err := func() error {
				s.ContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ContainerStatuses = append(s.ContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerStatuses\"")
			}
		case "ephemeralContainerStatuses":
			if err := func() error {
				s.EphemeralContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EphemeralContainerStatuses = append(s.EphemeralContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeralContainerStatuses\"")
			}
		case "hostIP":
			if err := func() error {
				s.HostIP.Reset()
				if err := s.HostIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIP\"")
			}
		case "initContainerStatuses":
			if err := func() error {
				s.InitContainerStatuses = make([]IoK8sAPICoreV1ContainerStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ContainerStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InitContainerStatuses = append(s.InitContainerStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initContainerStatuses\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "nominatedNodeName":
			if err := func() error {
				s.NominatedNodeName.Reset()
				if err := s.NominatedNodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominatedNodeName\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "podIP":
			if err := func() error {
				s.PodIP.Reset()
				if err := s.PodIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podIP\"")
			}
		case "podIPs":
			if err := func() error {
				s.PodIPs = make([]IoK8sAPICoreV1PodIP, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodIP
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PodIPs = append(s.PodIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podIPs\"")
			}
		case "qosClass":
			if err := func() error {
				s.QosClass.Reset()
				if err := s.QosClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"qosClass\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodTemplate) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplate = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1PodTemplate from json.
func (s *IoK8sAPICoreV1PodTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodTemplateList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodTemplateList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1PodTemplateList from json.
func (s *IoK8sAPICoreV1PodTemplateList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplateList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1PodTemplate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1PodTemplate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplateList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PodTemplateList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodTemplateList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodTemplateList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PodTemplateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PodTemplateSpec = [2]string{
	0: "metadata",
	1: "spec",
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (s *IoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PodTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PodTemplateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PodTemplateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PodTemplateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PortStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PortStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		e.FieldStart("protocol")
		e.Str(s.Protocol)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PortStatus = [3]string{
	0: "error",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPICoreV1PortStatus from json.
func (s *IoK8sAPICoreV1PortStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PortStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Protocol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PortStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PortStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PortStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PortworxVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("volumeID")
		e.Str(s.VolumeID)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource = [3]string{
	0: "fsType",
	1: "readOnly",
	2: "volumeID",
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (s *IoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PortworxVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "volumeID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PortworxVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PortworxVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PortworxVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PortworxVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("preference")
		s.Preference.Encode(e)
	}
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm = [2]string{
	0: "preference",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1PreferredSchedulingTerm from json.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1PreferredSchedulingTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preference":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Preference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preference\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1PreferredSchedulingTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1PreferredSchedulingTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1PreferredSchedulingTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Probe) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Probe) encodeFields(e *jx.Encoder) {
	{
		if s.Exec.Set {
			e.FieldStart("exec")
			s.Exec.Encode(e)
		}
	}
	{
		if s.FailureThreshold.Set {
			e.FieldStart("failureThreshold")
			s.FailureThreshold.Encode(e)
		}
	}
	{
		if s.HttpGet.Set {
			e.FieldStart("httpGet")
			s.HttpGet.Encode(e)
		}
	}
	{
		if s.InitialDelaySeconds.Set {
			e.FieldStart("initialDelaySeconds")
			s.InitialDelaySeconds.Encode(e)
		}
	}
	{
		if s.PeriodSeconds.Set {
			e.FieldStart("periodSeconds")
			s.PeriodSeconds.Encode(e)
		}
	}
	{
		if s.SuccessThreshold.Set {
			e.FieldStart("successThreshold")
			s.SuccessThreshold.Encode(e)
		}
	}
	{
		if s.TcpSocket.Set {
			e.FieldStart("tcpSocket")
			s.TcpSocket.Encode(e)
		}
	}
	{
		if s.TerminationGracePeriodSeconds.Set {
			e.FieldStart("terminationGracePeriodSeconds")
			s.TerminationGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.TimeoutSeconds.Set {
			e.FieldStart("timeoutSeconds")
			s.TimeoutSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Probe = [9]string{
	0: "exec",
	1: "failureThreshold",
	2: "httpGet",
	3: "initialDelaySeconds",
	4: "periodSeconds",
	5: "successThreshold",
	6: "tcpSocket",
	7: "terminationGracePeriodSeconds",
	8: "timeoutSeconds",
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (s *IoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Probe to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exec":
			if err := func() error {
				s.Exec.Reset()
				if err := s.Exec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exec\"")
			}
		case "failureThreshold":
			if err := func() error {
				s.FailureThreshold.Reset()
				if err := s.FailureThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failureThreshold\"")
			}
		case "httpGet":
			if err := func() error {
				s.HttpGet.Reset()
				if err := s.HttpGet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpGet\"")
			}
		case "initialDelaySeconds":
			if err := func() error {
				s.InitialDelaySeconds.Reset()
				if err := s.InitialDelaySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialDelaySeconds\"")
			}
		case "periodSeconds":
			if err := func() error {
				s.PeriodSeconds.Reset()
				if err := s.PeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"periodSeconds\"")
			}
		case "successThreshold":
			if err := func() error {
				s.SuccessThreshold.Reset()
				if err := s.SuccessThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successThreshold\"")
			}
		case "tcpSocket":
			if err := func() error {
				s.TcpSocket.Reset()
				if err := s.TcpSocket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tcpSocket\"")
			}
		case "terminationGracePeriodSeconds":
			if err := func() error {
				s.TerminationGracePeriodSeconds.Reset()
				if err := s.TerminationGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminationGracePeriodSeconds\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Probe")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Probe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Probe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultMode.Set {
			e.FieldStart("defaultMode")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Sources != nil {
			e.FieldStart("sources")
			e.ArrStart()
			for _, elem := range s.Sources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ProjectedVolumeSource = [2]string{
	0: "defaultMode",
	1: "sources",
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ProjectedVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "sources":
			if err := func() error {
				s.Sources = make([]IoK8sAPICoreV1VolumeProjection, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1VolumeProjection
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sources = append(s.Sources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ProjectedVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ProjectedVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("registry")
		e.Str(s.Registry)
	}
	{
		if s.Tenant.Set {
			e.FieldStart("tenant")
			s.Tenant.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		e.FieldStart("volume")
		e.Str(s.Volume)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource = [6]string{
	0: "group",
	1: "readOnly",
	2: "registry",
	3: "tenant",
	4: "user",
	5: "volume",
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1QuobyteVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "registry":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Registry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registry\"")
			}
		case "tenant":
			if err := func() error {
				s.Tenant.Reset()
				if err := s.Tenant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenant\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "volume":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Volume = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1QuobyteVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1QuobyteVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1QuobyteVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.FieldStart("keyring")
			s.Keyring.Encode(e)
		}
	}
	{
		e.FieldStart("monitors")
		e.ArrStart()
		for _, elem := range s.Monitors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.FieldStart("pool")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1RBDPersistentVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "keyring":
			if err := func() error {
				s.Keyring.Reset()
				if err := s.Keyring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyring\"")
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "pool":
			if err := func() error {
				s.Pool.Reset()
				if err := s.Pool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1RBDPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1RBDPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1RBDVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		if s.Keyring.Set {
			e.FieldStart("keyring")
			s.Keyring.Encode(e)
		}
	}
	{
		e.FieldStart("monitors")
		e.ArrStart()
		for _, elem := range s.Monitors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Pool.Set {
			e.FieldStart("pool")
			s.Pool.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource = [8]string{
	0: "fsType",
	1: "image",
	2: "keyring",
	3: "monitors",
	4: "pool",
	5: "readOnly",
	6: "secretRef",
	7: "user",
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (s *IoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1RBDVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "keyring":
			if err := func() error {
				s.Keyring.Reset()
				if err := s.Keyring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyring\"")
			}
		case "monitors":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Monitors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Monitors = append(s.Monitors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monitors\"")
			}
		case "pool":
			if err := func() error {
				s.Pool.Reset()
				if err := s.Pool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1RBDVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1RBDVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1RBDVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1RBDVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ReplicationController) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ReplicationController) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationController = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ReplicationController from json.
func (s *IoK8sAPICoreV1ReplicationController) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationController to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationController")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ReplicationController) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationController) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerCondition from json.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationControllerCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ReplicationControllerList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerList from json.
func (s *IoK8sAPICoreV1ReplicationControllerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ReplicationController, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ReplicationController
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationControllerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MinReadySeconds.Set {
			e.FieldStart("minReadySeconds")
			s.MinReadySeconds.Encode(e)
		}
	}
	{
		if s.Replicas.Set {
			e.FieldStart("replicas")
			s.Replicas.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerSpec = [4]string{
	0: "minReadySeconds",
	1: "replicas",
	2: "selector",
	3: "template",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minReadySeconds":
			if err := func() error {
				s.MinReadySeconds.Reset()
				if err := s.MinReadySeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minReadySeconds\"")
			}
		case "replicas":
			if err := func() error {
				s.Replicas.Reset()
				if err := s.Replicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationControllerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpecSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpecSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpecSelector from json.
func (s *IoK8sAPICoreV1ReplicationControllerSpecSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerSpecSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerSpecSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ReplicationControllerSpecSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationControllerSpecSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AvailableReplicas.Set {
			e.FieldStart("availableReplicas")
			s.AvailableReplicas.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FullyLabeledReplicas.Set {
			e.FieldStart("fullyLabeledReplicas")
			s.FullyLabeledReplicas.Encode(e)
		}
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.FieldStart("readyReplicas")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		e.FieldStart("replicas")
		e.Int32(s.Replicas)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus = [6]string{
	0: "availableReplicas",
	1: "conditions",
	2: "fullyLabeledReplicas",
	3: "observedGeneration",
	4: "readyReplicas",
	5: "replicas",
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ReplicationControllerStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availableReplicas":
			if err := func() error {
				s.AvailableReplicas.Reset()
				if err := s.AvailableReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableReplicas\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPICoreV1ReplicationControllerCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ReplicationControllerCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "fullyLabeledReplicas":
			if err := func() error {
				s.FullyLabeledReplicas.Reset()
				if err := s.FullyLabeledReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullyLabeledReplicas\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "readyReplicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readyReplicas\"")
			}
		case "replicas":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Replicas = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ReplicationControllerStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ReplicationControllerStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ReplicationControllerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceFieldSelector) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerName.Set {
			e.FieldStart("containerName")
			s.ContainerName.Encode(e)
		}
	}
	{
		if s.Divisor.Set {
			e.FieldStart("divisor")
			s.Divisor.Encode(e)
		}
	}
	{
		e.FieldStart("resource")
		e.Str(s.Resource)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector = [3]string{
	0: "containerName",
	1: "divisor",
	2: "resource",
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (s *IoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceFieldSelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerName":
			if err := func() error {
				s.ContainerName.Reset()
				if err := s.ContainerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerName\"")
			}
		case "divisor":
			if err := func() error {
				s.Divisor.Reset()
				if err := s.Divisor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divisor\"")
			}
		case "resource":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Resource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceFieldSelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceFieldSelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceFieldSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceFieldSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceQuota) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuota = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1ResourceQuota from json.
func (s *IoK8sAPICoreV1ResourceQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuota")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceQuotaList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaList from json.
func (s *IoK8sAPICoreV1ResourceQuotaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ResourceQuota, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ResourceQuota
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Hard.Set {
			e.FieldStart("hard")
			s.Hard.Encode(e)
		}
	}
	{
		if s.ScopeSelector.Set {
			e.FieldStart("scopeSelector")
			s.ScopeSelector.Encode(e)
		}
	}
	{
		if s.Scopes != nil {
			e.FieldStart("scopes")
			e.ArrStart()
			for _, elem := range s.Scopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaSpec = [3]string{
	0: "hard",
	1: "scopeSelector",
	2: "scopes",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			if err := func() error {
				s.Hard.Reset()
				if err := s.Hard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard\"")
			}
		case "scopeSelector":
			if err := func() error {
				s.ScopeSelector.Reset()
				if err := s.ScopeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopeSelector\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpecHard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpecHard) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpecHard from json.
func (s *IoK8sAPICoreV1ResourceQuotaSpecHard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaSpecHard to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaSpecHard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaSpecHard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaSpecHard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Hard.Set {
			e.FieldStart("hard")
			s.Hard.Encode(e)
		}
	}
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceQuotaStatus = [2]string{
	0: "hard",
	1: "used",
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hard":
			if err := func() error {
				s.Hard.Reset()
				if err := s.Hard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusHard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusHard) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusHard from json.
func (s *IoK8sAPICoreV1ResourceQuotaStatusHard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatusHard to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatusHard")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusHard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaStatusHard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusUsed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusUsed) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusUsed from json.
func (s *IoK8sAPICoreV1ResourceQuotaStatusUsed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceQuotaStatusUsed to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceQuotaStatusUsed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ResourceQuotaStatusUsed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceQuotaStatusUsed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ResourceRequirements) encodeFields(e *jx.Encoder) {
	{
		if s.Limits.Set {
			e.FieldStart("limits")
			s.Limits.Encode(e)
		}
	}
	{
		if s.Requests.Set {
			e.FieldStart("requests")
			s.Requests.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ResourceRequirements = [2]string{
	0: "limits",
	1: "requests",
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (s *IoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirements to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limits":
			if err := func() error {
				s.Limits.Reset()
				if err := s.Limits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limits\"")
			}
		case "requests":
			if err := func() error {
				s.Requests.Reset()
				if err := s.Requests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirements")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ResourceRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsLimits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsLimits) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsLimits from json.
func (s *IoK8sAPICoreV1ResourceRequirementsLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirementsLimits to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirementsLimits")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceRequirementsLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsRequests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsRequests from json.
func (s *IoK8sAPICoreV1ResourceRequirementsRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ResourceRequirementsRequests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ResourceRequirementsRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ResourceRequirementsRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ResourceRequirementsRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SELinuxOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SELinuxOptions = [4]string{
	0: "level",
	1: "role",
	2: "type",
	3: "user",
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (s *IoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SELinuxOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SELinuxOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SELinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SELinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.FieldStart("protectionDomain")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("secretRef")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.FieldStart("sslEnabled")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.FieldStart("storageMode")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.FieldStart("storagePool")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.FieldStart("system")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "protectionDomain":
			if err := func() error {
				s.ProtectionDomain.Reset()
				if err := s.ProtectionDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protectionDomain\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "sslEnabled":
			if err := func() error {
				s.SslEnabled.Reset()
				if err := s.SslEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslEnabled\"")
			}
		case "storageMode":
			if err := func() error {
				s.StorageMode.Reset()
				if err := s.StorageMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageMode\"")
			}
		case "storagePool":
			if err := func() error {
				s.StoragePool.Reset()
				if err := s.StoragePool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePool\"")
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.System = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScaleIOPersistentVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOPersistentVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ScaleIOPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		e.FieldStart("gateway")
		e.Str(s.Gateway)
	}
	{
		if s.ProtectionDomain.Set {
			e.FieldStart("protectionDomain")
			s.ProtectionDomain.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		e.FieldStart("secretRef")
		s.SecretRef.Encode(e)
	}
	{
		if s.SslEnabled.Set {
			e.FieldStart("sslEnabled")
			s.SslEnabled.Encode(e)
		}
	}
	{
		if s.StorageMode.Set {
			e.FieldStart("storageMode")
			s.StorageMode.Encode(e)
		}
	}
	{
		if s.StoragePool.Set {
			e.FieldStart("storagePool")
			s.StoragePool.Encode(e)
		}
	}
	{
		e.FieldStart("system")
		e.Str(s.System)
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource = [10]string{
	0: "fsType",
	1: "gateway",
	2: "protectionDomain",
	3: "readOnly",
	4: "secretRef",
	5: "sslEnabled",
	6: "storageMode",
	7: "storagePool",
	8: "system",
	9: "volumeName",
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScaleIOVolumeSource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "gateway":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Gateway = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gateway\"")
			}
		case "protectionDomain":
			if err := func() error {
				s.ProtectionDomain.Reset()
				if err := s.ProtectionDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protectionDomain\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "sslEnabled":
			if err := func() error {
				s.SslEnabled.Reset()
				if err := s.SslEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sslEnabled\"")
			}
		case "storageMode":
			if err := func() error {
				s.StorageMode.Reset()
				if err := s.StorageMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageMode\"")
			}
		case "storagePool":
			if err := func() error {
				s.StoragePool.Reset()
				if err := s.StoragePool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePool\"")
			}
		case "system":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.System = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScaleIOVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScaleIOVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ScaleIOVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ScopeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ScopeSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopeSelector = [1]string{
	0: "matchExpressions",
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (s *IoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScopeSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sAPICoreV1ScopedResourceSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ScopedResourceSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScopeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ScopeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ScopeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		e.FieldStart("scopeName")
		e.Str(s.ScopeName)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement = [3]string{
	0: "operator",
	1: "scopeName",
	2: "values",
}

// Decode decodes IoK8sAPICoreV1ScopedResourceSelectorRequirement from json.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ScopedResourceSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operator":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "scopeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ScopeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopeName\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ScopedResourceSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ScopedResourceSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ScopedResourceSelectorRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SeccompProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SeccompProfile) encodeFields(e *jx.Encoder) {
	{
		if s.LocalhostProfile.Set {
			e.FieldStart("localhostProfile")
			s.LocalhostProfile.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile = [2]string{
	0: "localhostProfile",
	1: "type",
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (s *IoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SeccompProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "localhostProfile":
			if err := func() error {
				s.LocalhostProfile.Reset()
				if err := s.LocalhostProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localhostProfile\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SeccompProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SeccompProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Secret) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Secret) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Immutable.Set {
			e.FieldStart("immutable")
			s.Immutable.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.StringData.Set {
			e.FieldStart("stringData")
			s.StringData.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Secret = [7]string{
	0: "apiVersion",
	1: "data",
	2: "immutable",
	3: "kind",
	4: "metadata",
	5: "stringData",
	6: "type",
}

// Decode decodes IoK8sAPICoreV1Secret from json.
func (s *IoK8sAPICoreV1Secret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Secret to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "immutable":
			if err := func() error {
				s.Immutable.Reset()
				if err := s.Immutable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immutable\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "stringData":
			if err := func() error {
				s.StringData.Reset()
				if err := s.StringData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stringData\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Secret")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Secret) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Secret) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1SecretData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Base64(elem)
	}
}

// Decode decodes IoK8sAPICoreV1SecretData from json.
func (s *IoK8sAPICoreV1SecretData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []byte
		if err := func() error {
			v, err := d.Base64()
			elem = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1SecretData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretEnvSource) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretEnvSource = [2]string{
	0: "name",
	1: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (s *IoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretEnvSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretEnvSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretEnvSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretEnvSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretKeySelector) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector = [3]string{
	0: "key",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (s *IoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretKeySelector to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretKeySelector")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretKeySelector[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretKeySelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretKeySelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1SecretList from json.
func (s *IoK8sAPICoreV1SecretList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Secret, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Secret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1SecretList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1SecretList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretProjection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretProjection) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretProjection = [3]string{
	0: "items",
	1: "name",
	2: "optional",
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (s *IoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretProjection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretReference) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretReference = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (s *IoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1SecretStringData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1SecretStringData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1SecretStringData from json.
func (s *IoK8sAPICoreV1SecretStringData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretStringData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretStringData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1SecretStringData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretStringData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecretVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultMode.Set {
			e.FieldStart("defaultMode")
			s.DefaultMode.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Optional.Set {
			e.FieldStart("optional")
			s.Optional.Encode(e)
		}
	}
	{
		if s.SecretName.Set {
			e.FieldStart("secretName")
			s.SecretName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecretVolumeSource = [4]string{
	0: "defaultMode",
	1: "items",
	2: "optional",
	3: "secretName",
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (s *IoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecretVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultMode":
			if err := func() error {
				s.DefaultMode.Reset()
				if err := s.DefaultMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultMode\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1KeyToPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1KeyToPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "optional":
			if err := func() error {
				s.Optional.Reset()
				if err := s.Optional.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional\"")
			}
		case "secretName":
			if err := func() error {
				s.SecretName.Reset()
				if err := s.SecretName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecretVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecretVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecretVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.AllowPrivilegeEscalation.Set {
			e.FieldStart("allowPrivilegeEscalation")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.Capabilities.Set {
			e.FieldStart("capabilities")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.Privileged.Set {
			e.FieldStart("privileged")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ProcMount.Set {
			e.FieldStart("procMount")
			s.ProcMount.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.FieldStart("readOnlyRootFilesystem")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		if s.RunAsNonRoot.Set {
			e.FieldStart("runAsNonRoot")
			s.RunAsNonRoot.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
	{
		if s.SeccompProfile.Set {
			e.FieldStart("seccompProfile")
			s.SeccompProfile.Encode(e)
		}
	}
	{
		if s.WindowsOptions.Set {
			e.FieldStart("windowsOptions")
			s.WindowsOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SecurityContext = [11]string{
	0:  "allowPrivilegeEscalation",
	1:  "capabilities",
	2:  "privileged",
	3:  "procMount",
	4:  "readOnlyRootFilesystem",
	5:  "runAsGroup",
	6:  "runAsNonRoot",
	7:  "runAsUser",
	8:  "seLinuxOptions",
	9:  "seccompProfile",
	10: "windowsOptions",
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (s *IoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "procMount":
			if err := func() error {
				s.ProcMount.Reset()
				if err := s.ProcMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"procMount\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsNonRoot":
			if err := func() error {
				s.RunAsNonRoot.Reset()
				if err := s.RunAsNonRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsNonRoot\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		case "seccompProfile":
			if err := func() error {
				s.SeccompProfile.Reset()
				if err := s.SeccompProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seccompProfile\"")
			}
		case "windowsOptions":
			if err := func() error {
				s.WindowsOptions.Reset()
				if err := s.WindowsOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"windowsOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Service) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Service) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Service = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPICoreV1Service from json.
func (s *IoK8sAPICoreV1Service) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Service to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Service")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Service) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Service) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceAccount) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.AutomountServiceAccountToken.Set {
			e.FieldStart("automountServiceAccountToken")
			s.AutomountServiceAccountToken.Encode(e)
		}
	}
	{
		if s.ImagePullSecrets != nil {
			e.FieldStart("imagePullSecrets")
			e.ArrStart()
			for _, elem := range s.ImagePullSecrets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Secrets != nil {
			e.FieldStart("secrets")
			e.ArrStart()
			for _, elem := range s.Secrets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccount = [6]string{
	0: "apiVersion",
	1: "automountServiceAccountToken",
	2: "imagePullSecrets",
	3: "kind",
	4: "metadata",
	5: "secrets",
}

// Decode decodes IoK8sAPICoreV1ServiceAccount from json.
func (s *IoK8sAPICoreV1ServiceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "automountServiceAccountToken":
			if err := func() error {
				s.AutomountServiceAccountToken.Reset()
				if err := s.AutomountServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automountServiceAccountToken\"")
			}
		case "imagePullSecrets":
			if err := func() error {
				s.ImagePullSecrets = make([]IoK8sAPICoreV1LocalObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1LocalObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImagePullSecrets = append(s.ImagePullSecrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullSecrets\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets = make([]IoK8sAPICoreV1ObjectReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ObjectReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccountList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceAccountList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountList from json.
func (s *IoK8sAPICoreV1ServiceAccountList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccountList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1ServiceAccount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ServiceAccount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccountList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccountList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceAccountList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) encodeFields(e *jx.Encoder) {
	{
		if s.Audience.Set {
			e.FieldStart("audience")
			s.Audience.Encode(e)
		}
	}
	{
		if s.ExpirationSeconds.Set {
			e.FieldStart("expirationSeconds")
			s.ExpirationSeconds.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection = [3]string{
	0: "audience",
	1: "expirationSeconds",
	2: "path",
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceAccountTokenProjection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			if err := func() error {
				s.Audience.Reset()
				if err := s.Audience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audience\"")
			}
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceAccountTokenProjection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceAccountTokenProjection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceAccountTokenProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPICoreV1ServiceList from json.
func (s *IoK8sAPICoreV1ServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPICoreV1Service, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Service
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServiceList) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServicePort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServicePort) encodeFields(e *jx.Encoder) {
	{
		if s.AppProtocol.Set {
			e.FieldStart("appProtocol")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodePort.Set {
			e.FieldStart("nodePort")
			s.NodePort.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.TargetPort.Set {
			e.FieldStart("targetPort")
			s.TargetPort.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServicePort = [6]string{
	0: "appProtocol",
	1: "name",
	2: "nodePort",
	3: "port",
	4: "protocol",
	5: "targetPort",
}

// Decode decodes IoK8sAPICoreV1ServicePort from json.
func (s *IoK8sAPICoreV1ServicePort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServicePort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodePort":
			if err := func() error {
				s.NodePort.Reset()
				if err := s.NodePort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePort\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "targetPort":
			if err := func() error {
				s.TargetPort.Reset()
				if err := s.TargetPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetPort\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServicePort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1ServicePort) {
					name = jsonFieldsNameOfIoK8sAPICoreV1ServicePort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServicePort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServicePort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceSpec) encodeFields(e *jx.Encoder) {
	{
		if s.AllocateLoadBalancerNodePorts.Set {
			e.FieldStart("allocateLoadBalancerNodePorts")
			s.AllocateLoadBalancerNodePorts.Encode(e)
		}
	}
	{
		if s.ClusterIP.Set {
			e.FieldStart("clusterIP")
			s.ClusterIP.Encode(e)
		}
	}
	{
		if s.ClusterIPs != nil {
			e.FieldStart("clusterIPs")
			e.ArrStart()
			for _, elem := range s.ClusterIPs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalIPs != nil {
			e.FieldStart("externalIPs")
			e.ArrStart()
			for _, elem := range s.ExternalIPs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalName.Set {
			e.FieldStart("externalName")
			s.ExternalName.Encode(e)
		}
	}
	{
		if s.ExternalTrafficPolicy.Set {
			e.FieldStart("externalTrafficPolicy")
			s.ExternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.HealthCheckNodePort.Set {
			e.FieldStart("healthCheckNodePort")
			s.HealthCheckNodePort.Encode(e)
		}
	}
	{
		if s.InternalTrafficPolicy.Set {
			e.FieldStart("internalTrafficPolicy")
			s.InternalTrafficPolicy.Encode(e)
		}
	}
	{
		if s.IpFamilies != nil {
			e.FieldStart("ipFamilies")
			e.ArrStart()
			for _, elem := range s.IpFamilies {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IpFamilyPolicy.Set {
			e.FieldStart("ipFamilyPolicy")
			s.IpFamilyPolicy.Encode(e)
		}
	}
	{
		if s.LoadBalancerClass.Set {
			e.FieldStart("loadBalancerClass")
			s.LoadBalancerClass.Encode(e)
		}
	}
	{
		if s.LoadBalancerIP.Set {
			e.FieldStart("loadBalancerIP")
			s.LoadBalancerIP.Encode(e)
		}
	}
	{
		if s.LoadBalancerSourceRanges != nil {
			e.FieldStart("loadBalancerSourceRanges")
			e.ArrStart()
			for _, elem := range s.LoadBalancerSourceRanges {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PublishNotReadyAddresses.Set {
			e.FieldStart("publishNotReadyAddresses")
			s.PublishNotReadyAddresses.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
	{
		if s.SessionAffinity.Set {
			e.FieldStart("sessionAffinity")
			s.SessionAffinity.Encode(e)
		}
	}
	{
		if s.SessionAffinityConfig.Set {
			e.FieldStart("sessionAffinityConfig")
			s.SessionAffinityConfig.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceSpec = [19]string{
	0:  "allocateLoadBalancerNodePorts",
	1:  "clusterIP",
	2:  "clusterIPs",
	3:  "externalIPs",
	4:  "externalName",
	5:  "externalTrafficPolicy",
	6:  "healthCheckNodePort",
	7:  "internalTrafficPolicy",
	8:  "ipFamilies",
	9:  "ipFamilyPolicy",
	10: "loadBalancerClass",
	11: "loadBalancerIP",
	12: "loadBalancerSourceRanges",
	13: "ports",
	14: "publishNotReadyAddresses",
	15: "selector",
	16: "sessionAffinity",
	17: "sessionAffinityConfig",
	18: "type",
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (s *IoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocateLoadBalancerNodePorts":
			if err := func() error {
				s.AllocateLoadBalancerNodePorts.Reset()
				if err := s.AllocateLoadBalancerNodePorts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocateLoadBalancerNodePorts\"")
			}
		case "clusterIP":
			if err := func() error {
				s.ClusterIP.Reset()
				if err := s.ClusterIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIP\"")
			}
		case "clusterIPs":
			if err := func() error {
				s.ClusterIPs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ClusterIPs = append(s.ClusterIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterIPs\"")
			}
		case "externalIPs":
			if err := func() error {
				s.ExternalIPs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExternalIPs = append(s.ExternalIPs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalIPs\"")
			}
		case "externalName":
			if err := func() error {
				s.ExternalName.Reset()
				if err := s.ExternalName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalName\"")
			}
		case "externalTrafficPolicy":
			if err := func() error {
				s.ExternalTrafficPolicy.Reset()
				if err := s.ExternalTrafficPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalTrafficPolicy\"")
			}
		case "healthCheckNodePort":
			if err := func() error {
				s.HealthCheckNodePort.Reset()
				if err := s.HealthCheckNodePort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthCheckNodePort\"")
			}
		case "internalTrafficPolicy":
			if err := func() error {
				s.InternalTrafficPolicy.Reset()
				if err := s.InternalTrafficPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalTrafficPolicy\"")
			}
		case "ipFamilies":
			if err := func() error {
				s.IpFamilies = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IpFamilies = append(s.IpFamilies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipFamilies\"")
			}
		case "ipFamilyPolicy":
			if err := func() error {
				s.IpFamilyPolicy.Reset()
				if err := s.IpFamilyPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipFamilyPolicy\"")
			}
		case "loadBalancerClass":
			if err := func() error {
				s.LoadBalancerClass.Reset()
				if err := s.LoadBalancerClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerClass\"")
			}
		case "loadBalancerIP":
			if err := func() error {
				s.LoadBalancerIP.Reset()
				if err := s.LoadBalancerIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerIP\"")
			}
		case "loadBalancerSourceRanges":
			if err := func() error {
				s.LoadBalancerSourceRanges = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LoadBalancerSourceRanges = append(s.LoadBalancerSourceRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancerSourceRanges\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPICoreV1ServicePort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1ServicePort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "publishNotReadyAddresses":
			if err := func() error {
				s.PublishNotReadyAddresses.Reset()
				if err := s.PublishNotReadyAddresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishNotReadyAddresses\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		case "sessionAffinity":
			if err := func() error {
				s.SessionAffinity.Reset()
				if err := s.SessionAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionAffinity\"")
			}
		case "sessionAffinityConfig":
			if err := func() error {
				s.SessionAffinityConfig.Reset()
				if err := s.SessionAffinityConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionAffinityConfig\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceSpecSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPICoreV1ServiceSpecSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPICoreV1ServiceSpecSelector from json.
func (s *IoK8sAPICoreV1ServiceSpecSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceSpecSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceSpecSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPICoreV1ServiceSpecSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceSpecSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1ServiceStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1ServiceStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LoadBalancer.Set {
			e.FieldStart("loadBalancer")
			s.LoadBalancer.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1ServiceStatus = [2]string{
	0: "conditions",
	1: "loadBalancer",
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (s *IoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1ServiceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "loadBalancer":
			if err := func() error {
				s.LoadBalancer.Reset()
				if err := s.LoadBalancer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1ServiceStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1ServiceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1ServiceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1SessionAffinityConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ClientIP.Set {
			e.FieldStart("clientIP")
			s.ClientIP.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1SessionAffinityConfig = [1]string{
	0: "clientIP",
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (s *IoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1SessionAffinityConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientIP":
			if err := func() error {
				s.ClientIP.Reset()
				if err := s.ClientIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientIP\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1SessionAffinityConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1SessionAffinityConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1SessionAffinityConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			e.FieldStart("volumeNamespace")
			s.VolumeNamespace.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSPersistentVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1StorageOSPersistentVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		case "volumeNamespace":
			if err := func() error {
				s.VolumeNamespace.Reset()
				if err := s.VolumeNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeNamespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1StorageOSPersistentVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1StorageOSPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SecretRef.Set {
			e.FieldStart("secretRef")
			s.SecretRef.Encode(e)
		}
	}
	{
		if s.VolumeName.Set {
			e.FieldStart("volumeName")
			s.VolumeName.Encode(e)
		}
	}
	{
		if s.VolumeNamespace.Set {
			e.FieldStart("volumeNamespace")
			s.VolumeNamespace.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1StorageOSVolumeSource = [5]string{
	0: "fsType",
	1: "readOnly",
	2: "secretRef",
	3: "volumeName",
	4: "volumeNamespace",
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1StorageOSVolumeSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "secretRef":
			if err := func() error {
				s.SecretRef.Reset()
				if err := s.SecretRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretRef\"")
			}
		case "volumeName":
			if err := func() error {
				s.VolumeName.Reset()
				if err := s.VolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeName\"")
			}
		case "volumeNamespace":
			if err := func() error {
				s.VolumeNamespace.Reset()
				if err := s.VolumeNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeNamespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1StorageOSVolumeSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1StorageOSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Sysctl) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Sysctl) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Sysctl = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes IoK8sAPICoreV1Sysctl from json.
func (s *IoK8sAPICoreV1Sysctl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Sysctl to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Sysctl")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Sysctl) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Sysctl[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Sysctl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Sysctl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1TCPSocketAction) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction = [2]string{
	0: "host",
	1: "port",
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (s *IoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TCPSocketAction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TCPSocketAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TCPSocketAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1TCPSocketAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1TCPSocketAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Taint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Taint) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("effect")
		e.Str(s.Effect)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.TimeAdded.Set {
			e.FieldStart("timeAdded")
			s.TimeAdded.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Taint = [4]string{
	0: "effect",
	1: "key",
	2: "timeAdded",
	3: "value",
}

// Decode decodes IoK8sAPICoreV1Taint from json.
func (s *IoK8sAPICoreV1Taint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Taint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Effect = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "timeAdded":
			if err := func() error {
				s.TimeAdded.Reset()
				if err := s.TimeAdded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeAdded\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Taint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Taint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Taint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Taint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Taint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Toleration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Toleration) encodeFields(e *jx.Encoder) {
	{
		if s.Effect.Set {
			e.FieldStart("effect")
			s.Effect.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.TolerationSeconds.Set {
			e.FieldStart("tolerationSeconds")
			s.TolerationSeconds.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Toleration = [5]string{
	0: "effect",
	1: "key",
	2: "operator",
	3: "tolerationSeconds",
	4: "value",
}

// Decode decodes IoK8sAPICoreV1Toleration from json.
func (s *IoK8sAPICoreV1Toleration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Toleration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "effect":
			if err := func() error {
				s.Effect.Reset()
				if err := s.Effect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "tolerationSeconds":
			if err := func() error {
				s.TolerationSeconds.Reset()
				if err := s.TolerationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerationSeconds\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Toleration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Toleration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Toleration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("values")
		e.ArrStart()
		for _, elem := range s.Values {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement = [2]string{
	0: "key",
	1: "values",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorLabelRequirement from json.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySelectorLabelRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySelectorLabelRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorLabelRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1TopologySelectorLabelRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1TopologySelectorTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1TopologySelectorTerm) encodeFields(e *jx.Encoder) {
	{
		if s.MatchLabelExpressions != nil {
			e.FieldStart("matchLabelExpressions")
			e.ArrStart()
			for _, elem := range s.MatchLabelExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySelectorTerm = [1]string{
	0: "matchLabelExpressions",
}

// Decode decodes IoK8sAPICoreV1TopologySelectorTerm from json.
func (s *IoK8sAPICoreV1TopologySelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySelectorTerm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchLabelExpressions":
			if err := func() error {
				s.MatchLabelExpressions = make([]IoK8sAPICoreV1TopologySelectorLabelRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySelectorLabelRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchLabelExpressions = append(s.MatchLabelExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabelExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySelectorTerm")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1TopologySelectorTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1TopologySelectorTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		e.FieldStart("maxSkew")
		e.Int32(s.MaxSkew)
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
	{
		e.FieldStart("whenUnsatisfiable")
		e.Str(s.WhenUnsatisfiable)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint = [4]string{
	0: "labelSelector",
	1: "maxSkew",
	2: "topologyKey",
	3: "whenUnsatisfiable",
}

// Decode decodes IoK8sAPICoreV1TopologySpreadConstraint from json.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TopologySpreadConstraint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "maxSkew":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxSkew = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSkew\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		case "whenUnsatisfiable":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WhenUnsatisfiable = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whenUnsatisfiable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TopologySpreadConstraint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TopologySpreadConstraint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1TopologySpreadConstraint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroup.Set {
			e.FieldStart("apiGroup")
			s.ApiGroup.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1TypedLocalObjectReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1TypedLocalObjectReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference) {
					name = jsonFieldsNameOfIoK8sAPICoreV1TypedLocalObjectReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1TypedLocalObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1Volume) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1Volume) encodeFields(e *jx.Encoder) {
	{
		if s.AwsElasticBlockStore.Set {
			e.FieldStart("awsElasticBlockStore")
			s.AwsElasticBlockStore.Encode(e)
		}
	}
	{
		if s.AzureDisk.Set {
			e.FieldStart("azureDisk")
			s.AzureDisk.Encode(e)
		}
	}
	{
		if s.AzureFile.Set {
			e.FieldStart("azureFile")
			s.AzureFile.Encode(e)
		}
	}
	{
		if s.Cephfs.Set {
			e.FieldStart("cephfs")
			s.Cephfs.Encode(e)
		}
	}
	{
		if s.Cinder.Set {
			e.FieldStart("cinder")
			s.Cinder.Encode(e)
		}
	}
	{
		if s.ConfigMap.Set {
			e.FieldStart("configMap")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.Csi.Set {
			e.FieldStart("csi")
			s.Csi.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			e.FieldStart("downwardAPI")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.EmptyDir.Set {
			e.FieldStart("emptyDir")
			s.EmptyDir.Encode(e)
		}
	}
	{
		if s.Ephemeral.Set {
			e.FieldStart("ephemeral")
			s.Ephemeral.Encode(e)
		}
	}
	{
		if s.Fc.Set {
			e.FieldStart("fc")
			s.Fc.Encode(e)
		}
	}
	{
		if s.FlexVolume.Set {
			e.FieldStart("flexVolume")
			s.FlexVolume.Encode(e)
		}
	}
	{
		if s.Flocker.Set {
			e.FieldStart("flocker")
			s.Flocker.Encode(e)
		}
	}
	{
		if s.GcePersistentDisk.Set {
			e.FieldStart("gcePersistentDisk")
			s.GcePersistentDisk.Encode(e)
		}
	}
	{
		if s.GitRepo.Set {
			e.FieldStart("gitRepo")
			s.GitRepo.Encode(e)
		}
	}
	{
		if s.Glusterfs.Set {
			e.FieldStart("glusterfs")
			s.Glusterfs.Encode(e)
		}
	}
	{
		if s.HostPath.Set {
			e.FieldStart("hostPath")
			s.HostPath.Encode(e)
		}
	}
	{
		if s.Iscsi.Set {
			e.FieldStart("iscsi")
			s.Iscsi.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Nfs.Set {
			e.FieldStart("nfs")
			s.Nfs.Encode(e)
		}
	}
	{
		if s.PersistentVolumeClaim.Set {
			e.FieldStart("persistentVolumeClaim")
			s.PersistentVolumeClaim.Encode(e)
		}
	}
	{
		if s.PhotonPersistentDisk.Set {
			e.FieldStart("photonPersistentDisk")
			s.PhotonPersistentDisk.Encode(e)
		}
	}
	{
		if s.PortworxVolume.Set {
			e.FieldStart("portworxVolume")
			s.PortworxVolume.Encode(e)
		}
	}
	{
		if s.Projected.Set {
			e.FieldStart("projected")
			s.Projected.Encode(e)
		}
	}
	{
		if s.Quobyte.Set {
			e.FieldStart("quobyte")
			s.Quobyte.Encode(e)
		}
	}
	{
		if s.Rbd.Set {
			e.FieldStart("rbd")
			s.Rbd.Encode(e)
		}
	}
	{
		if s.ScaleIO.Set {
			e.FieldStart("scaleIO")
			s.ScaleIO.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Storageos.Set {
			e.FieldStart("storageos")
			s.Storageos.Encode(e)
		}
	}
	{
		if s.VsphereVolume.Set {
			e.FieldStart("vsphereVolume")
			s.VsphereVolume.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1Volume = [30]string{
	0:  "awsElasticBlockStore",
	1:  "azureDisk",
	2:  "azureFile",
	3:  "cephfs",
	4:  "cinder",
	5:  "configMap",
	6:  "csi",
	7:  "downwardAPI",
	8:  "emptyDir",
	9:  "ephemeral",
	10: "fc",
	11: "flexVolume",
	12: "flocker",
	13: "gcePersistentDisk",
	14: "gitRepo",
	15: "glusterfs",
	16: "hostPath",
	17: "iscsi",
	18: "name",
	19: "nfs",
	20: "persistentVolumeClaim",
	21: "photonPersistentDisk",
	22: "portworxVolume",
	23: "projected",
	24: "quobyte",
	25: "rbd",
	26: "scaleIO",
	27: "secret",
	28: "storageos",
	29: "vsphereVolume",
}

// Decode decodes IoK8sAPICoreV1Volume from json.
func (s *IoK8sAPICoreV1Volume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1Volume to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "awsElasticBlockStore":
			if err := func() error {
				s.AwsElasticBlockStore.Reset()
				if err := s.AwsElasticBlockStore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"awsElasticBlockStore\"")
			}
		case "azureDisk":
			if err := func() error {
				s.AzureDisk.Reset()
				if err := s.AzureDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureDisk\"")
			}
		case "azureFile":
			if err := func() error {
				s.AzureFile.Reset()
				if err := s.AzureFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"azureFile\"")
			}
		case "cephfs":
			if err := func() error {
				s.Cephfs.Reset()
				if err := s.Cephfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cephfs\"")
			}
		case "cinder":
			if err := func() error {
				s.Cinder.Reset()
				if err := s.Cinder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cinder\"")
			}
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		case "csi":
			if err := func() error {
				s.Csi.Reset()
				if err := s.Csi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csi\"")
			}
		case "downwardAPI":
			if err := func() error {
				s.DownwardAPI.Reset()
				if err := s.DownwardAPI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downwardAPI\"")
			}
		case "emptyDir":
			if err := func() error {
				s.EmptyDir.Reset()
				if err := s.EmptyDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emptyDir\"")
			}
		case "ephemeral":
			if err := func() error {
				s.Ephemeral.Reset()
				if err := s.Ephemeral.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ephemeral\"")
			}
		case "fc":
			if err := func() error {
				s.Fc.Reset()
				if err := s.Fc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fc\"")
			}
		case "flexVolume":
			if err := func() error {
				s.FlexVolume.Reset()
				if err := s.FlexVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flexVolume\"")
			}
		case "flocker":
			if err := func() error {
				s.Flocker.Reset()
				if err := s.Flocker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flocker\"")
			}
		case "gcePersistentDisk":
			if err := func() error {
				s.GcePersistentDisk.Reset()
				if err := s.GcePersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gcePersistentDisk\"")
			}
		case "gitRepo":
			if err := func() error {
				s.GitRepo.Reset()
				if err := s.GitRepo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitRepo\"")
			}
		case "glusterfs":
			if err := func() error {
				s.Glusterfs.Reset()
				if err := s.Glusterfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"glusterfs\"")
			}
		case "hostPath":
			if err := func() error {
				s.HostPath.Reset()
				if err := s.HostPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPath\"")
			}
		case "iscsi":
			if err := func() error {
				s.Iscsi.Reset()
				if err := s.Iscsi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iscsi\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nfs":
			if err := func() error {
				s.Nfs.Reset()
				if err := s.Nfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nfs\"")
			}
		case "persistentVolumeClaim":
			if err := func() error {
				s.PersistentVolumeClaim.Reset()
				if err := s.PersistentVolumeClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeClaim\"")
			}
		case "photonPersistentDisk":
			if err := func() error {
				s.PhotonPersistentDisk.Reset()
				if err := s.PhotonPersistentDisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photonPersistentDisk\"")
			}
		case "portworxVolume":
			if err := func() error {
				s.PortworxVolume.Reset()
				if err := s.PortworxVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portworxVolume\"")
			}
		case "projected":
			if err := func() error {
				s.Projected.Reset()
				if err := s.Projected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projected\"")
			}
		case "quobyte":
			if err := func() error {
				s.Quobyte.Reset()
				if err := s.Quobyte.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quobyte\"")
			}
		case "rbd":
			if err := func() error {
				s.Rbd.Reset()
				if err := s.Rbd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rbd\"")
			}
		case "scaleIO":
			if err := func() error {
				s.ScaleIO.Reset()
				if err := s.ScaleIO.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scaleIO\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "storageos":
			if err := func() error {
				s.Storageos.Reset()
				if err := s.Storageos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageos\"")
			}
		case "vsphereVolume":
			if err := func() error {
				s.VsphereVolume.Reset()
				if err := s.VsphereVolume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsphereVolume\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1Volume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000000,
		0b00000000,
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1Volume) {
					name = jsonFieldsNameOfIoK8sAPICoreV1Volume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1Volume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1Volume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1VolumeDevice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1VolumeDevice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("devicePath")
		e.Str(s.DevicePath)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice = [2]string{
	0: "devicePath",
	1: "name",
}

// Decode decodes IoK8sAPICoreV1VolumeDevice from json.
func (s *IoK8sAPICoreV1VolumeDevice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeDevice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devicePath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DevicePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devicePath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeDevice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeDevice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1VolumeDevice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1VolumeDevice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1VolumeMount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1VolumeMount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mountPath")
		e.Str(s.MountPath)
	}
	{
		if s.MountPropagation.Set {
			e.FieldStart("mountPropagation")
			s.MountPropagation.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.SubPath.Set {
			e.FieldStart("subPath")
			s.SubPath.Encode(e)
		}
	}
	{
		if s.SubPathExpr.Set {
			e.FieldStart("subPathExpr")
			s.SubPathExpr.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeMount = [6]string{
	0: "mountPath",
	1: "mountPropagation",
	2: "name",
	3: "readOnly",
	4: "subPath",
	5: "subPathExpr",
}

// Decode decodes IoK8sAPICoreV1VolumeMount from json.
func (s *IoK8sAPICoreV1VolumeMount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeMount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mountPath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MountPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountPath\"")
			}
		case "mountPropagation":
			if err := func() error {
				s.MountPropagation.Reset()
				if err := s.MountPropagation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountPropagation\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "subPath":
			if err := func() error {
				s.SubPath.Reset()
				if err := s.SubPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subPath\"")
			}
		case "subPathExpr":
			if err := func() error {
				s.SubPathExpr.Reset()
				if err := s.SubPathExpr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subPathExpr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeMount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VolumeMount) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VolumeMount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1VolumeMount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1VolumeMount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeNodeAffinity = [1]string{
	0: "required",
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeNodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeNodeAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1VolumeNodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1VolumeProjection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1VolumeProjection) encodeFields(e *jx.Encoder) {
	{
		if s.ConfigMap.Set {
			e.FieldStart("configMap")
			s.ConfigMap.Encode(e)
		}
	}
	{
		if s.DownwardAPI.Set {
			e.FieldStart("downwardAPI")
			s.DownwardAPI.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.ServiceAccountToken.Set {
			e.FieldStart("serviceAccountToken")
			s.ServiceAccountToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1VolumeProjection = [4]string{
	0: "configMap",
	1: "downwardAPI",
	2: "secret",
	3: "serviceAccountToken",
}

// Decode decodes IoK8sAPICoreV1VolumeProjection from json.
func (s *IoK8sAPICoreV1VolumeProjection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VolumeProjection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configMap":
			if err := func() error {
				s.ConfigMap.Reset()
				if err := s.ConfigMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configMap\"")
			}
		case "downwardAPI":
			if err := func() error {
				s.DownwardAPI.Reset()
				if err := s.DownwardAPI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downwardAPI\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "serviceAccountToken":
			if err := func() error {
				s.ServiceAccountToken.Reset()
				if err := s.ServiceAccountToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VolumeProjection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1VolumeProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1VolumeProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) encodeFields(e *jx.Encoder) {
	{
		if s.FsType.Set {
			e.FieldStart("fsType")
			s.FsType.Encode(e)
		}
	}
	{
		if s.StoragePolicyID.Set {
			e.FieldStart("storagePolicyID")
			s.StoragePolicyID.Encode(e)
		}
	}
	{
		if s.StoragePolicyName.Set {
			e.FieldStart("storagePolicyName")
			s.StoragePolicyName.Encode(e)
		}
	}
	{
		e.FieldStart("volumePath")
		e.Str(s.VolumePath)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource = [4]string{
	0: "fsType",
	1: "storagePolicyID",
	2: "storagePolicyName",
	3: "volumePath",
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fsType":
			if err := func() error {
				s.FsType.Reset()
				if err := s.FsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsType\"")
			}
		case "storagePolicyID":
			if err := func() error {
				s.StoragePolicyID.Reset()
				if err := s.StoragePolicyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePolicyID\"")
			}
		case "storagePolicyName":
			if err := func() error {
				s.StoragePolicyName.Reset()
				if err := s.StoragePolicyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storagePolicyName\"")
			}
		case "volumePath":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VolumePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1VsphereVirtualDiskVolumeSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) {
					name = jsonFieldsNameOfIoK8sAPICoreV1VsphereVirtualDiskVolumeSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1VsphereVirtualDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("podAffinityTerm")
		s.PodAffinityTerm.Encode(e)
	}
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm = [2]string{
	0: "podAffinityTerm",
	1: "weight",
}

// Decode decodes IoK8sAPICoreV1WeightedPodAffinityTerm from json.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1WeightedPodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PodAffinityTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinityTerm\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1WeightedPodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm) {
					name = jsonFieldsNameOfIoK8sAPICoreV1WeightedPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1WeightedPodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) encodeFields(e *jx.Encoder) {
	{
		if s.GmsaCredentialSpec.Set {
			e.FieldStart("gmsaCredentialSpec")
			s.GmsaCredentialSpec.Encode(e)
		}
	}
	{
		if s.GmsaCredentialSpecName.Set {
			e.FieldStart("gmsaCredentialSpecName")
			s.GmsaCredentialSpecName.Encode(e)
		}
	}
	{
		if s.HostProcess.Set {
			e.FieldStart("hostProcess")
			s.HostProcess.Encode(e)
		}
	}
	{
		if s.RunAsUserName.Set {
			e.FieldStart("runAsUserName")
			s.RunAsUserName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPICoreV1WindowsSecurityContextOptions = [4]string{
	0: "gmsaCredentialSpec",
	1: "gmsaCredentialSpecName",
	2: "hostProcess",
	3: "runAsUserName",
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPICoreV1WindowsSecurityContextOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gmsaCredentialSpec":
			if err := func() error {
				s.GmsaCredentialSpec.Reset()
				if err := s.GmsaCredentialSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpec\"")
			}
		case "gmsaCredentialSpecName":
			if err := func() error {
				s.GmsaCredentialSpecName.Reset()
				if err := s.GmsaCredentialSpecName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gmsaCredentialSpecName\"")
			}
		case "hostProcess":
			if err := func() error {
				s.HostProcess.Reset()
				if err := s.HostProcess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostProcess\"")
			}
		case "runAsUserName":
			if err := func() error {
				s.RunAsUserName.Reset()
				if err := s.RunAsUserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUserName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPICoreV1WindowsSecurityContextOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPICoreV1WindowsSecurityContextOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1Endpoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1Endpoint) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("addresses")
		e.ArrStart()
		for _, elem := range s.Addresses {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.FieldStart("conditions")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.DeprecatedTopology.Set {
			e.FieldStart("deprecatedTopology")
			s.DeprecatedTopology.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.FieldStart("hints")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.FieldStart("nodeName")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.FieldStart("targetRef")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("zone")
			s.Zone.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint = [8]string{
	0: "addresses",
	1: "conditions",
	2: "deprecatedTopology",
	3: "hints",
	4: "hostname",
	5: "nodeName",
	6: "targetRef",
	7: "zone",
}

// Decode decodes IoK8sAPIDiscoveryV1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1Endpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions.Reset()
				if err := s.Conditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "deprecatedTopology":
			if err := func() error {
				s.DeprecatedTopology.Reset()
				if err := s.DeprecatedTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedTopology\"")
			}
		case "hints":
			if err := func() error {
				s.Hints.Reset()
				if err := s.Hints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hints\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		case "zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1Endpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1Endpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1Endpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) encodeFields(e *jx.Encoder) {
	{
		if s.Ready.Set {
			e.FieldStart("ready")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			e.FieldStart("serving")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			e.FieldStart("terminating")
			s.Terminating.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "serving":
			if err := func() error {
				s.Serving.Reset()
				if err := s.Serving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serving\"")
			}
		case "terminating":
			if err := func() error {
				s.Terminating.Reset()
				if err := s.Terminating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointConditions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology from json.
func (s *IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointDeprecatedTopology to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointDeprecatedTopology")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointDeprecatedTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1EndpointHints) encodeFields(e *jx.Encoder) {
	{
		if s.ForZones != nil {
			e.FieldStart("forZones")
			e.ArrStart()
			for _, elem := range s.ForZones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointHints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			if err := func() error {
				s.ForZones = make([]IoK8sAPIDiscoveryV1ForZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1ForZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ForZones = append(s.ForZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forZones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointHints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointHints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointHints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1EndpointPort) encodeFields(e *jx.Encoder) {
	{
		if s.AppProtocol.Set {
			e.FieldStart("appProtocol")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointPort")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("addressType")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("endpoints")
		e.ArrStart()
		for _, elem := range s.Endpoints {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSlice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AddressType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressType\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Endpoints = make([]IoK8sAPIDiscoveryV1Endpoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1Endpoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Endpoints = append(s.Endpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPIDiscoveryV1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointSlice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSlice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1EndpointSliceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIDiscoveryV1EndpointSlice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1EndpointSlice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1EndpointSliceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1EndpointSliceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1ForZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1ForZone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1ForZone from json.
func (s *IoK8sAPIDiscoveryV1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1ForZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1ForZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1ForZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1ForZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("addresses")
		e.ArrStart()
		for _, elem := range s.Addresses {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Conditions.Set {
			e.FieldStart("conditions")
			s.Conditions.Encode(e)
		}
	}
	{
		if s.Hints.Set {
			e.FieldStart("hints")
			s.Hints.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeName.Set {
			e.FieldStart("nodeName")
			s.NodeName.Encode(e)
		}
	}
	{
		if s.TargetRef.Set {
			e.FieldStart("targetRef")
			s.TargetRef.Encode(e)
		}
	}
	{
		if s.Topology.Set {
			e.FieldStart("topology")
			s.Topology.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint = [7]string{
	0: "addresses",
	1: "conditions",
	2: "hints",
	3: "hostname",
	4: "nodeName",
	5: "targetRef",
	6: "topology",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1Endpoint from json.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1Endpoint to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Addresses = append(s.Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addresses\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions.Reset()
				if err := s.Conditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "hints":
			if err := func() error {
				s.Hints.Reset()
				if err := s.Hints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hints\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "nodeName":
			if err := func() error {
				s.NodeName.Reset()
				if err := s.NodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "targetRef":
			if err := func() error {
				s.TargetRef.Reset()
				if err := s.TargetRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetRef\"")
			}
		case "topology":
			if err := func() error {
				s.Topology.Reset()
				if err := s.Topology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topology\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1Endpoint")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1Endpoint[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1Endpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) encodeFields(e *jx.Encoder) {
	{
		if s.Ready.Set {
			e.FieldStart("ready")
			s.Ready.Encode(e)
		}
	}
	{
		if s.Serving.Set {
			e.FieldStart("serving")
			s.Serving.Encode(e)
		}
	}
	{
		if s.Terminating.Set {
			e.FieldStart("terminating")
			s.Terminating.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointConditions = [3]string{
	0: "ready",
	1: "serving",
	2: "terminating",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointConditions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		case "serving":
			if err := func() error {
				s.Serving.Reset()
				if err := s.Serving.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serving\"")
			}
		case "terminating":
			if err := func() error {
				s.Terminating.Reset()
				if err := s.Terminating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointConditions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) encodeFields(e *jx.Encoder) {
	{
		if s.ForZones != nil {
			e.FieldStart("forZones")
			e.ArrStart()
			for _, elem := range s.ForZones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointHints = [1]string{
	0: "forZones",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointHints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forZones":
			if err := func() error {
				s.ForZones = make([]IoK8sAPIDiscoveryV1beta1ForZone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1ForZone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ForZones = append(s.ForZones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forZones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointHints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointHints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) encodeFields(e *jx.Encoder) {
	{
		if s.AppProtocol.Set {
			e.FieldStart("appProtocol")
			s.AppProtocol.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointPort = [4]string{
	0: "appProtocol",
	1: "name",
	2: "port",
	3: "protocol",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointPort from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "appProtocol":
			if err := func() error {
				s.AppProtocol.Reset()
				if err := s.AppProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appProtocol\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointPort")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("addressType")
		e.Str(s.AddressType)
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("endpoints")
		e.ArrStart()
		for _, elem := range s.Endpoints {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice = [6]string{
	0: "addressType",
	1: "apiVersion",
	2: "endpoints",
	3: "kind",
	4: "metadata",
	5: "ports",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSlice from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSlice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AddressType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressType\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "endpoints":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Endpoints = make([]IoK8sAPIDiscoveryV1beta1Endpoint, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1Endpoint
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Endpoints = append(s.Endpoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoints\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPIDiscoveryV1beta1EndpointPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1EndpointPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointSlice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSlice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSlice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointSliceList from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointSliceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIDiscoveryV1beta1EndpointSlice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIDiscoveryV1beta1EndpointSlice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointSliceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1EndpointSliceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointSliceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointTopology) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointTopology) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointTopology from json.
func (s *IoK8sAPIDiscoveryV1beta1EndpointTopology) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1EndpointTopology to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1EndpointTopology")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIDiscoveryV1beta1EndpointTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1EndpointTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIDiscoveryV1beta1ForZone from json.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIDiscoveryV1beta1ForZone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIDiscoveryV1beta1ForZone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone) {
					name = jsonFieldsNameOfIoK8sAPIDiscoveryV1beta1ForZone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIDiscoveryV1beta1ForZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1Event) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			e.FieldStart("deprecatedCount")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			e.FieldStart("deprecatedFirstTimestamp")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			e.FieldStart("deprecatedLastTimestamp")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			e.FieldStart("deprecatedSource")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		e.FieldStart("eventTime")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.FieldStart("regarding")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.FieldStart("related")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.FieldStart("reportingController")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.FieldStart("reportingInstance")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.FieldStart("series")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1Event from json.
func (s *IoK8sAPIEventsV1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "deprecatedCount":
			if err := func() error {
				s.DeprecatedCount.Reset()
				if err := s.DeprecatedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedCount\"")
			}
		case "deprecatedFirstTimestamp":
			if err := func() error {
				s.DeprecatedFirstTimestamp.Reset()
				if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedFirstTimestamp\"")
			}
		case "deprecatedLastTimestamp":
			if err := func() error {
				s.DeprecatedLastTimestamp.Reset()
				if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedLastTimestamp\"")
			}
		case "deprecatedSource":
			if err := func() error {
				s.DeprecatedSource.Reset()
				if err := s.DeprecatedSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedSource\"")
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "regarding":
			if err := func() error {
				s.Regarding.Reset()
				if err := s.Regarding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regarding\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingController":
			if err := func() error {
				s.ReportingController.Reset()
				if err := s.ReportingController.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingController\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1EventList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1EventList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1EventList from json.
func (s *IoK8sAPIEventsV1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIEventsV1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIEventsV1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1EventList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1EventList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1EventSeries) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1EventSeries) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int32(s.Count)
	}
	{
		e.FieldStart("lastObservedTime")
		s.LastObservedTime.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (s *IoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1EventSeries to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Count = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1EventSeries")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1beta1Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1beta1Event) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.DeprecatedCount.Set {
			e.FieldStart("deprecatedCount")
			s.DeprecatedCount.Encode(e)
		}
	}
	{
		if s.DeprecatedFirstTimestamp.Set {
			e.FieldStart("deprecatedFirstTimestamp")
			s.DeprecatedFirstTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedLastTimestamp.Set {
			e.FieldStart("deprecatedLastTimestamp")
			s.DeprecatedLastTimestamp.Encode(e)
		}
	}
	{
		if s.DeprecatedSource.Set {
			e.FieldStart("deprecatedSource")
			s.DeprecatedSource.Encode(e)
		}
	}
	{
		e.FieldStart("eventTime")
		s.EventTime.Encode(e)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Regarding.Set {
			e.FieldStart("regarding")
			s.Regarding.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.FieldStart("related")
			s.Related.Encode(e)
		}
	}
	{
		if s.ReportingController.Set {
			e.FieldStart("reportingController")
			s.ReportingController.Encode(e)
		}
	}
	{
		if s.ReportingInstance.Set {
			e.FieldStart("reportingInstance")
			s.ReportingInstance.Encode(e)
		}
	}
	{
		if s.Series.Set {
			e.FieldStart("series")
			s.Series.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1Event = [17]string{
	0:  "action",
	1:  "apiVersion",
	2:  "deprecatedCount",
	3:  "deprecatedFirstTimestamp",
	4:  "deprecatedLastTimestamp",
	5:  "deprecatedSource",
	6:  "eventTime",
	7:  "kind",
	8:  "metadata",
	9:  "note",
	10: "reason",
	11: "regarding",
	12: "related",
	13: "reportingController",
	14: "reportingInstance",
	15: "series",
	16: "type",
}

// Decode decodes IoK8sAPIEventsV1beta1Event from json.
func (s *IoK8sAPIEventsV1beta1Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1Event to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "deprecatedCount":
			if err := func() error {
				s.DeprecatedCount.Reset()
				if err := s.DeprecatedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedCount\"")
			}
		case "deprecatedFirstTimestamp":
			if err := func() error {
				s.DeprecatedFirstTimestamp.Reset()
				if err := s.DeprecatedFirstTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedFirstTimestamp\"")
			}
		case "deprecatedLastTimestamp":
			if err := func() error {
				s.DeprecatedLastTimestamp.Reset()
				if err := s.DeprecatedLastTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedLastTimestamp\"")
			}
		case "deprecatedSource":
			if err := func() error {
				s.DeprecatedSource.Reset()
				if err := s.DeprecatedSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecatedSource\"")
			}
		case "eventTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.EventTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventTime\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "regarding":
			if err := func() error {
				s.Regarding.Reset()
				if err := s.Regarding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regarding\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "reportingController":
			if err := func() error {
				s.ReportingController.Reset()
				if err := s.ReportingController.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingController\"")
			}
		case "reportingInstance":
			if err := func() error {
				s.ReportingInstance.Reset()
				if err := s.ReportingInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reportingInstance\"")
			}
		case "series":
			if err := func() error {
				s.Series.Reset()
				if err := s.Series.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1Event) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1Event[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1beta1Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1beta1Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1beta1EventList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1beta1EventList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIEventsV1beta1EventList from json.
func (s *IoK8sAPIEventsV1beta1EventList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1EventList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIEventsV1beta1Event, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIEventsV1beta1Event
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1EventList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1beta1EventList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1beta1EventList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIEventsV1beta1EventSeries) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int32(s.Count)
	}
	{
		e.FieldStart("lastObservedTime")
		s.LastObservedTime.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries = [2]string{
	0: "count",
	1: "lastObservedTime",
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (s *IoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIEventsV1beta1EventSeries to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Count = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "lastObservedTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LastObservedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastObservedTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIEventsV1beta1EventSeries")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries) {
					name = jsonFieldsNameOfIoK8sAPIEventsV1beta1EventSeries[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIEventsV1beta1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIEventsV1beta1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta1FlowSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1FlowSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DistinguisherMethod.Set {
			e.FieldStart("distinguisherMethod")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			e.FieldStart("matchingPrecedence")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		e.FieldStart("priorityLevelConfiguration")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			if err := func() error {
				s.DistinguisherMethod.Reset()
				if err := s.DistinguisherMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinguisherMethod\"")
			}
		case "matchingPrecedence":
			if err := func() error {
				s.MatchingPrecedence.Reset()
				if err := s.MatchingPrecedence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchingPrecedence\"")
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityLevelConfiguration\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1FlowSchemaCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1GroupSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1GroupSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1GroupSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Queuing.Set {
			e.FieldStart("queuing")
			s.Queuing.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			if err := func() error {
				s.Queuing.Reset()
				if err := s.Queuing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queuing\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1LimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.AssuredConcurrencyShares.Set {
			e.FieldStart("assuredConcurrencyShares")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			e.FieldStart("limitResponse")
			s.LimitResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			if err := func() error {
				s.AssuredConcurrencyShares.Reset()
				if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assuredConcurrencyShares\"")
			}
		case "limitResponse":
			if err := func() error {
				s.LimitResponse.Reset()
				if err := s.LimitResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nonResourceURLs")
		e.ArrStart()
		for _, elem := range s.NonResourceURLs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) encodeFields(e *jx.Encoder) {
	{
		if s.NonResourceRules != nil {
			e.FieldStart("nonResourceRules")
			e.ArrStart()
			for _, elem := range s.NonResourceRules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			e.FieldStart("resourceRules")
			e.ArrStart()
			for _, elem := range s.ResourceRules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("subjects")
		e.ArrStart()
		for _, elem := range s.Subjects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			if err := func() error {
				s.NonResourceRules = make([]IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1NonResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NonResourceRules = append(s.NonResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceRules\"")
			}
		case "resourceRules":
			if err := func() error {
				s.ResourceRules = make([]IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceRules = append(s.ResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceRules\"")
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Subjects = make([]IoK8sAPIFlowcontrolV1beta1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PolicyRulesWithSubjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Limited.Set {
			e.FieldStart("limited")
			s.Limited.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			if err := func() error {
				s.Limited.Reset()
				if err := s.Limited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.HandSize.Set {
			e.FieldStart("handSize")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			e.FieldStart("queueLengthLimit")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			e.FieldStart("queues")
			s.Queues.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			if err := func() error {
				s.HandSize.Reset()
				if err := s.HandSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handSize\"")
			}
		case "queueLengthLimit":
			if err := func() error {
				s.QueueLengthLimit.Reset()
				if err := s.QueueLengthLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueLengthLimit\"")
			}
		case "queues":
			if err := func() error {
				s.Queues.Reset()
				if err := s.Queues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1QueuingConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1QueuingConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiGroups")
		e.ArrStart()
		for _, elem := range s.ApiGroups {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.FieldStart("clusterScope")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "clusterScope":
			if err := func() error {
				s.ClusterScope.Reset()
				if err := s.ClusterScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterScope\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ResourcePolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) encodeFields(e *jx.Encoder) {
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.FieldStart("serviceAccount")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1Subject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta1UserSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta1UserSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta1UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta1UserSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod = [1]string{
	0: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchema = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchema from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaList from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta2FlowSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2FlowSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DistinguisherMethod.Set {
			e.FieldStart("distinguisherMethod")
			s.DistinguisherMethod.Encode(e)
		}
	}
	{
		if s.MatchingPrecedence.Set {
			e.FieldStart("matchingPrecedence")
			s.MatchingPrecedence.Encode(e)
		}
	}
	{
		e.FieldStart("priorityLevelConfiguration")
		s.PriorityLevelConfiguration.Encode(e)
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec = [4]string{
	0: "distinguisherMethod",
	1: "matchingPrecedence",
	2: "priorityLevelConfiguration",
	3: "rules",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "distinguisherMethod":
			if err := func() error {
				s.DistinguisherMethod.Reset()
				if err := s.DistinguisherMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distinguisherMethod\"")
			}
		case "matchingPrecedence":
			if err := func() error {
				s.MatchingPrecedence.Reset()
				if err := s.MatchingPrecedence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchingPrecedence\"")
			}
		case "priorityLevelConfiguration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PriorityLevelConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priorityLevelConfiguration\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2FlowSchemaCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2GroupSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2GroupSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2GroupSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2GroupSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Queuing.Set {
			e.FieldStart("queuing")
			s.Queuing.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse = [2]string{
	0: "queuing",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queuing":
			if err := func() error {
				s.Queuing.Reset()
				if err := s.Queuing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queuing\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2LimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.AssuredConcurrencyShares.Set {
			e.FieldStart("assuredConcurrencyShares")
			s.AssuredConcurrencyShares.Encode(e)
		}
	}
	{
		if s.LimitResponse.Set {
			e.FieldStart("limitResponse")
			s.LimitResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration = [2]string{
	0: "assuredConcurrencyShares",
	1: "limitResponse",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assuredConcurrencyShares":
			if err := func() error {
				s.AssuredConcurrencyShares.Reset()
				if err := s.AssuredConcurrencyShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assuredConcurrencyShares\"")
			}
		case "limitResponse":
			if err := func() error {
				s.LimitResponse.Reset()
				if err := s.LimitResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nonResourceURLs")
		e.ArrStart()
		for _, elem := range s.NonResourceURLs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule = [2]string{
	0: "nonResourceURLs",
	1: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceURLs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) encodeFields(e *jx.Encoder) {
	{
		if s.NonResourceRules != nil {
			e.FieldStart("nonResourceRules")
			e.ArrStart()
			for _, elem := range s.NonResourceRules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceRules != nil {
			e.FieldStart("resourceRules")
			e.ArrStart()
			for _, elem := range s.ResourceRules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("subjects")
		e.ArrStart()
		for _, elem := range s.Subjects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects = [3]string{
	0: "nonResourceRules",
	1: "resourceRules",
	2: "subjects",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects from json.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nonResourceRules":
			if err := func() error {
				s.NonResourceRules = make([]IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2NonResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NonResourceRules = append(s.NonResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceRules\"")
			}
		case "resourceRules":
			if err := func() error {
				s.ResourceRules = make([]IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResourceRules = append(s.ResourceRules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceRules\"")
			}
		case "subjects":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Subjects = make([]IoK8sAPIFlowcontrolV1beta2Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PolicyRulesWithSubjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfiguration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Limited.Set {
			e.FieldStart("limited")
			s.Limited.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec = [2]string{
	0: "limited",
	1: "type",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limited":
			if err := func() error {
				s.Limited.Reset()
				if err := s.Limited.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.HandSize.Set {
			e.FieldStart("handSize")
			s.HandSize.Encode(e)
		}
	}
	{
		if s.QueueLengthLimit.Set {
			e.FieldStart("queueLengthLimit")
			s.QueueLengthLimit.Encode(e)
		}
	}
	{
		if s.Queues.Set {
			e.FieldStart("queues")
			s.Queues.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2QueuingConfiguration = [3]string{
	0: "handSize",
	1: "queueLengthLimit",
	2: "queues",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handSize":
			if err := func() error {
				s.HandSize.Reset()
				if err := s.HandSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handSize\"")
			}
		case "queueLengthLimit":
			if err := func() error {
				s.QueueLengthLimit.Reset()
				if err := s.QueueLengthLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueLengthLimit\"")
			}
		case "queues":
			if err := func() error {
				s.Queues.Reset()
				if err := s.Queues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2QueuingConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2QueuingConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiGroups")
		e.ArrStart()
		for _, elem := range s.ApiGroups {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ClusterScope.Set {
			e.FieldStart("clusterScope")
			s.ClusterScope.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule = [5]string{
	0: "apiGroups",
	1: "clusterScope",
	2: "namespaces",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule from json.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "clusterScope":
			if err := func() error {
				s.ClusterScope.Reset()
				if err := s.ClusterScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterScope\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ResourcePolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ResourcePolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject = [2]string{
	0: "name",
	1: "namespace",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) encodeFields(e *jx.Encoder) {
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		if s.ServiceAccount.Set {
			e.FieldStart("serviceAccount")
			s.ServiceAccount.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject = [4]string{
	0: "group",
	1: "kind",
	2: "serviceAccount",
	3: "user",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2Subject from json.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serviceAccount":
			if err := func() error {
				s.ServiceAccount.Reset()
				if err := s.ServiceAccount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccount\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2Subject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIFlowcontrolV1beta2UserSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIFlowcontrolV1beta2UserSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject) {
					name = jsonFieldsNameOfIoK8sAPIFlowcontrolV1beta2UserSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIFlowcontrolV1beta2UserSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backend")
		s.Backend.Encode(e)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		e.FieldStart("pathType")
		e.Str(s.PathType)
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath = [3]string{
	0: "backend",
	1: "path",
	2: "pathType",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressPath from json.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressPath to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backend":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Backend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backend\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "pathType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PathType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1HTTPIngressPath")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressPath[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("paths")
		e.ArrStart()
		for _, elem := range s.Paths {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue = [1]string{
	0: "paths",
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1HTTPIngressRuleValue to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "paths":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Paths = make([]IoK8sAPINetworkingV1HTTPIngressPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1HTTPIngressPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Paths = append(s.Paths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1HTTPIngressRuleValue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1HTTPIngressRuleValue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1HTTPIngressRuleValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IPBlock) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IPBlock) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cidr")
		e.Str(s.Cidr)
	}
	{
		if s.Except != nil {
			e.FieldStart("except")
			e.ArrStart()
			for _, elem := range s.Except {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock = [2]string{
	0: "cidr",
	1: "except",
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (s *IoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IPBlock to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cidr":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Cidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		case "except":
			if err := func() error {
				s.Except = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Except = append(s.Except, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"except\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IPBlock")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IPBlock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IPBlock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IPBlock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1Ingress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1Ingress) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1Ingress = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPINetworkingV1Ingress from json.
func (s *IoK8sAPINetworkingV1Ingress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1Ingress to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1Ingress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1Ingress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1Ingress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressBackend) encodeFields(e *jx.Encoder) {
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressBackend = [2]string{
	0: "resource",
	1: "service",
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (s *IoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressBackend to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressBackend")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressClass) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1IngressClass from json.
func (s *IoK8sAPINetworkingV1IngressClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClass to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClass")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassList from json.
func (s *IoK8sAPINetworkingV1IngressClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1IngressClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroup.Set {
			e.FieldStart("apiGroup")
			s.ApiGroup.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Scope.Set {
			e.FieldStart("scope")
			s.Scope.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference = [5]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
	4: "scope",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassParametersReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "scope":
			if err := func() error {
				s.Scope.Reset()
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassParametersReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassParametersReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressClassParametersReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressClassSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Controller.Set {
			e.FieldStart("controller")
			s.Controller.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressClassSpec = [2]string{
	0: "controller",
	1: "parameters",
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (s *IoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressClassSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "controller":
			if err := func() error {
				s.Controller.Reset()
				if err := s.Controller.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controller\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressClassSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressClassSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressClassSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1IngressList from json.
func (s *IoK8sAPINetworkingV1IngressList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1Ingress, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1Ingress
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressRule) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.HTTP.Set {
			e.FieldStart("http")
			s.HTTP.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressRule = [2]string{
	0: "host",
	1: "http",
}

// Decode decodes IoK8sAPINetworkingV1IngressRule from json.
func (s *IoK8sAPINetworkingV1IngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "http":
			if err := func() error {
				s.HTTP.Reset()
				if err := s.HTTP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"http\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend = [2]string{
	0: "name",
	1: "port",
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressServiceBackend to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressServiceBackend")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1IngressServiceBackend[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressServiceBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressSpec) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultBackend.Set {
			e.FieldStart("defaultBackend")
			s.DefaultBackend.Encode(e)
		}
	}
	{
		if s.IngressClassName.Set {
			e.FieldStart("ingressClassName")
			s.IngressClassName.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TLS != nil {
			e.FieldStart("tls")
			e.ArrStart()
			for _, elem := range s.TLS {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressSpec = [4]string{
	0: "defaultBackend",
	1: "ingressClassName",
	2: "rules",
	3: "tls",
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (s *IoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultBackend":
			if err := func() error {
				s.DefaultBackend.Reset()
				if err := s.DefaultBackend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultBackend\"")
			}
		case "ingressClassName":
			if err := func() error {
				s.IngressClassName.Reset()
				if err := s.IngressClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingressClassName\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPINetworkingV1IngressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "tls":
			if err := func() error {
				s.TLS = make([]IoK8sAPINetworkingV1IngressTLS, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1IngressTLS
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TLS = append(s.TLS, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressStatus) encodeFields(e *jx.Encoder) {
	{
		if s.LoadBalancer.Set {
			e.FieldStart("loadBalancer")
			s.LoadBalancer.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressStatus = [1]string{
	0: "loadBalancer",
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (s *IoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loadBalancer":
			if err := func() error {
				s.LoadBalancer.Reset()
				if err := s.LoadBalancer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadBalancer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1IngressTLS) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1IngressTLS) encodeFields(e *jx.Encoder) {
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecretName.Set {
			e.FieldStart("secretName")
			s.SecretName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1IngressTLS = [2]string{
	0: "hosts",
	1: "secretName",
}

// Decode decodes IoK8sAPINetworkingV1IngressTLS from json.
func (s *IoK8sAPINetworkingV1IngressTLS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1IngressTLS to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "secretName":
			if err := func() error {
				s.SecretName.Reset()
				if err := s.SecretName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1IngressTLS")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1IngressTLS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1IngressTLS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicy) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicy from json.
func (s *IoK8sAPINetworkingV1NetworkPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) encodeFields(e *jx.Encoder) {
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.To != nil {
			e.FieldStart("to")
			e.ArrStart()
			for _, elem := range s.To {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyEgressRule = [2]string{
	0: "ports",
	1: "to",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyEgressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyEgressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPINetworkingV1NetworkPolicyPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "to":
			if err := func() error {
				s.To = make([]IoK8sAPINetworkingV1NetworkPolicyPeer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPeer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.To = append(s.To, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyEgressRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyEgressRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) encodeFields(e *jx.Encoder) {
	{
		if s.From != nil {
			e.FieldStart("from")
			e.ArrStart()
			for _, elem := range s.From {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ports != nil {
			e.FieldStart("ports")
			e.ArrStart()
			for _, elem := range s.Ports {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyIngressRule = [2]string{
	0: "from",
	1: "ports",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyIngressRule from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyIngressRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From = make([]IoK8sAPINetworkingV1NetworkPolicyPeer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPeer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.From = append(s.From, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "ports":
			if err := func() error {
				s.Ports = make([]IoK8sAPINetworkingV1NetworkPolicyPort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyPort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyIngressRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyIngressRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyList from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINetworkingV1NetworkPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) encodeFields(e *jx.Encoder) {
	{
		if s.IpBlock.Set {
			e.FieldStart("ipBlock")
			s.IpBlock.Encode(e)
		}
	}
	{
		if s.NamespaceSelector.Set {
			e.FieldStart("namespaceSelector")
			s.NamespaceSelector.Encode(e)
		}
	}
	{
		if s.PodSelector.Set {
			e.FieldStart("podSelector")
			s.PodSelector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPeer = [3]string{
	0: "ipBlock",
	1: "namespaceSelector",
	2: "podSelector",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPeer from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPeer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipBlock":
			if err := func() error {
				s.IpBlock.Reset()
				if err := s.IpBlock.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipBlock\"")
			}
		case "namespaceSelector":
			if err := func() error {
				s.NamespaceSelector.Reset()
				if err := s.NamespaceSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaceSelector\"")
			}
		case "podSelector":
			if err := func() error {
				s.PodSelector.Reset()
				if err := s.PodSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podSelector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyPeer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPeer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) encodeFields(e *jx.Encoder) {
	{
		if s.EndPort.Set {
			e.FieldStart("endPort")
			s.EndPort.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicyPort = [3]string{
	0: "endPort",
	1: "port",
	2: "protocol",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicyPort from json.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicyPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endPort":
			if err := func() error {
				s.EndPort.Reset()
				if err := s.EndPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endPort\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicyPort")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicyPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) encodeFields(e *jx.Encoder) {
	{
		if s.Egress != nil {
			e.FieldStart("egress")
			e.ArrStart()
			for _, elem := range s.Egress {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ingress != nil {
			e.FieldStart("ingress")
			e.ArrStart()
			for _, elem := range s.Ingress {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("podSelector")
		s.PodSelector.Encode(e)
	}
	{
		if s.PolicyTypes != nil {
			e.FieldStart("policyTypes")
			e.ArrStart()
			for _, elem := range s.PolicyTypes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec = [4]string{
	0: "egress",
	1: "ingress",
	2: "podSelector",
	3: "policyTypes",
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1NetworkPolicySpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "egress":
			if err := func() error {
				s.Egress = make([]IoK8sAPINetworkingV1NetworkPolicyEgressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyEgressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Egress = append(s.Egress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"egress\"")
			}
		case "ingress":
			if err := func() error {
				s.Ingress = make([]IoK8sAPINetworkingV1NetworkPolicyIngressRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINetworkingV1NetworkPolicyIngressRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ingress = append(s.Ingress, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ingress\"")
			}
		case "podSelector":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PodSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podSelector\"")
			}
		case "policyTypes":
			if err := func() error {
				s.PolicyTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PolicyTypes = append(s.PolicyTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policyTypes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1NetworkPolicySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPINetworkingV1NetworkPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1NetworkPolicySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINetworkingV1ServiceBackendPort = [2]string{
	0: "name",
	1: "number",
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINetworkingV1ServiceBackendPort to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINetworkingV1ServiceBackendPort")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINetworkingV1ServiceBackendPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1Overhead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1Overhead) encodeFields(e *jx.Encoder) {
	{
		if s.PodFixed.Set {
			e.FieldStart("podFixed")
			s.PodFixed.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (s *IoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1Overhead")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1OverheadPodFixed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1OverheadPodFixed) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPINodeV1OverheadPodFixed from json.
func (s *IoK8sAPINodeV1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1OverheadPodFixed to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1OverheadPodFixed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1RuntimeClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1RuntimeClass) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("handler")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.FieldStart("overhead")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.FieldStart("scheduling")
			s.Scheduling.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1RuntimeClass from json.
func (s *IoK8sAPINodeV1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Handler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handler\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1RuntimeClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1RuntimeClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1RuntimeClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1RuntimeClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1RuntimeClassList from json.
func (s *IoK8sAPINodeV1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1RuntimeClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1RuntimeClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1Scheduling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1Scheduling) encodeFields(e *jx.Encoder) {
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (s *IoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1Scheduling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1SchedulingNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPINodeV1SchedulingNodeSelector from json.
func (s *IoK8sAPINodeV1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1SchedulingNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1SchedulingNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1alpha1Overhead) encodeFields(e *jx.Encoder) {
	{
		if s.PodFixed.Set {
			e.FieldStart("podFixed")
			s.PodFixed.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (s *IoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1Overhead")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1alpha1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1OverheadPodFixed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1OverheadPodFixed) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPINodeV1alpha1OverheadPodFixed from json.
func (s *IoK8sAPINodeV1alpha1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1OverheadPodFixed to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1OverheadPodFixed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1alpha1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClass from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassList from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1alpha1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1alpha1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Overhead.Set {
			e.FieldStart("overhead")
			s.Overhead.Encode(e)
		}
	}
	{
		e.FieldStart("runtimeHandler")
		e.Str(s.RuntimeHandler)
	}
	{
		if s.Scheduling.Set {
			e.FieldStart("scheduling")
			s.Scheduling.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec = [3]string{
	0: "overhead",
	1: "runtimeHandler",
	2: "scheduling",
}

// Decode decodes IoK8sAPINodeV1alpha1RuntimeClassSpec from json.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1RuntimeClassSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "runtimeHandler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RuntimeHandler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeHandler\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1RuntimeClassSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec) {
					name = jsonFieldsNameOfIoK8sAPINodeV1alpha1RuntimeClassSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1RuntimeClassSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1alpha1Scheduling) encodeFields(e *jx.Encoder) {
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1alpha1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (s *IoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1Scheduling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1alpha1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1alpha1SchedulingNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPINodeV1alpha1SchedulingNodeSelector from json.
func (s *IoK8sAPINodeV1alpha1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1alpha1SchedulingNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1alpha1SchedulingNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1alpha1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1alpha1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1beta1Overhead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1beta1Overhead) encodeFields(e *jx.Encoder) {
	{
		if s.PodFixed.Set {
			e.FieldStart("podFixed")
			s.PodFixed.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Overhead = [1]string{
	0: "podFixed",
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (s *IoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1Overhead to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podFixed":
			if err := func() error {
				s.PodFixed.Reset()
				if err := s.PodFixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podFixed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1Overhead")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1beta1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1OverheadPodFixed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1beta1OverheadPodFixed) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPINodeV1beta1OverheadPodFixed from json.
func (s *IoK8sAPINodeV1beta1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1OverheadPodFixed to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgAPIResourceQuantity
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1OverheadPodFixed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1beta1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1beta1RuntimeClass) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("handler")
		e.Str(s.Handler)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Overhead.Set {
			e.FieldStart("overhead")
			s.Overhead.Encode(e)
		}
	}
	{
		if s.Scheduling.Set {
			e.FieldStart("scheduling")
			s.Scheduling.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass = [6]string{
	0: "apiVersion",
	1: "handler",
	2: "kind",
	3: "metadata",
	4: "overhead",
	5: "scheduling",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClass from json.
func (s *IoK8sAPINodeV1beta1RuntimeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "handler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Handler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handler\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "overhead":
			if err := func() error {
				s.Overhead.Reset()
				if err := s.Overhead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overhead\"")
			}
		case "scheduling":
			if err := func() error {
				s.Scheduling.Reset()
				if err := s.Scheduling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduling\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1RuntimeClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPINodeV1beta1RuntimeClassList from json.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1RuntimeClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPINodeV1beta1RuntimeClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPINodeV1beta1RuntimeClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1RuntimeClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList) {
					name = jsonFieldsNameOfIoK8sAPINodeV1beta1RuntimeClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1RuntimeClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPINodeV1beta1Scheduling) encodeFields(e *jx.Encoder) {
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPINodeV1beta1Scheduling = [2]string{
	0: "nodeSelector",
	1: "tolerations",
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (s *IoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1Scheduling to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]IoK8sAPICoreV1Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1Scheduling")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPINodeV1beta1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPINodeV1beta1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPINodeV1beta1SchedulingNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPINodeV1beta1SchedulingNodeSelector from json.
func (s *IoK8sAPINodeV1beta1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPINodeV1beta1SchedulingNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPINodeV1beta1SchedulingNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPINodeV1beta1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPINodeV1beta1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudget")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1PodDisruptionBudget, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1PodDisruptionBudget
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MaxUnavailable.Set {
			e.FieldStart("maxUnavailable")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			e.FieldStart("minAvailable")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		case "minAvailable":
			if err := func() error {
				s.MinAvailable.Reset()
				if err := s.MinAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minAvailable\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("currentHealthy")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.FieldStart("desiredHealthy")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.FieldStart("disruptedPods")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.FieldStart("disruptionsAllowed")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.FieldStart("expectedPods")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentHealthy\"")
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredHealthy\"")
			}
		case "disruptedPods":
			if err := func() error {
				s.DisruptedPods.Reset()
				if err := s.DisruptedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptedPods\"")
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DisruptionsAllowed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptionsAllowed\"")
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ExpectedPods = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedPods\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods from json.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgApisMetaV1Time
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver = [1]string{
	0: "name",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedCSIDriver from json.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedCSIDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedCSIDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedCSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedCSIDriver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("driver")
		e.Str(s.Driver)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume = [1]string{
	0: "driver",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedFlexVolume from json.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedFlexVolume to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "driver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Driver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedFlexVolume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedFlexVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedFlexVolume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) encodeFields(e *jx.Encoder) {
	{
		if s.PathPrefix.Set {
			e.FieldStart("pathPrefix")
			s.PathPrefix.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1AllowedHostPath = [2]string{
	0: "pathPrefix",
	1: "readOnly",
}

// Decode decodes IoK8sAPIPolicyV1beta1AllowedHostPath from json.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1AllowedHostPath to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pathPrefix":
			if err := func() error {
				s.PathPrefix.Reset()
				if err := s.PathPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pathPrefix\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1AllowedHostPath")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1AllowedHostPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ranges != nil {
			e.FieldStart("ranges")
			e.ArrStart()
			for _, elem := range s.Ranges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			e.FieldStart("rule")
			s.Rule.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1FSGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1FSGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1FSGroupStrategyOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			if err := func() error {
				s.Rule.Reset()
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1FSGroupStrategyOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1FSGroupStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max")
		e.Int32(s.Max)
	}
	{
		e.FieldStart("min")
		e.Int32(s.Min)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1HostPortRange from json.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1HostPortRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Max = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Min = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1HostPortRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1HostPortRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1HostPortRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1IDRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1IDRange) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max")
		e.Int64(s.Max)
	}
	{
		e.FieldStart("min")
		e.Int64(s.Min)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange = [2]string{
	0: "max",
	1: "min",
}

// Decode decodes IoK8sAPIPolicyV1beta1IDRange from json.
func (s *IoK8sAPIPolicyV1beta1IDRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1IDRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Max = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Min = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1IDRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1IDRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1IDRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1IDRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudget = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudget from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudget")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetList from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1beta1PodDisruptionBudget, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1PodDisruptionBudget
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) encodeFields(e *jx.Encoder) {
	{
		if s.MaxUnavailable.Set {
			e.FieldStart("maxUnavailable")
			s.MaxUnavailable.Encode(e)
		}
	}
	{
		if s.MinAvailable.Set {
			e.FieldStart("minAvailable")
			s.MinAvailable.Encode(e)
		}
	}
	{
		if s.Selector.Set {
			e.FieldStart("selector")
			s.Selector.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec = [3]string{
	0: "maxUnavailable",
	1: "minAvailable",
	2: "selector",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxUnavailable":
			if err := func() error {
				s.MaxUnavailable.Reset()
				if err := s.MaxUnavailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxUnavailable\"")
			}
		case "minAvailable":
			if err := func() error {
				s.MinAvailable.Reset()
				if err := s.MinAvailable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minAvailable\"")
			}
		case "selector":
			if err := func() error {
				s.Selector.Reset()
				if err := s.Selector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("currentHealthy")
		e.Int32(s.CurrentHealthy)
	}
	{
		e.FieldStart("desiredHealthy")
		e.Int32(s.DesiredHealthy)
	}
	{
		if s.DisruptedPods.Set {
			e.FieldStart("disruptedPods")
			s.DisruptedPods.Encode(e)
		}
	}
	{
		e.FieldStart("disruptionsAllowed")
		e.Int32(s.DisruptionsAllowed)
	}
	{
		e.FieldStart("expectedPods")
		e.Int32(s.ExpectedPods)
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus = [7]string{
	0: "conditions",
	1: "currentHealthy",
	2: "desiredHealthy",
	3: "disruptedPods",
	4: "disruptionsAllowed",
	5: "expectedPods",
	6: "observedGeneration",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApimachineryPkgApisMetaV1Condition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1Condition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "currentHealthy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentHealthy\"")
			}
		case "desiredHealthy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DesiredHealthy = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desiredHealthy\"")
			}
		case "disruptedPods":
			if err := func() error {
				s.DisruptedPods.Reset()
				if err := s.DisruptedPods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptedPods\"")
			}
		case "disruptionsAllowed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DisruptionsAllowed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disruptionsAllowed\"")
			}
		case "expectedPods":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ExpectedPods = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedPods\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods from json.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApimachineryPkgApisMetaV1Time
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicy = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicy from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicyList from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIPolicyV1beta1PodSecurityPolicy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1PodSecurityPolicy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicyList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) encodeFields(e *jx.Encoder) {
	{
		if s.AllowPrivilegeEscalation.Set {
			e.FieldStart("allowPrivilegeEscalation")
			s.AllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.AllowedCSIDrivers != nil {
			e.FieldStart("allowedCSIDrivers")
			e.ArrStart()
			for _, elem := range s.AllowedCSIDrivers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedCapabilities != nil {
			e.FieldStart("allowedCapabilities")
			e.ArrStart()
			for _, elem := range s.AllowedCapabilities {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedFlexVolumes != nil {
			e.FieldStart("allowedFlexVolumes")
			e.ArrStart()
			for _, elem := range s.AllowedFlexVolumes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedHostPaths != nil {
			e.FieldStart("allowedHostPaths")
			e.ArrStart()
			for _, elem := range s.AllowedHostPaths {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedProcMountTypes != nil {
			e.FieldStart("allowedProcMountTypes")
			e.ArrStart()
			for _, elem := range s.AllowedProcMountTypes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedUnsafeSysctls != nil {
			e.FieldStart("allowedUnsafeSysctls")
			e.ArrStart()
			for _, elem := range s.AllowedUnsafeSysctls {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAddCapabilities != nil {
			e.FieldStart("defaultAddCapabilities")
			e.ArrStart()
			for _, elem := range s.DefaultAddCapabilities {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultAllowPrivilegeEscalation.Set {
			e.FieldStart("defaultAllowPrivilegeEscalation")
			s.DefaultAllowPrivilegeEscalation.Encode(e)
		}
	}
	{
		if s.ForbiddenSysctls != nil {
			e.FieldStart("forbiddenSysctls")
			e.ArrStart()
			for _, elem := range s.ForbiddenSysctls {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("fsGroup")
		s.FsGroup.Encode(e)
	}
	{
		if s.HostIPC.Set {
			e.FieldStart("hostIPC")
			s.HostIPC.Encode(e)
		}
	}
	{
		if s.HostNetwork.Set {
			e.FieldStart("hostNetwork")
			s.HostNetwork.Encode(e)
		}
	}
	{
		if s.HostPID.Set {
			e.FieldStart("hostPID")
			s.HostPID.Encode(e)
		}
	}
	{
		if s.HostPorts != nil {
			e.FieldStart("hostPorts")
			e.ArrStart()
			for _, elem := range s.HostPorts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privileged.Set {
			e.FieldStart("privileged")
			s.Privileged.Encode(e)
		}
	}
	{
		if s.ReadOnlyRootFilesystem.Set {
			e.FieldStart("readOnlyRootFilesystem")
			s.ReadOnlyRootFilesystem.Encode(e)
		}
	}
	{
		if s.RequiredDropCapabilities != nil {
			e.FieldStart("requiredDropCapabilities")
			e.ArrStart()
			for _, elem := range s.RequiredDropCapabilities {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
	{
		e.FieldStart("runAsUser")
		s.RunAsUser.Encode(e)
	}
	{
		if s.RuntimeClass.Set {
			e.FieldStart("runtimeClass")
			s.RuntimeClass.Encode(e)
		}
	}
	{
		e.FieldStart("seLinux")
		s.SeLinux.Encode(e)
	}
	{
		e.FieldStart("supplementalGroups")
		s.SupplementalGroups.Encode(e)
	}
	{
		if s.Volumes != nil {
			e.FieldStart("volumes")
			e.ArrStart()
			for _, elem := range s.Volumes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec = [24]string{
	0:  "allowPrivilegeEscalation",
	1:  "allowedCSIDrivers",
	2:  "allowedCapabilities",
	3:  "allowedFlexVolumes",
	4:  "allowedHostPaths",
	5:  "allowedProcMountTypes",
	6:  "allowedUnsafeSysctls",
	7:  "defaultAddCapabilities",
	8:  "defaultAllowPrivilegeEscalation",
	9:  "forbiddenSysctls",
	10: "fsGroup",
	11: "hostIPC",
	12: "hostNetwork",
	13: "hostPID",
	14: "hostPorts",
	15: "privileged",
	16: "readOnlyRootFilesystem",
	17: "requiredDropCapabilities",
	18: "runAsGroup",
	19: "runAsUser",
	20: "runtimeClass",
	21: "seLinux",
	22: "supplementalGroups",
	23: "volumes",
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowPrivilegeEscalation":
			if err := func() error {
				s.AllowPrivilegeEscalation.Reset()
				if err := s.AllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowPrivilegeEscalation\"")
			}
		case "allowedCSIDrivers":
			if err := func() error {
				s.AllowedCSIDrivers = make([]IoK8sAPIPolicyV1beta1AllowedCSIDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedCSIDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedCSIDrivers = append(s.AllowedCSIDrivers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedCSIDrivers\"")
			}
		case "allowedCapabilities":
			if err := func() error {
				s.AllowedCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedCapabilities = append(s.AllowedCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedCapabilities\"")
			}
		case "allowedFlexVolumes":
			if err := func() error {
				s.AllowedFlexVolumes = make([]IoK8sAPIPolicyV1beta1AllowedFlexVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedFlexVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedFlexVolumes = append(s.AllowedFlexVolumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedFlexVolumes\"")
			}
		case "allowedHostPaths":
			if err := func() error {
				s.AllowedHostPaths = make([]IoK8sAPIPolicyV1beta1AllowedHostPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1AllowedHostPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedHostPaths = append(s.AllowedHostPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedHostPaths\"")
			}
		case "allowedProcMountTypes":
			if err := func() error {
				s.AllowedProcMountTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedProcMountTypes = append(s.AllowedProcMountTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedProcMountTypes\"")
			}
		case "allowedUnsafeSysctls":
			if err := func() error {
				s.AllowedUnsafeSysctls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedUnsafeSysctls = append(s.AllowedUnsafeSysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedUnsafeSysctls\"")
			}
		case "defaultAddCapabilities":
			if err := func() error {
				s.DefaultAddCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DefaultAddCapabilities = append(s.DefaultAddCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAddCapabilities\"")
			}
		case "defaultAllowPrivilegeEscalation":
			if err := func() error {
				s.DefaultAllowPrivilegeEscalation.Reset()
				if err := s.DefaultAllowPrivilegeEscalation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAllowPrivilegeEscalation\"")
			}
		case "forbiddenSysctls":
			if err := func() error {
				s.ForbiddenSysctls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ForbiddenSysctls = append(s.ForbiddenSysctls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forbiddenSysctls\"")
			}
		case "fsGroup":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.FsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroup\"")
			}
		case "hostIPC":
			if err := func() error {
				s.HostIPC.Reset()
				if err := s.HostIPC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostIPC\"")
			}
		case "hostNetwork":
			if err := func() error {
				s.HostNetwork.Reset()
				if err := s.HostNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostNetwork\"")
			}
		case "hostPID":
			if err := func() error {
				s.HostPID.Reset()
				if err := s.HostPID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPID\"")
			}
		case "hostPorts":
			if err := func() error {
				s.HostPorts = make([]IoK8sAPIPolicyV1beta1HostPortRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1HostPortRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HostPorts = append(s.HostPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostPorts\"")
			}
		case "privileged":
			if err := func() error {
				s.Privileged.Reset()
				if err := s.Privileged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privileged\"")
			}
		case "readOnlyRootFilesystem":
			if err := func() error {
				s.ReadOnlyRootFilesystem.Reset()
				if err := s.ReadOnlyRootFilesystem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyRootFilesystem\"")
			}
		case "requiredDropCapabilities":
			if err := func() error {
				s.RequiredDropCapabilities = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredDropCapabilities = append(s.RequiredDropCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDropCapabilities\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		case "runAsUser":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "runtimeClass":
			if err := func() error {
				s.RuntimeClass.Reset()
				if err := s.RuntimeClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClass\"")
			}
		case "seLinux":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.SeLinux.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinux\"")
			}
		case "supplementalGroups":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.SupplementalGroups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supplementalGroups\"")
			}
		case "volumes":
			if err := func() error {
				s.Volumes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Volumes = append(s.Volumes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1PodSecurityPolicySpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000100,
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1PodSecurityPolicySpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1PodSecurityPolicySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ranges != nil {
			e.FieldStart("ranges")
			e.ArrStart()
			for _, elem := range s.Ranges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("rule")
		e.Str(s.Rule)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ranges != nil {
			e.FieldStart("ranges")
			e.ArrStart()
			for _, elem := range s.Ranges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("rule")
		e.Str(s.Rule)
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RunAsUserStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1RunAsUserStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("allowedRuntimeClassNames")
		e.ArrStart()
		for _, elem := range s.AllowedRuntimeClassNames {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.DefaultRuntimeClassName.Set {
			e.FieldStart("defaultRuntimeClassName")
			s.DefaultRuntimeClassName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions = [2]string{
	0: "allowedRuntimeClassNames",
	1: "defaultRuntimeClassName",
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedRuntimeClassNames":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AllowedRuntimeClassNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedRuntimeClassNames = append(s.AllowedRuntimeClassNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedRuntimeClassNames\"")
			}
		case "defaultRuntimeClassName":
			if err := func() error {
				s.DefaultRuntimeClassName.Reset()
				if err := s.DefaultRuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRuntimeClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule")
		e.Str(s.Rule)
	}
	{
		if s.SeLinuxOptions.Set {
			e.FieldStart("seLinuxOptions")
			s.SeLinuxOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions = [2]string{
	0: "rule",
	1: "seLinuxOptions",
}

// Decode decodes IoK8sAPIPolicyV1beta1SELinuxStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1SELinuxStrategyOptions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Rule = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "seLinuxOptions":
			if err := func() error {
				s.SeLinuxOptions.Reset()
				if err := s.SeLinuxOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seLinuxOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1SELinuxStrategyOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions) {
					name = jsonFieldsNameOfIoK8sAPIPolicyV1beta1SELinuxStrategyOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1SELinuxStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ranges != nil {
			e.FieldStart("ranges")
			e.ArrStart()
			for _, elem := range s.Ranges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rule.Set {
			e.FieldStart("rule")
			s.Rule.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions = [2]string{
	0: "ranges",
	1: "rule",
}

// Decode decodes IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions from json.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ranges":
			if err := func() error {
				s.Ranges = make([]IoK8sAPIPolicyV1beta1IDRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIPolicyV1beta1IDRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ranges = append(s.Ranges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ranges\"")
			}
		case "rule":
			if err := func() error {
				s.Rule.Reset()
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIPolicyV1beta1SupplementalGroupsStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1AggregationRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1AggregationRule) encodeFields(e *jx.Encoder) {
	{
		if s.ClusterRoleSelectors != nil {
			e.FieldStart("clusterRoleSelectors")
			e.ArrStart()
			for _, elem := range s.ClusterRoleSelectors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1AggregationRule = [1]string{
	0: "clusterRoleSelectors",
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (s *IoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1AggregationRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterRoleSelectors":
			if err := func() error {
				s.ClusterRoleSelectors = make([]IoK8sApimachineryPkgApisMetaV1LabelSelector, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1LabelSelector
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClusterRoleSelectors = append(s.ClusterRoleSelectors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterRoleSelectors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1AggregationRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1AggregationRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1AggregationRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1ClusterRole) encodeFields(e *jx.Encoder) {
	{
		if s.AggregationRule.Set {
			e.FieldStart("aggregationRule")
			s.AggregationRule.Encode(e)
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRole = [5]string{
	0: "aggregationRule",
	1: "apiVersion",
	2: "kind",
	3: "metadata",
	4: "rules",
}

// Decode decodes IoK8sAPIRbacV1ClusterRole from json.
func (s *IoK8sAPIRbacV1ClusterRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRole to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aggregationRule":
			if err := func() error {
				s.AggregationRule.Reset()
				if err := s.AggregationRule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggregationRule\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIRbacV1PolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1PolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRole")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1ClusterRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("roleRef")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.FieldStart("subjects")
			e.ArrStart()
			for _, elem := range s.Subjects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBinding from json.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBinding to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RoleRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roleRef\"")
			}
		case "subjects":
			if err := func() error {
				s.Subjects = make([]IoK8sAPIRbacV1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleBinding")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBinding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleBindingList from json.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleBindingList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1ClusterRoleBinding, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1ClusterRoleBinding
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleBindingList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1ClusterRoleBindingList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1ClusterRoleList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1ClusterRoleList from json.
func (s *IoK8sAPIRbacV1ClusterRoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1ClusterRoleList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1ClusterRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1ClusterRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1ClusterRoleList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1ClusterRoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1ClusterRoleList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1ClusterRoleList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1PolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1PolicyRule) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroups != nil {
			e.FieldStart("apiGroups")
			e.ArrStart()
			for _, elem := range s.ApiGroups {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NonResourceURLs != nil {
			e.FieldStart("nonResourceURLs")
			e.ArrStart()
			for _, elem := range s.NonResourceURLs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceNames != nil {
			e.FieldStart("resourceNames")
			e.ArrStart()
			for _, elem := range s.ResourceNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule = [5]string{
	0: "apiGroups",
	1: "nonResourceURLs",
	2: "resourceNames",
	3: "resources",
	4: "verbs",
}

// Decode decodes IoK8sAPIRbacV1PolicyRule from json.
func (s *IoK8sAPIRbacV1PolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1PolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroups":
			if err := func() error {
				s.ApiGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ApiGroups = append(s.ApiGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroups\"")
			}
		case "nonResourceURLs":
			if err := func() error {
				s.NonResourceURLs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NonResourceURLs = append(s.NonResourceURLs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nonResourceURLs\"")
			}
		case "resourceNames":
			if err := func() error {
				s.ResourceNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ResourceNames = append(s.ResourceNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceNames\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "verbs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1PolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1PolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1PolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1PolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1Role) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1Role) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1Role = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "rules",
}

// Decode decodes IoK8sAPIRbacV1Role from json.
func (s *IoK8sAPIRbacV1Role) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1Role to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IoK8sAPIRbacV1PolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1PolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1Role")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1Role) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1Role) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1RoleBinding) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1RoleBinding) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("roleRef")
		s.RoleRef.Encode(e)
	}
	{
		if s.Subjects != nil {
			e.FieldStart("subjects")
			e.ArrStart()
			for _, elem := range s.Subjects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "roleRef",
	4: "subjects",
}

// Decode decodes IoK8sAPIRbacV1RoleBinding from json.
func (s *IoK8sAPIRbacV1RoleBinding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleBinding to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "roleRef":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RoleRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roleRef\"")
			}
		case "subjects":
			if err := func() error {
				s.Subjects = make([]IoK8sAPIRbacV1Subject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Subject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subjects = append(s.Subjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subjects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleBinding")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBinding[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1RoleBinding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1RoleBinding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1RoleBindingList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1RoleBindingList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleBindingList from json.
func (s *IoK8sAPIRbacV1RoleBindingList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleBindingList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1RoleBinding, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1RoleBinding
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleBindingList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleBindingList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1RoleBindingList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1RoleBindingList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1RoleList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1RoleList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIRbacV1RoleList from json.
func (s *IoK8sAPIRbacV1RoleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIRbacV1Role, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIRbacV1Role
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleList) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1RoleList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1RoleList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1RoleRef) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1RoleRef) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiGroup")
		e.Str(s.ApiGroup)
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1RoleRef = [3]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
}

// Decode decodes IoK8sAPIRbacV1RoleRef from json.
func (s *IoK8sAPIRbacV1RoleRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1RoleRef to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiGroup = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1RoleRef")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1RoleRef) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1RoleRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1RoleRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1RoleRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIRbacV1Subject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIRbacV1Subject) encodeFields(e *jx.Encoder) {
	{
		if s.ApiGroup.Set {
			e.FieldStart("apiGroup")
			s.ApiGroup.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIRbacV1Subject = [4]string{
	0: "apiGroup",
	1: "kind",
	2: "name",
	3: "namespace",
}

// Decode decodes IoK8sAPIRbacV1Subject from json.
func (s *IoK8sAPIRbacV1Subject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIRbacV1Subject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiGroup":
			if err := func() error {
				s.ApiGroup.Reset()
				if err := s.ApiGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiGroup\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIRbacV1Subject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIRbacV1Subject) {
					name = jsonFieldsNameOfIoK8sAPIRbacV1Subject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIRbacV1Subject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIRbacV1Subject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPISchedulingV1PriorityClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPISchedulingV1PriorityClass) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.GlobalDefault.Set {
			e.FieldStart("globalDefault")
			s.GlobalDefault.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.PreemptionPolicy.Set {
			e.FieldStart("preemptionPolicy")
			s.PreemptionPolicy.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Int32(s.Value)
	}
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass = [7]string{
	0: "apiVersion",
	1: "description",
	2: "globalDefault",
	3: "kind",
	4: "metadata",
	5: "preemptionPolicy",
	6: "value",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClass from json.
func (s *IoK8sAPISchedulingV1PriorityClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPISchedulingV1PriorityClass to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "globalDefault":
			if err := func() error {
				s.GlobalDefault.Reset()
				if err := s.GlobalDefault.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"globalDefault\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "preemptionPolicy":
			if err := func() error {
				s.PreemptionPolicy.Reset()
				if err := s.PreemptionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preemptionPolicy\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Value = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPISchedulingV1PriorityClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPISchedulingV1PriorityClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPISchedulingV1PriorityClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPISchedulingV1PriorityClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPISchedulingV1PriorityClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPISchedulingV1PriorityClassList from json.
func (s *IoK8sAPISchedulingV1PriorityClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPISchedulingV1PriorityClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPISchedulingV1PriorityClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPISchedulingV1PriorityClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPISchedulingV1PriorityClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList) {
					name = jsonFieldsNameOfIoK8sAPISchedulingV1PriorityClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPISchedulingV1PriorityClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPISchedulingV1PriorityClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriver) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSIDriver) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSIDriver from json.
func (s *IoK8sAPIStorageV1CSIDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSIDriver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriverList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSIDriverList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverList from json.
func (s *IoK8sAPIStorageV1CSIDriverList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriverList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1CSIDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSIDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriverList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriverList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSIDriverList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriverSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSIDriverSpec) encodeFields(e *jx.Encoder) {
	{
		if s.AttachRequired.Set {
			e.FieldStart("attachRequired")
			s.AttachRequired.Encode(e)
		}
	}
	{
		if s.FsGroupPolicy.Set {
			e.FieldStart("fsGroupPolicy")
			s.FsGroupPolicy.Encode(e)
		}
	}
	{
		if s.PodInfoOnMount.Set {
			e.FieldStart("podInfoOnMount")
			s.PodInfoOnMount.Encode(e)
		}
	}
	{
		if s.RequiresRepublish.Set {
			e.FieldStart("requiresRepublish")
			s.RequiresRepublish.Encode(e)
		}
	}
	{
		if s.StorageCapacity.Set {
			e.FieldStart("storageCapacity")
			s.StorageCapacity.Encode(e)
		}
	}
	{
		if s.TokenRequests != nil {
			e.FieldStart("tokenRequests")
			e.ArrStart()
			for _, elem := range s.TokenRequests {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VolumeLifecycleModes != nil {
			e.FieldStart("volumeLifecycleModes")
			e.ArrStart()
			for _, elem := range s.VolumeLifecycleModes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSIDriverSpec = [7]string{
	0: "attachRequired",
	1: "fsGroupPolicy",
	2: "podInfoOnMount",
	3: "requiresRepublish",
	4: "storageCapacity",
	5: "tokenRequests",
	6: "volumeLifecycleModes",
}

// Decode decodes IoK8sAPIStorageV1CSIDriverSpec from json.
func (s *IoK8sAPIStorageV1CSIDriverSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSIDriverSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachRequired":
			if err := func() error {
				s.AttachRequired.Reset()
				if err := s.AttachRequired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachRequired\"")
			}
		case "fsGroupPolicy":
			if err := func() error {
				s.FsGroupPolicy.Reset()
				if err := s.FsGroupPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fsGroupPolicy\"")
			}
		case "podInfoOnMount":
			if err := func() error {
				s.PodInfoOnMount.Reset()
				if err := s.PodInfoOnMount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podInfoOnMount\"")
			}
		case "requiresRepublish":
			if err := func() error {
				s.RequiresRepublish.Reset()
				if err := s.RequiresRepublish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiresRepublish\"")
			}
		case "storageCapacity":
			if err := func() error {
				s.StorageCapacity.Reset()
				if err := s.StorageCapacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageCapacity\"")
			}
		case "tokenRequests":
			if err := func() error {
				s.TokenRequests = make([]IoK8sAPIStorageV1TokenRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1TokenRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TokenRequests = append(s.TokenRequests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenRequests\"")
			}
		case "volumeLifecycleModes":
			if err := func() error {
				s.VolumeLifecycleModes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VolumeLifecycleModes = append(s.VolumeLifecycleModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeLifecycleModes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSIDriverSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSIDriverSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSIDriverSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSINode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSINode) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINode = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
}

// Decode decodes IoK8sAPIStorageV1CSINode from json.
func (s *IoK8sAPIStorageV1CSINode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINode) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSINode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSINode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeDriver) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSINodeDriver) encodeFields(e *jx.Encoder) {
	{
		if s.Allocatable.Set {
			e.FieldStart("allocatable")
			s.Allocatable.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("nodeID")
		e.Str(s.NodeID)
	}
	{
		if s.TopologyKeys != nil {
			e.FieldStart("topologyKeys")
			e.ArrStart()
			for _, elem := range s.TopologyKeys {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver = [4]string{
	0: "allocatable",
	1: "name",
	2: "nodeID",
	3: "topologyKeys",
}

// Decode decodes IoK8sAPIStorageV1CSINodeDriver from json.
func (s *IoK8sAPIStorageV1CSINodeDriver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeDriver to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allocatable":
			if err := func() error {
				s.Allocatable.Reset()
				if err := s.Allocatable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allocatable\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodeID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeID\"")
			}
		case "topologyKeys":
			if err := func() error {
				s.TopologyKeys = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TopologyKeys = append(s.TopologyKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeDriver")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeDriver[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeDriver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSINodeDriver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSINodeList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1CSINodeList from json.
func (s *IoK8sAPIStorageV1CSINodeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1CSINode, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSINode
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSINodeList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1CSINodeSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("drivers")
		e.ArrStart()
		for _, elem := range s.Drivers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec = [1]string{
	0: "drivers",
}

// Decode decodes IoK8sAPIStorageV1CSINodeSpec from json.
func (s *IoK8sAPIStorageV1CSINodeSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1CSINodeSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drivers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Drivers = make([]IoK8sAPIStorageV1CSINodeDriver, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1CSINodeDriver
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drivers = append(s.Drivers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drivers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1CSINodeSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1CSINodeSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1CSINodeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1CSINodeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1StorageClass) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1StorageClass) encodeFields(e *jx.Encoder) {
	{
		if s.AllowVolumeExpansion.Set {
			e.FieldStart("allowVolumeExpansion")
			s.AllowVolumeExpansion.Encode(e)
		}
	}
	{
		if s.AllowedTopologies != nil {
			e.FieldStart("allowedTopologies")
			e.ArrStart()
			for _, elem := range s.AllowedTopologies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.MountOptions != nil {
			e.FieldStart("mountOptions")
			e.ArrStart()
			for _, elem := range s.MountOptions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		e.FieldStart("provisioner")
		e.Str(s.Provisioner)
	}
	{
		if s.ReclaimPolicy.Set {
			e.FieldStart("reclaimPolicy")
			s.ReclaimPolicy.Encode(e)
		}
	}
	{
		if s.VolumeBindingMode.Set {
			e.FieldStart("volumeBindingMode")
			s.VolumeBindingMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClass = [10]string{
	0: "allowVolumeExpansion",
	1: "allowedTopologies",
	2: "apiVersion",
	3: "kind",
	4: "metadata",
	5: "mountOptions",
	6: "parameters",
	7: "provisioner",
	8: "reclaimPolicy",
	9: "volumeBindingMode",
}

// Decode decodes IoK8sAPIStorageV1StorageClass from json.
func (s *IoK8sAPIStorageV1StorageClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClass to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowVolumeExpansion":
			if err := func() error {
				s.AllowVolumeExpansion.Reset()
				if err := s.AllowVolumeExpansion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowVolumeExpansion\"")
			}
		case "allowedTopologies":
			if err := func() error {
				s.AllowedTopologies = make([]IoK8sAPICoreV1TopologySelectorTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPICoreV1TopologySelectorTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedTopologies = append(s.AllowedTopologies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedTopologies\"")
			}
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "mountOptions":
			if err := func() error {
				s.MountOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MountOptions = append(s.MountOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mountOptions\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "provisioner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Provisioner = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provisioner\"")
			}
		case "reclaimPolicy":
			if err := func() error {
				s.ReclaimPolicy.Reset()
				if err := s.ReclaimPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reclaimPolicy\"")
			}
		case "volumeBindingMode":
			if err := func() error {
				s.VolumeBindingMode.Reset()
				if err := s.VolumeBindingMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volumeBindingMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClass")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClass) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClass[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1StorageClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1StorageClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1StorageClassList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1StorageClassList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1StorageClassList from json.
func (s *IoK8sAPIStorageV1StorageClassList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClassList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1StorageClass, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1StorageClass
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClassList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1StorageClassList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1StorageClassList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1StorageClassList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClassParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIStorageV1StorageClassParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPIStorageV1StorageClassParameters from json.
func (s *IoK8sAPIStorageV1StorageClassParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1StorageClassParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1StorageClassParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIStorageV1StorageClassParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1StorageClassParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1TokenRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1TokenRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audience")
		e.Str(s.Audience)
	}
	{
		if s.ExpirationSeconds.Set {
			e.FieldStart("expirationSeconds")
			s.ExpirationSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest = [2]string{
	0: "audience",
	1: "expirationSeconds",
}

// Decode decodes IoK8sAPIStorageV1TokenRequest from json.
func (s *IoK8sAPIStorageV1TokenRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1TokenRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audience":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Audience = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audience\"")
			}
		case "expirationSeconds":
			if err := func() error {
				s.ExpirationSeconds.Reset()
				if err := s.ExpirationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1TokenRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1TokenRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1TokenRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1TokenRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeAttachment) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachment from json.
func (s *IoK8sAPIStorageV1VolumeAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentList from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1VolumeAttachment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1VolumeAttachment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) encodeFields(e *jx.Encoder) {
	{
		if s.InlineVolumeSpec.Set {
			e.FieldStart("inlineVolumeSpec")
			s.InlineVolumeSpec.Encode(e)
		}
	}
	{
		if s.PersistentVolumeName.Set {
			e.FieldStart("persistentVolumeName")
			s.PersistentVolumeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSource = [2]string{
	0: "inlineVolumeSpec",
	1: "persistentVolumeName",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSource from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inlineVolumeSpec":
			if err := func() error {
				s.InlineVolumeSpec.Reset()
				if err := s.InlineVolumeSpec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inlineVolumeSpec\"")
			}
		case "persistentVolumeName":
			if err := func() error {
				s.PersistentVolumeName.Reset()
				if err := s.PersistentVolumeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentVolumeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attacher")
		e.Str(s.Attacher)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec = [3]string{
	0: "attacher",
	1: "nodeName",
	2: "source",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentSpec from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attacher":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Attacher = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attacher\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AttachError.Set {
			e.FieldStart("attachError")
			s.AttachError.Encode(e)
		}
	}
	{
		e.FieldStart("attached")
		e.Bool(s.Attached)
	}
	{
		if s.AttachmentMetadata.Set {
			e.FieldStart("attachmentMetadata")
			s.AttachmentMetadata.Encode(e)
		}
	}
	{
		if s.DetachError.Set {
			e.FieldStart("detachError")
			s.DetachError.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus = [4]string{
	0: "attachError",
	1: "attached",
	2: "attachmentMetadata",
	3: "detachError",
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attachError":
			if err := func() error {
				s.AttachError.Reset()
				if err := s.AttachError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachError\"")
			}
		case "attached":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Attached = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attached\"")
			}
		case "attachmentMetadata":
			if err := func() error {
				s.AttachmentMetadata.Reset()
				if err := s.AttachmentMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachmentMetadata\"")
			}
		case "detachError":
			if err := func() error {
				s.DetachError.Reset()
				if err := s.DetachError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detachError\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1VolumeAttachmentStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata from json.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeError) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeError = [2]string{
	0: "message",
	1: "time",
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (s *IoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1VolumeNodeResources) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1VolumeNodeResources = [1]string{
	0: "count",
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (s *IoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1VolumeNodeResources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1VolumeNodeResources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1VolumeNodeResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1VolumeNodeResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			e.FieldStart("maximumVolumeSize")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			e.FieldStart("nodeTopology")
			s.NodeTopology.Encode(e)
		}
	}
	{
		e.FieldStart("storageClassName")
		e.Str(s.StorageClassName)
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "maximumVolumeSize":
			if err := func() error {
				s.MaximumVolumeSize.Reset()
				if err := s.MaximumVolumeSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximumVolumeSize\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "nodeTopology":
			if err := func() error {
				s.NodeTopology.Reset()
				if err := s.NodeTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeTopology\"")
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StorageClassName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1alpha1CSIStorageCapacity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1alpha1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1alpha1CSIStorageCapacityList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1alpha1CSIStorageCapacity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1alpha1CSIStorageCapacity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1alpha1CSIStorageCapacityList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1alpha1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1alpha1CSIStorageCapacityList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Capacity.Set {
			e.FieldStart("capacity")
			s.Capacity.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.MaximumVolumeSize.Set {
			e.FieldStart("maximumVolumeSize")
			s.MaximumVolumeSize.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.NodeTopology.Set {
			e.FieldStart("nodeTopology")
			s.NodeTopology.Encode(e)
		}
	}
	{
		e.FieldStart("storageClassName")
		e.Str(s.StorageClassName)
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity = [7]string{
	0: "apiVersion",
	1: "capacity",
	2: "kind",
	3: "maximumVolumeSize",
	4: "metadata",
	5: "nodeTopology",
	6: "storageClassName",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacity from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "capacity":
			if err := func() error {
				s.Capacity.Reset()
				if err := s.Capacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "maximumVolumeSize":
			if err := func() error {
				s.MaximumVolumeSize.Reset()
				if err := s.MaximumVolumeSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximumVolumeSize\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "nodeTopology":
			if err := func() error {
				s.NodeTopology.Reset()
				if err := s.NodeTopology.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeTopology\"")
			}
		case "storageClassName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StorageClassName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageClassName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1beta1CSIStorageCapacity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sAPIStorageV1beta1CSIStorageCapacityList from json.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sAPIStorageV1beta1CSIStorageCapacityList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sAPIStorageV1beta1CSIStorageCapacity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sAPIStorageV1beta1CSIStorageCapacity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sAPIStorageV1beta1CSIStorageCapacityList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList) {
					name = jsonFieldsNameOfIoK8sAPIStorageV1beta1CSIStorageCapacityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sAPIStorageV1beta1CSIStorageCapacityList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	{
		e.FieldStart("jsonPath")
		e.Str(s.JsonPath)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition = [6]string{
	0: "description",
	1: "format",
	2: "jsonPath",
	3: "name",
	4: "priority",
	5: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "jsonPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.JsonPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jsonPath\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("strategy")
		e.Str(s.Strategy)
	}
	{
		if s.Webhook.Set {
			e.FieldStart("webhook")
			s.Webhook.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion = [2]string{
	0: "strategy",
	1: "webhook",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strategy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Strategy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "webhook":
			if err := func() error {
				s.Webhook.Reset()
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) encodeFields(e *jx.Encoder) {
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		if s.ListKind.Set {
			e.FieldStart("listKind")
			s.ListKind.Encode(e)
		}
	}
	{
		e.FieldStart("plural")
		e.Str(s.Plural)
	}
	{
		if s.ShortNames != nil {
			e.FieldStart("shortNames")
			e.ArrStart()
			for _, elem := range s.ShortNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Singular.Set {
			e.FieldStart("singular")
			s.Singular.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames = [6]string{
	0: "categories",
	1: "kind",
	2: "listKind",
	3: "plural",
	4: "shortNames",
	5: "singular",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "listKind":
			if err := func() error {
				s.ListKind.Reset()
				if err := s.ListKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"listKind\"")
			}
		case "plural":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Plural = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plural\"")
			}
		case "shortNames":
			if err := func() error {
				s.ShortNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ShortNames = append(s.ShortNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortNames\"")
			}
		case "singular":
			if err := func() error {
				s.Singular.Reset()
				if err := s.Singular.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"singular\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Conversion.Set {
			e.FieldStart("conversion")
			s.Conversion.Encode(e)
		}
	}
	{
		e.FieldStart("group")
		e.Str(s.Group)
	}
	{
		e.FieldStart("names")
		s.Names.Encode(e)
	}
	{
		if s.PreserveUnknownFields.Set {
			e.FieldStart("preserveUnknownFields")
			s.PreserveUnknownFields.Encode(e)
		}
	}
	{
		e.FieldStart("scope")
		e.Str(s.Scope)
	}
	{
		e.FieldStart("versions")
		e.ArrStart()
		for _, elem := range s.Versions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec = [6]string{
	0: "conversion",
	1: "group",
	2: "names",
	3: "preserveUnknownFields",
	4: "scope",
	5: "versions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversion":
			if err := func() error {
				s.Conversion.Reset()
				if err := s.Conversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversion\"")
			}
		case "group":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Group = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "names":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Names.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "preserveUnknownFields":
			if err := func() error {
				s.PreserveUnknownFields.Reset()
				if err := s.PreserveUnknownFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preserveUnknownFields\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Scope = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Versions = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) encodeFields(e *jx.Encoder) {
	{
		if s.AcceptedNames.Set {
			e.FieldStart("acceptedNames")
			s.AcceptedNames.Encode(e)
		}
	}
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StoredVersions != nil {
			e.FieldStart("storedVersions")
			e.ArrStart()
			for _, elem := range s.StoredVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus = [3]string{
	0: "acceptedNames",
	1: "conditions",
	2: "storedVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acceptedNames":
			if err := func() error {
				s.AcceptedNames.Reset()
				if err := s.AcceptedNames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptedNames\"")
			}
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "storedVersions":
			if err := func() error {
				s.StoredVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StoredVersions = append(s.StoredVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storedVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) encodeFields(e *jx.Encoder) {
	{
		if s.AdditionalPrinterColumns != nil {
			e.FieldStart("additionalPrinterColumns")
			e.ArrStart()
			for _, elem := range s.AdditionalPrinterColumns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.DeprecationWarning.Set {
			e.FieldStart("deprecationWarning")
			s.DeprecationWarning.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{
		e.FieldStart("served")
		e.Bool(s.Served)
	}
	{
		e.FieldStart("storage")
		e.Bool(s.Storage)
	}
	{
		if s.Subresources.Set {
			e.FieldStart("subresources")
			s.Subresources.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion = [8]string{
	0: "additionalPrinterColumns",
	1: "deprecated",
	2: "deprecationWarning",
	3: "name",
	4: "schema",
	5: "served",
	6: "storage",
	7: "subresources",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additionalPrinterColumns":
			if err := func() error {
				s.AdditionalPrinterColumns = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceColumnDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AdditionalPrinterColumns = append(s.AdditionalPrinterColumns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalPrinterColumns\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "deprecationWarning":
			if err := func() error {
				s.DeprecationWarning.Reset()
				if err := s.DeprecationWarning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecationWarning\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Schema = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "served":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Served = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"served\"")
			}
		case "storage":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Storage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storage\"")
			}
		case "subresources":
			if err := func() error {
				s.Subresources.Reset()
				if err := s.Subresources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelectorPath.Set {
			e.FieldStart("labelSelectorPath")
			s.LabelSelectorPath.Encode(e)
		}
	}
	{
		e.FieldStart("specReplicasPath")
		e.Str(s.SpecReplicasPath)
	}
	{
		e.FieldStart("statusReplicasPath")
		e.Str(s.StatusReplicasPath)
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale = [3]string{
	0: "labelSelectorPath",
	1: "specReplicasPath",
	2: "statusReplicasPath",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelectorPath":
			if err := func() error {
				s.LabelSelectorPath.Reset()
				if err := s.LabelSelectorPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelectorPath\"")
			}
		case "specReplicasPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SpecReplicasPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"specReplicasPath\"")
			}
		case "statusReplicasPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StatusReplicasPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusReplicasPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) encodeFields(e *jx.Encoder) {
	{
		if s.Scale.Set {
			e.FieldStart("scale")
			s.Scale.Encode(e)
		}
	}
	{
		if s.Status != nil {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources = [2]string{
	0: "scale",
	1: "status",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scale":
			if err := func() error {
				s.Scale.Reset()
				if err := s.Scale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scale\"")
			}
		case "status":
			if err := func() error {
				s.Status = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Status = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) encodeFields(e *jx.Encoder) {
	{
		if s.OpenAPIV3Schema != nil {
			e.FieldStart("openAPIV3Schema")
			s.OpenAPIV3Schema.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation = [1]string{
	0: "openAPIV3Schema",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openAPIV3Schema":
			if err := func() error {
				s.OpenAPIV3Schema = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OpenAPIV3Schema = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openAPIV3Schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation = [2]string{
	0: "description",
	1: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) encodeFields(e *jx.Encoder) {
	{
		if s.Ref.Set {
			e.FieldStart("$ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("$schema")
			s.Schema.Encode(e)
		}
	}
	{
		if s.AdditionalItems != nil {
			e.FieldStart("additionalItems")
			s.AdditionalItems.Encode(e)
		}
	}
	{
		if s.AdditionalProperties != nil {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.AllOf != nil {
			e.FieldStart("allOf")
			e.ArrStart()
			for _, elem := range s.AllOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnyOf != nil {
			e.FieldStart("anyOf")
			e.ArrStart()
			for _, elem := range s.AnyOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Default != nil {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.Definitions.Set {
			e.FieldStart("definitions")
			s.Definitions.Encode(e)
		}
	}
	{
		if s.Dependencies.Set {
			e.FieldStart("dependencies")
			s.Dependencies.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Enum != nil {
			e.FieldStart("enum")
			e.ArrStart()
			for _, elem := range s.Enum {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Example != nil {
			e.FieldStart("example")
			s.Example.Encode(e)
		}
	}
	{
		if s.ExclusiveMaximum.Set {
			e.FieldStart("exclusiveMaximum")
			s.ExclusiveMaximum.Encode(e)
		}
	}
	{
		if s.ExclusiveMinimum.Set {
			e.FieldStart("exclusiveMinimum")
			s.ExclusiveMinimum.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			s.Items.Encode(e)
		}
	}
	{
		if s.MaxItems.Set {
			e.FieldStart("maxItems")
			s.MaxItems.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			e.FieldStart("maxLength")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.MaxProperties.Set {
			e.FieldStart("maxProperties")
			s.MaxProperties.Encode(e)
		}
	}
	{
		if s.Maximum.Set {
			e.FieldStart("maximum")
			s.Maximum.Encode(e)
		}
	}
	{
		if s.MinItems.Set {
			e.FieldStart("minItems")
			s.MinItems.Encode(e)
		}
	}
	{
		if s.MinLength.Set {
			e.FieldStart("minLength")
			s.MinLength.Encode(e)
		}
	}
	{
		if s.MinProperties.Set {
			e.FieldStart("minProperties")
			s.MinProperties.Encode(e)
		}
	}
	{
		if s.Minimum.Set {
			e.FieldStart("minimum")
			s.Minimum.Encode(e)
		}
	}
	{
		if s.MultipleOf.Set {
			e.FieldStart("multipleOf")
			s.MultipleOf.Encode(e)
		}
	}
	{
		if s.Not != nil {
			e.FieldStart("not")
			s.Not.Encode(e)
		}
	}
	{
		if s.Nullable.Set {
			e.FieldStart("nullable")
			s.Nullable.Encode(e)
		}
	}
	{
		if s.OneOf != nil {
			e.FieldStart("oneOf")
			e.ArrStart()
			for _, elem := range s.OneOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.PatternProperties.Set {
			e.FieldStart("patternProperties")
			s.PatternProperties.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.Required != nil {
			e.FieldStart("required")
			e.ArrStart()
			for _, elem := range s.Required {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UniqueItems.Set {
			e.FieldStart("uniqueItems")
			s.UniqueItems.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusEmbeddedMinusResource.Set {
			e.FieldStart("x-kubernetes-embedded-resource")
			s.XMinusKubernetesMinusEmbeddedMinusResource.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusIntMinusOrMinusString.Set {
			e.FieldStart("x-kubernetes-int-or-string")
			s.XMinusKubernetesMinusIntMinusOrMinusString.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusMapMinusKeys != nil {
			e.FieldStart("x-kubernetes-list-map-keys")
			e.ArrStart()
			for _, elem := range s.XMinusKubernetesMinusListMinusMapMinusKeys {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.XMinusKubernetesMinusListMinusType.Set {
			e.FieldStart("x-kubernetes-list-type")
			s.XMinusKubernetesMinusListMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusMapMinusType.Set {
			e.FieldStart("x-kubernetes-map-type")
			s.XMinusKubernetesMinusMapMinusType.Encode(e)
		}
	}
	{
		if s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Set {
			e.FieldStart("x-kubernetes-preserve-unknown-fields")
			s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps = [43]string{
	0:  "$ref",
	1:  "$schema",
	2:  "additionalItems",
	3:  "additionalProperties",
	4:  "allOf",
	5:  "anyOf",
	6:  "default",
	7:  "definitions",
	8:  "dependencies",
	9:  "description",
	10: "enum",
	11: "example",
	12: "exclusiveMaximum",
	13: "exclusiveMinimum",
	14: "externalDocs",
	15: "format",
	16: "id",
	17: "items",
	18: "maxItems",
	19: "maxLength",
	20: "maxProperties",
	21: "maximum",
	22: "minItems",
	23: "minLength",
	24: "minProperties",
	25: "minimum",
	26: "multipleOf",
	27: "not",
	28: "nullable",
	29: "oneOf",
	30: "pattern",
	31: "patternProperties",
	32: "properties",
	33: "required",
	34: "title",
	35: "type",
	36: "uniqueItems",
	37: "x-kubernetes-embedded-resource",
	38: "x-kubernetes-int-or-string",
	39: "x-kubernetes-list-map-keys",
	40: "x-kubernetes-list-type",
	41: "x-kubernetes-map-type",
	42: "x-kubernetes-preserve-unknown-fields",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "$schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$schema\"")
			}
		case "additionalItems":
			if err := func() error {
				s.AdditionalItems = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalItems = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalItems\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalProperties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "allOf":
			if err := func() error {
				s.AllOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllOf = append(s.AllOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allOf\"")
			}
		case "anyOf":
			if err := func() error {
				s.AnyOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnyOf = append(s.AnyOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anyOf\"")
			}
		case "default":
			if err := func() error {
				s.Default = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Default = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "definitions":
			if err := func() error {
				s.Definitions.Reset()
				if err := s.Definitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"definitions\"")
			}
		case "dependencies":
			if err := func() error {
				s.Dependencies.Reset()
				if err := s.Dependencies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependencies\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enum":
			if err := func() error {
				s.Enum = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Enum = append(s.Enum, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "example":
			if err := func() error {
				s.Example = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSON
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Example = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "exclusiveMaximum":
			if err := func() error {
				s.ExclusiveMaximum.Reset()
				if err := s.ExclusiveMaximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMaximum\"")
			}
		case "exclusiveMinimum":
			if err := func() error {
				s.ExclusiveMinimum.Reset()
				if err := s.ExclusiveMinimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMinimum\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "items":
			if err := func() error {
				s.Items = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "maxItems":
			if err := func() error {
				s.MaxItems.Reset()
				if err := s.MaxItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxItems\"")
			}
		case "maxLength":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLength\"")
			}
		case "maxProperties":
			if err := func() error {
				s.MaxProperties.Reset()
				if err := s.MaxProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxProperties\"")
			}
		case "maximum":
			if err := func() error {
				s.Maximum.Reset()
				if err := s.Maximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum\"")
			}
		case "minItems":
			if err := func() error {
				s.MinItems.Reset()
				if err := s.MinItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minItems\"")
			}
		case "minLength":
			if err := func() error {
				s.MinLength.Reset()
				if err := s.MinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minLength\"")
			}
		case "minProperties":
			if err := func() error {
				s.MinProperties.Reset()
				if err := s.MinProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minProperties\"")
			}
		case "minimum":
			if err := func() error {
				s.Minimum.Reset()
				if err := s.Minimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum\"")
			}
		case "multipleOf":
			if err := func() error {
				s.MultipleOf.Reset()
				if err := s.MultipleOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multipleOf\"")
			}
		case "not":
			if err := func() error {
				s.Not = nil
				var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Not = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"not\"")
			}
		case "nullable":
			if err := func() error {
				s.Nullable.Reset()
				if err := s.Nullable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nullable\"")
			}
		case "oneOf":
			if err := func() error {
				s.OneOf = make([]IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OneOf = append(s.OneOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneOf\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "patternProperties":
			if err := func() error {
				s.PatternProperties.Reset()
				if err := s.PatternProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patternProperties\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "required":
			if err := func() error {
				s.Required = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Required = append(s.Required, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "uniqueItems":
			if err := func() error {
				s.UniqueItems.Reset()
				if err := s.UniqueItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueItems\"")
			}
		case "x-kubernetes-embedded-resource":
			if err := func() error {
				s.XMinusKubernetesMinusEmbeddedMinusResource.Reset()
				if err := s.XMinusKubernetesMinusEmbeddedMinusResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-embedded-resource\"")
			}
		case "x-kubernetes-int-or-string":
			if err := func() error {
				s.XMinusKubernetesMinusIntMinusOrMinusString.Reset()
				if err := s.XMinusKubernetesMinusIntMinusOrMinusString.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-int-or-string\"")
			}
		case "x-kubernetes-list-map-keys":
			if err := func() error {
				s.XMinusKubernetesMinusListMinusMapMinusKeys = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.XMinusKubernetesMinusListMinusMapMinusKeys = append(s.XMinusKubernetesMinusListMinusMapMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-list-map-keys\"")
			}
		case "x-kubernetes-list-type":
			if err := func() error {
				s.XMinusKubernetesMinusListMinusType.Reset()
				if err := s.XMinusKubernetesMinusListMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-list-type\"")
			}
		case "x-kubernetes-map-type":
			if err := func() error {
				s.XMinusKubernetesMinusMapMinusType.Reset()
				if err := s.XMinusKubernetesMinusMapMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-map-type\"")
			}
		case "x-kubernetes-preserve-unknown-fields":
			if err := func() error {
				s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Reset()
				if err := s.XMinusKubernetesMinusPreserveMinusUnknownMinusFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x-kubernetes-preserve-unknown-fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray = [0]string{}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsOrStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference = [4]string{
	0: "name",
	1: "namespace",
	2: "path",
	3: "port",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("caBundle")
		e.Base64(s.CaBundle)
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig = [3]string{
	0: "caBundle",
	1: "service",
	2: "url",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) encodeFields(e *jx.Encoder) {
	{
		if s.ClientConfig.Set {
			e.FieldStart("clientConfig")
			s.ClientConfig.Encode(e)
		}
	}
	{
		e.FieldStart("conversionReviewVersions")
		e.ArrStart()
		for _, elem := range s.ConversionReviewVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion = [2]string{
	0: "clientConfig",
	1: "conversionReviewVersions",
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientConfig":
			if err := func() error {
				s.ClientConfig.Reset()
				if err := s.ClientConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientConfig\"")
			}
		case "conversionReviewVersions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ConversionReviewVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ConversionReviewVersions = append(s.ConversionReviewVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversionReviewVersions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) {
					name = jsonFieldsNameOfIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (s IoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (s *IoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgAPIResourceQuantity to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgAPIResourceQuantity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgAPIResourceQuantity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgAPIResourceQuantity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PreferredVersion.Set {
			e.FieldStart("preferredVersion")
			s.PreferredVersion.Encode(e)
		}
	}
	{
		if s.ServerAddressByClientCIDRs != nil {
			e.FieldStart("serverAddressByClientCIDRs")
			e.ArrStart()
			for _, elem := range s.ServerAddressByClientCIDRs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("versions")
		e.ArrStart()
		for _, elem := range s.Versions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup = [6]string{
	0: "apiVersion",
	1: "kind",
	2: "name",
	3: "preferredVersion",
	4: "serverAddressByClientCIDRs",
	5: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroup from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "preferredVersion":
			if err := func() error {
				s.PreferredVersion.Reset()
				if err := s.PreferredVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredVersion\"")
			}
		case "serverAddressByClientCIDRs":
			if err := func() error {
				s.ServerAddressByClientCIDRs = make([]IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddressByClientCIDRs\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Versions = make([]IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList = [3]string{
	0: "apiVersion",
	1: "groups",
	2: "kind",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIGroupList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIGroupList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Groups = make([]IoK8sApimachineryPkgApisMetaV1APIGroup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1APIGroup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIGroupList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIGroupList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIGroupList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) encodeFields(e *jx.Encoder) {
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("namespaced")
		e.Bool(s.Namespaced)
	}
	{
		if s.ShortNames != nil {
			e.FieldStart("shortNames")
			e.ArrStart()
			for _, elem := range s.ShortNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("singularName")
		e.Str(s.SingularName)
	}
	{
		if s.StorageVersionHash.Set {
			e.FieldStart("storageVersionHash")
			s.StorageVersionHash.Encode(e)
		}
	}
	{
		e.FieldStart("verbs")
		e.ArrStart()
		for _, elem := range s.Verbs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource = [10]string{
	0: "categories",
	1: "group",
	2: "kind",
	3: "name",
	4: "namespaced",
	5: "shortNames",
	6: "singularName",
	7: "storageVersionHash",
	8: "verbs",
	9: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResource from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespaced":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Namespaced = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaced\"")
			}
		case "shortNames":
			if err := func() error {
				s.ShortNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ShortNames = append(s.ShortNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortNames\"")
			}
		case "singularName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.SingularName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"singularName\"")
			}
		case "storageVersionHash":
			if err := func() error {
				s.StorageVersionHash.Reset()
				if err := s.StorageVersionHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageVersionHash\"")
			}
		case "verbs":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Verbs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Verbs = append(s.Verbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verbs\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("groupVersion")
		e.Str(s.GroupVersion)
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		e.FieldStart("resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList = [4]string{
	0: "apiVersion",
	1: "groupVersion",
	2: "kind",
	3: "resources",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIResourceList from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIResourceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "groupVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Resources = make([]IoK8sApimachineryPkgApisMetaV1APIResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1APIResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIResourceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIResourceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIResourceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		e.FieldStart("serverAddressByClientCIDRs")
		e.ArrStart()
		for _, elem := range s.ServerAddressByClientCIDRs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("versions")
		e.ArrStart()
		for _, elem := range s.Versions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions = [4]string{
	0: "apiVersion",
	1: "kind",
	2: "serverAddressByClientCIDRs",
	3: "versions",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1APIVersions from json.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1APIVersions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "serverAddressByClientCIDRs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ServerAddressByClientCIDRs = make([]IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ServerAddressByClientCIDRs = append(s.ServerAddressByClientCIDRs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddressByClientCIDRs\"")
			}
		case "versions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Versions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1APIVersions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1APIVersions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1APIVersions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastTransitionTime")
		s.LastTransitionTime.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.ObservedGeneration.Set {
			e.FieldStart("observedGeneration")
			s.ObservedGeneration.Encode(e)
		}
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition = [6]string{
	0: "lastTransitionTime",
	1: "message",
	2: "observedGeneration",
	3: "reason",
	4: "status",
	5: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Condition from json.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Condition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "observedGeneration":
			if err := func() error {
				s.ObservedGeneration.Reset()
				if err := s.ObservedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observedGeneration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1Condition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1Condition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1Condition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1FieldsV1 = [0]string{}

// Decode decodes IoK8sApimachineryPkgApisMetaV1FieldsV1 from json.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1FieldsV1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1FieldsV1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1FieldsV1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("groupVersion")
		e.Str(s.GroupVersion)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery = [2]string{
	0: "groupVersion",
	1: "version",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groupVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupVersion\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelector = [2]string{
	0: "matchExpressions",
	1: "matchLabels",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement from json.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1LabelSelectorRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Continue.Set {
			e.FieldStart("continue")
			s.Continue.Encode(e)
		}
	}
	{
		if s.RemainingItemCount.Set {
			e.FieldStart("remainingItemCount")
			s.RemainingItemCount.Encode(e)
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			e.FieldStart("selfLink")
			s.SelfLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ListMeta = [4]string{
	0: "continue",
	1: "remainingItemCount",
	2: "resourceVersion",
	3: "selfLink",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ListMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "continue":
			if err := func() error {
				s.Continue.Reset()
				if err := s.Continue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"continue\"")
			}
		case "remainingItemCount":
			if err := func() error {
				s.RemainingItemCount.Reset()
				if err := s.RemainingItemCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remainingItemCount\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "selfLink":
			if err := func() error {
				s.SelfLink.Reset()
				if err := s.SelfLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ListMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ListMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.FieldsType.Set {
			e.FieldStart("fieldsType")
			s.FieldsType.Encode(e)
		}
	}
	{
		if s.FieldsV1 != nil {
			e.FieldStart("fieldsV1")
			s.FieldsV1.Encode(e)
		}
	}
	{
		if s.Manager.Set {
			e.FieldStart("manager")
			s.Manager.Encode(e)
		}
	}
	{
		if s.Operation.Set {
			e.FieldStart("operation")
			s.Operation.Encode(e)
		}
	}
	{
		if s.Subresource.Set {
			e.FieldStart("subresource")
			s.Subresource.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry = [7]string{
	0: "apiVersion",
	1: "fieldsType",
	2: "fieldsV1",
	3: "manager",
	4: "operation",
	5: "subresource",
	6: "time",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry from json.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "fieldsType":
			if err := func() error {
				s.FieldsType.Reset()
				if err := s.FieldsType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldsType\"")
			}
		case "fieldsV1":
			if err := func() error {
				s.FieldsV1 = nil
				var elem IoK8sApimachineryPkgApisMetaV1FieldsV1
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FieldsV1 = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldsV1\"")
			}
		case "manager":
			if err := func() error {
				s.Manager.Reset()
				if err := s.Manager.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manager\"")
			}
		case "operation":
			if err := func() error {
				s.Operation.Reset()
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "subresource":
			if err := func() error {
				s.Subresource.Reset()
				if err := s.Subresource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (s IoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (s *IoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1MicroTime to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1MicroTime(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1MicroTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1MicroTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Annotations.Set {
			e.FieldStart("annotations")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("clusterName")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.CreationTimestamp.Set {
			e.FieldStart("creationTimestamp")
			s.CreationTimestamp.Encode(e)
		}
	}
	{
		if s.DeletionGracePeriodSeconds.Set {
			e.FieldStart("deletionGracePeriodSeconds")
			s.DeletionGracePeriodSeconds.Encode(e)
		}
	}
	{
		if s.DeletionTimestamp.Set {
			e.FieldStart("deletionTimestamp")
			s.DeletionTimestamp.Encode(e)
		}
	}
	{
		if s.Finalizers != nil {
			e.FieldStart("finalizers")
			e.ArrStart()
			for _, elem := range s.Finalizers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GenerateName.Set {
			e.FieldStart("generateName")
			s.GenerateName.Encode(e)
		}
	}
	{
		if s.Generation.Set {
			e.FieldStart("generation")
			s.Generation.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.ManagedFields != nil {
			e.FieldStart("managedFields")
			e.ArrStart()
			for _, elem := range s.ManagedFields {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.OwnerReferences != nil {
			e.FieldStart("ownerReferences")
			e.ArrStart()
			for _, elem := range s.OwnerReferences {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResourceVersion.Set {
			e.FieldStart("resourceVersion")
			s.ResourceVersion.Encode(e)
		}
	}
	{
		if s.SelfLink.Set {
			e.FieldStart("selfLink")
			s.SelfLink.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ObjectMeta = [16]string{
	0:  "annotations",
	1:  "clusterName",
	2:  "creationTimestamp",
	3:  "deletionGracePeriodSeconds",
	4:  "deletionTimestamp",
	5:  "finalizers",
	6:  "generateName",
	7:  "generation",
	8:  "labels",
	9:  "managedFields",
	10: "name",
	11: "namespace",
	12: "ownerReferences",
	13: "resourceVersion",
	14: "selfLink",
	15: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "clusterName":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "creationTimestamp":
			if err := func() error {
				s.CreationTimestamp.Reset()
				if err := s.CreationTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creationTimestamp\"")
			}
		case "deletionGracePeriodSeconds":
			if err := func() error {
				s.DeletionGracePeriodSeconds.Reset()
				if err := s.DeletionGracePeriodSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletionGracePeriodSeconds\"")
			}
		case "deletionTimestamp":
			if err := func() error {
				s.DeletionTimestamp.Reset()
				if err := s.DeletionTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletionTimestamp\"")
			}
		case "finalizers":
			if err := func() error {
				s.Finalizers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Finalizers = append(s.Finalizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalizers\"")
			}
		case "generateName":
			if err := func() error {
				s.GenerateName.Reset()
				if err := s.GenerateName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateName\"")
			}
		case "generation":
			if err := func() error {
				s.Generation.Reset()
				if err := s.Generation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generation\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "managedFields":
			if err := func() error {
				s.ManagedFields = make([]IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1ManagedFieldsEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ManagedFields = append(s.ManagedFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managedFields\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "ownerReferences":
			if err := func() error {
				s.OwnerReferences = make([]IoK8sApimachineryPkgApisMetaV1OwnerReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sApimachineryPkgApisMetaV1OwnerReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OwnerReferences = append(s.OwnerReferences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerReferences\"")
			}
		case "resourceVersion":
			if err := func() error {
				s.ResourceVersion.Reset()
				if err := s.ResourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceVersion\"")
			}
		case "selfLink":
			if err := func() error {
				s.SelfLink.Reset()
				if err := s.SelfLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selfLink\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations from json.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels from json.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiVersion")
		e.Str(s.ApiVersion)
	}
	{
		if s.BlockOwnerDeletion.Set {
			e.FieldStart("blockOwnerDeletion")
			s.BlockOwnerDeletion.Encode(e)
		}
	}
	{
		if s.Controller.Set {
			e.FieldStart("controller")
			s.Controller.Encode(e)
		}
	}
	{
		e.FieldStart("kind")
		e.Str(s.Kind)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("uid")
		e.Str(s.UID)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference = [6]string{
	0: "apiVersion",
	1: "blockOwnerDeletion",
	2: "controller",
	3: "kind",
	4: "name",
	5: "uid",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1OwnerReference from json.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1OwnerReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "blockOwnerDeletion":
			if err := func() error {
				s.BlockOwnerDeletion.Reset()
				if err := s.BlockOwnerDeletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockOwnerDeletion\"")
			}
		case "controller":
			if err := func() error {
				s.Controller.Reset()
				if err := s.Controller.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controller\"")
			}
		case "kind":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Kind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1OwnerReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1OwnerReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1OwnerReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientCIDR")
		e.Str(s.ClientCIDR)
	}
	{
		e.FieldStart("serverAddress")
		e.Str(s.ServerAddress)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR = [2]string{
	0: "clientCIDR",
	1: "serverAddress",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR from json.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientCIDR":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientCIDR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientCIDR\"")
			}
		case "serverAddress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ServerAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverAddress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1ServerAddressByClientCIDR) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (s IoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (s *IoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1Time to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgApisMetaV1Time(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgApisMetaV1Time) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1Time) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent = [2]string{
	0: "object",
	1: "type",
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1WatchEvent from json.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgApisMetaV1WatchEvent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgApisMetaV1WatchEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgApisMetaV1WatchEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgApisMetaV1WatchEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfIoK8sApimachineryPkgRuntimeRawExtension = [0]string{}

// Decode decodes IoK8sApimachineryPkgRuntimeRawExtension from json.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgRuntimeRawExtension to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgRuntimeRawExtension")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgRuntimeRawExtension) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (s IoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (s *IoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgUtilIntstrIntOrString to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IoK8sApimachineryPkgUtilIntstrIntOrString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IoK8sApimachineryPkgUtilIntstrIntOrString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgUtilIntstrIntOrString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sApimachineryPkgVersionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sApimachineryPkgVersionInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("buildDate")
		e.Str(s.BuildDate)
	}
	{
		e.FieldStart("compiler")
		e.Str(s.Compiler)
	}
	{
		e.FieldStart("gitCommit")
		e.Str(s.GitCommit)
	}
	{
		e.FieldStart("gitTreeState")
		e.Str(s.GitTreeState)
	}
	{
		e.FieldStart("gitVersion")
		e.Str(s.GitVersion)
	}
	{
		e.FieldStart("goVersion")
		e.Str(s.GoVersion)
	}
	{
		e.FieldStart("major")
		e.Str(s.Major)
	}
	{
		e.FieldStart("minor")
		e.Str(s.Minor)
	}
	{
		e.FieldStart("platform")
		e.Str(s.Platform)
	}
}

var jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo = [9]string{
	0: "buildDate",
	1: "compiler",
	2: "gitCommit",
	3: "gitTreeState",
	4: "gitVersion",
	5: "goVersion",
	6: "major",
	7: "minor",
	8: "platform",
}

// Decode decodes IoK8sApimachineryPkgVersionInfo from json.
func (s *IoK8sApimachineryPkgVersionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sApimachineryPkgVersionInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "buildDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BuildDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildDate\"")
			}
		case "compiler":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Compiler = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compiler\"")
			}
		case "gitCommit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitCommit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitCommit\"")
			}
		case "gitTreeState":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTreeState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitTreeState\"")
			}
		case "gitVersion":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitVersion\"")
			}
		case "goVersion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GoVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goVersion\"")
			}
		case "major":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Major = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major\"")
			}
		case "minor":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Minor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minor\"")
			}
		case "platform":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Platform = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sApimachineryPkgVersionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo) {
					name = jsonFieldsNameOfIoK8sApimachineryPkgVersionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sApimachineryPkgVersionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sApimachineryPkgVersionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Spec.Set {
			e.FieldStart("spec")
			s.Spec.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIService = [5]string{
	0: "apiVersion",
	1: "kind",
	2: "metadata",
	3: "spec",
	4: "status",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIService from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIService to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "spec":
			if err := func() error {
				s.Spec.Reset()
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIService")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIService) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) encodeFields(e *jx.Encoder) {
	{
		if s.LastTransitionTime.Set {
			e.FieldStart("lastTransitionTime")
			s.LastTransitionTime.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition = [5]string{
	0: "lastTransitionTime",
	1: "message",
	2: "reason",
	3: "status",
	4: "type",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastTransitionTime":
			if err := func() error {
				s.LastTransitionTime.Reset()
				if err := s.LastTransitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTransitionTime\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) encodeFields(e *jx.Encoder) {
	{
		if s.ApiVersion.Set {
			e.FieldStart("apiVersion")
			s.ApiVersion.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Kind.Set {
			e.FieldStart("kind")
			s.Kind.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList = [4]string{
	0: "apiVersion",
	1: "items",
	2: "kind",
	3: "metadata",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiVersion":
			if err := func() error {
				s.ApiVersion.Reset()
				if err := s.ApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiVersion\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]IoK8sKubeAggregatorPkgApisApiregistrationV1APIService, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIService
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "kind":
			if err := func() error {
				s.Kind.Reset()
				if err := s.Kind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kind\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("caBundle")
		e.Base64(s.CaBundle)
	}
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		e.FieldStart("groupPriorityMinimum")
		e.Int32(s.GroupPriorityMinimum)
	}
	{
		if s.InsecureSkipTLSVerify.Set {
			e.FieldStart("insecureSkipTLSVerify")
			s.InsecureSkipTLSVerify.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("versionPriority")
		e.Int32(s.VersionPriority)
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec = [7]string{
	0: "caBundle",
	1: "group",
	2: "groupPriorityMinimum",
	3: "insecureSkipTLSVerify",
	4: "service",
	5: "version",
	6: "versionPriority",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "caBundle":
			if err := func() error {
				v, err := d.Base64()
				s.CaBundle = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caBundle\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "groupPriorityMinimum":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.GroupPriorityMinimum = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groupPriorityMinimum\"")
			}
		case "insecureSkipTLSVerify":
			if err := func() error {
				s.InsecureSkipTLSVerify.Reset()
				if err := s.InsecureSkipTLSVerify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecureSkipTLSVerify\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "versionPriority":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.VersionPriority = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionPriority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) {
					name = jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Conditions != nil {
			e.FieldStart("conditions")
			e.ArrStart()
			for _, elem := range s.Conditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus = [1]string{
	0: "conditions",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conditions":
			if err := func() error {
				s.Conditions = make([]IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceCondition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
}

var jsonFieldsNameOfIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference = [3]string{
	0: "name",
	1: "namespace",
	2: "port",
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAdmissionregistrationV1ServiceReference as json.
func (o OptIoK8sAPIAdmissionregistrationV1ServiceReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAdmissionregistrationV1ServiceReference from json.
func (o *OptIoK8sAPIAdmissionregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAdmissionregistrationV1ServiceReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAdmissionregistrationV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAdmissionregistrationV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DaemonSetSpec as json.
func (o OptIoK8sAPIAppsV1DaemonSetSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetSpec from json.
func (o *OptIoK8sAPIAppsV1DaemonSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DaemonSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DaemonSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DaemonSetStatus as json.
func (o OptIoK8sAPIAppsV1DaemonSetStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetStatus from json.
func (o *OptIoK8sAPIAppsV1DaemonSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DaemonSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DaemonSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DaemonSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DaemonSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DaemonSetUpdateStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DaemonSetUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DeploymentSpec as json.
func (o OptIoK8sAPIAppsV1DeploymentSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentSpec from json.
func (o *OptIoK8sAPIAppsV1DeploymentSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DeploymentSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DeploymentSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DeploymentStatus as json.
func (o OptIoK8sAPIAppsV1DeploymentStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStatus from json.
func (o *OptIoK8sAPIAppsV1DeploymentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DeploymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DeploymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1DeploymentStrategy as json.
func (o OptIoK8sAPIAppsV1DeploymentStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1DeploymentStrategy from json.
func (o *OptIoK8sAPIAppsV1DeploymentStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1DeploymentStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1DeploymentStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1DeploymentStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetSpec as json.
func (o OptIoK8sAPIAppsV1ReplicaSetSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetSpec from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1ReplicaSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1ReplicaSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1ReplicaSetStatus as json.
func (o OptIoK8sAPIAppsV1ReplicaSetStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1ReplicaSetStatus from json.
func (o *OptIoK8sAPIAppsV1ReplicaSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1ReplicaSetStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1ReplicaSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1ReplicaSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDaemonSet as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDaemonSet from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDaemonSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDaemonSet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1RollingUpdateDaemonSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1RollingUpdateDaemonSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateDeployment as json.
func (o OptIoK8sAPIAppsV1RollingUpdateDeployment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateDeployment from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateDeployment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateDeployment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1RollingUpdateDeployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1RollingUpdateDeployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy as json.
func (o OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1RollingUpdateStatefulSetStrategy from json.
func (o *OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1RollingUpdateStatefulSetStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1StatefulSetSpec as json.
func (o OptIoK8sAPIAppsV1StatefulSetSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetSpec from json.
func (o *OptIoK8sAPIAppsV1StatefulSetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1StatefulSetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1StatefulSetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1StatefulSetStatus as json.
func (o OptIoK8sAPIAppsV1StatefulSetStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetStatus from json.
func (o *OptIoK8sAPIAppsV1StatefulSetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1StatefulSetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1StatefulSetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAppsV1StatefulSetUpdateStrategy as json.
func (o OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAppsV1StatefulSetUpdateStrategy from json.
func (o *OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAppsV1StatefulSetUpdateStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAppsV1StatefulSetUpdateStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV1HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleSpec as json.
func (o OptIoK8sAPIAutoscalingV1ScaleSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleSpec from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV1ScaleSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV1ScaleSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV1ScaleStatus as json.
func (o OptIoK8sAPIAutoscalingV1ScaleStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV1ScaleStatus from json.
func (o *OptIoK8sAPIAutoscalingV1ScaleStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV1ScaleStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV1ScaleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV1ScaleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ContainerResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ExternalMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ExternalMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ObjectMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ObjectMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1PodsMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1PodsMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta1ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta1ResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ContainerResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ExternalMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ExternalMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ExternalMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HPAScalingRules as json.
func (o OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HPAScalingRules from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HPAScalingRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2HPAScalingRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2HorizontalPodAutoscalerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ObjectMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ObjectMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ObjectMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2PodsMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2PodsMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2PodsMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricSource from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ResourceMetricSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus as json.
func (o OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIAutoscalingV2beta2ResourceMetricStatus from json.
func (o *OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIAutoscalingV2beta2ResourceMetricStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1CronJobSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1CronJobSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1CronJobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1CronJobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1CronJobStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1CronJobStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1CronJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1CronJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1JobSpec as json.
func (o OptIoK8sAPIBatchV1JobSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobSpec from json.
func (o *OptIoK8sAPIBatchV1JobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1JobSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1JobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1JobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1JobStatus as json.
func (o OptIoK8sAPIBatchV1JobStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1JobStatus from json.
func (o *OptIoK8sAPIBatchV1JobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1JobStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1JobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1JobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1UncountedTerminatedPods as json.
func (o OptIoK8sAPIBatchV1UncountedTerminatedPods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1UncountedTerminatedPods from json.
func (o *OptIoK8sAPIBatchV1UncountedTerminatedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1UncountedTerminatedPods to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1UncountedTerminatedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1UncountedTerminatedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobSpec as json.
func (o OptIoK8sAPIBatchV1beta1CronJobSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobSpec from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1beta1CronJobSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1beta1CronJobSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIBatchV1beta1CronJobStatus as json.
func (o OptIoK8sAPIBatchV1beta1CronJobStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIBatchV1beta1CronJobStatus from json.
func (o *OptIoK8sAPIBatchV1beta1CronJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIBatchV1beta1CronJobStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIBatchV1beta1CronJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIBatchV1beta1CronJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICertificatesV1CertificateSigningRequestSpecExtra)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICertificatesV1CertificateSigningRequestSpecExtra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICertificatesV1CertificateSigningRequestStatus as json.
func (o OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICertificatesV1CertificateSigningRequestStatus from json.
func (o *OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICertificatesV1CertificateSigningRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICertificatesV1CertificateSigningRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoordinationV1LeaseSpec as json.
func (o OptIoK8sAPICoordinationV1LeaseSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoordinationV1LeaseSpec from json.
func (o *OptIoK8sAPICoordinationV1LeaseSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoordinationV1LeaseSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoordinationV1LeaseSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoordinationV1LeaseSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource as json.
func (o OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AWSElasticBlockStoreVolumeSource from json.
func (o *OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1AWSElasticBlockStoreVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1Affinity as json.
func (o OptIoK8sAPICoreV1Affinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Affinity from json.
func (o *OptIoK8sAPICoreV1Affinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Affinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1Affinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1Affinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1AzureDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureDiskVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureDiskVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1AzureDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1AzureDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1AzureFilePersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFilePersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureFilePersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1AzureFilePersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1AzureFileVolumeSource as json.
func (o OptIoK8sAPICoreV1AzureFileVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1AzureFileVolumeSource from json.
func (o *OptIoK8sAPICoreV1AzureFileVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1AzureFileVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1AzureFileVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1AzureFileVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CSIPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CSIPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CSIPersistentVolumeSourceVolumeAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSource as json.
func (o OptIoK8sAPICoreV1CSIVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CSIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CSIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes as json.
func (o OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes from json.
func (o *OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1CSIVolumeSourceVolumeAttributes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CSIVolumeSourceVolumeAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1Capabilities as json.
func (o OptIoK8sAPICoreV1Capabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Capabilities from json.
func (o *OptIoK8sAPICoreV1Capabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Capabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1Capabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1Capabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CephFSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CephFSPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CephFSPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CephFSPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CephFSVolumeSource as json.
func (o OptIoK8sAPICoreV1CephFSVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CephFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1CephFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CephFSVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CephFSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CephFSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CinderPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CinderPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CinderPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CinderPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1CinderVolumeSource as json.
func (o OptIoK8sAPICoreV1CinderVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1CinderVolumeSource from json.
func (o *OptIoK8sAPICoreV1CinderVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1CinderVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1CinderVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1CinderVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ClientIPConfig as json.
func (o OptIoK8sAPICoreV1ClientIPConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ClientIPConfig from json.
func (o *OptIoK8sAPICoreV1ClientIPConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ClientIPConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ClientIPConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ClientIPConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapBinaryData as json.
func (o OptIoK8sAPICoreV1ConfigMapBinaryData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapBinaryData from json.
func (o *OptIoK8sAPICoreV1ConfigMapBinaryData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapBinaryData to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ConfigMapBinaryData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapBinaryData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapBinaryData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapData as json.
func (o OptIoK8sAPICoreV1ConfigMapData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapData from json.
func (o *OptIoK8sAPICoreV1ConfigMapData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapData to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ConfigMapData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapEnvSource as json.
func (o OptIoK8sAPICoreV1ConfigMapEnvSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapEnvSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapEnvSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapEnvSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapEnvSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapKeySelector as json.
func (o OptIoK8sAPICoreV1ConfigMapKeySelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapKeySelector from json.
func (o *OptIoK8sAPICoreV1ConfigMapKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapKeySelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapKeySelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapKeySelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapNodeConfigSource as json.
func (o OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapNodeConfigSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapNodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapNodeConfigSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapNodeConfigSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapNodeConfigSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapProjection as json.
func (o OptIoK8sAPICoreV1ConfigMapProjection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapProjection from json.
func (o *OptIoK8sAPICoreV1ConfigMapProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapProjection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ConfigMapVolumeSource as json.
func (o OptIoK8sAPICoreV1ConfigMapVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ConfigMapVolumeSource from json.
func (o *OptIoK8sAPICoreV1ConfigMapVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ConfigMapVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ConfigMapVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ConfigMapVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ContainerState as json.
func (o OptIoK8sAPICoreV1ContainerState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerState from json.
func (o *OptIoK8sAPICoreV1ContainerState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ContainerState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ContainerState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ContainerStateRunning as json.
func (o OptIoK8sAPICoreV1ContainerStateRunning) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateRunning from json.
func (o *OptIoK8sAPICoreV1ContainerStateRunning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateRunning to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ContainerStateRunning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ContainerStateRunning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ContainerStateTerminated as json.
func (o OptIoK8sAPICoreV1ContainerStateTerminated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateTerminated from json.
func (o *OptIoK8sAPICoreV1ContainerStateTerminated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateTerminated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ContainerStateTerminated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ContainerStateTerminated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ContainerStateWaiting as json.
func (o OptIoK8sAPICoreV1ContainerStateWaiting) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ContainerStateWaiting from json.
func (o *OptIoK8sAPICoreV1ContainerStateWaiting) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ContainerStateWaiting to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ContainerStateWaiting) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ContainerStateWaiting) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1DaemonEndpoint as json.
func (o OptIoK8sAPICoreV1DaemonEndpoint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DaemonEndpoint from json.
func (o *OptIoK8sAPICoreV1DaemonEndpoint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DaemonEndpoint to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1DaemonEndpoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1DaemonEndpoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1DownwardAPIProjection as json.
func (o OptIoK8sAPICoreV1DownwardAPIProjection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIProjection from json.
func (o *OptIoK8sAPICoreV1DownwardAPIProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIProjection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1DownwardAPIProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1DownwardAPIProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1DownwardAPIVolumeSource as json.
func (o OptIoK8sAPICoreV1DownwardAPIVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1DownwardAPIVolumeSource from json.
func (o *OptIoK8sAPICoreV1DownwardAPIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1DownwardAPIVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1DownwardAPIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1DownwardAPIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1EmptyDirVolumeSource as json.
func (o OptIoK8sAPICoreV1EmptyDirVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EmptyDirVolumeSource from json.
func (o *OptIoK8sAPICoreV1EmptyDirVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EmptyDirVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1EmptyDirVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1EmptyDirVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1EnvVarSource as json.
func (o OptIoK8sAPICoreV1EnvVarSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EnvVarSource from json.
func (o *OptIoK8sAPICoreV1EnvVarSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EnvVarSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1EnvVarSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1EnvVarSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1EphemeralVolumeSource as json.
func (o OptIoK8sAPICoreV1EphemeralVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EphemeralVolumeSource from json.
func (o *OptIoK8sAPICoreV1EphemeralVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EphemeralVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1EphemeralVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1EphemeralVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1EventSeries as json.
func (o OptIoK8sAPICoreV1EventSeries) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSeries from json.
func (o *OptIoK8sAPICoreV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EventSeries to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1EventSource as json.
func (o OptIoK8sAPICoreV1EventSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1EventSource from json.
func (o *OptIoK8sAPICoreV1EventSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1EventSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1EventSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1EventSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ExecAction as json.
func (o OptIoK8sAPICoreV1ExecAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ExecAction from json.
func (o *OptIoK8sAPICoreV1ExecAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ExecAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ExecAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ExecAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FCVolumeSource as json.
func (o OptIoK8sAPICoreV1FCVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FCVolumeSource from json.
func (o *OptIoK8sAPICoreV1FCVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FCVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FCVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FCVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FlexPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FlexPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexPersistentVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1FlexPersistentVolumeSourceOptions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FlexPersistentVolumeSourceOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSource as json.
func (o OptIoK8sAPICoreV1FlexVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FlexVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FlexVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FlexVolumeSourceOptions as json.
func (o OptIoK8sAPICoreV1FlexVolumeSourceOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlexVolumeSourceOptions from json.
func (o *OptIoK8sAPICoreV1FlexVolumeSourceOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlexVolumeSourceOptions to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1FlexVolumeSourceOptions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FlexVolumeSourceOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FlexVolumeSourceOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1FlockerVolumeSource as json.
func (o OptIoK8sAPICoreV1FlockerVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1FlockerVolumeSource from json.
func (o *OptIoK8sAPICoreV1FlockerVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1FlockerVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1FlockerVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1FlockerVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GCEPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1GCEPersistentDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1GitRepoVolumeSource as json.
func (o OptIoK8sAPICoreV1GitRepoVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GitRepoVolumeSource from json.
func (o *OptIoK8sAPICoreV1GitRepoVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GitRepoVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1GitRepoVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1GitRepoVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1GlusterfsPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1GlusterfsVolumeSource as json.
func (o OptIoK8sAPICoreV1GlusterfsVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1GlusterfsVolumeSource from json.
func (o *OptIoK8sAPICoreV1GlusterfsVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1GlusterfsVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1GlusterfsVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1GlusterfsVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1HTTPGetAction as json.
func (o OptIoK8sAPICoreV1HTTPGetAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HTTPGetAction from json.
func (o *OptIoK8sAPICoreV1HTTPGetAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1HTTPGetAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1HTTPGetAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1HTTPGetAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1Handler as json.
func (o OptIoK8sAPICoreV1Handler) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Handler from json.
func (o *OptIoK8sAPICoreV1Handler) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Handler to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1Handler) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1Handler) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1HostPathVolumeSource as json.
func (o OptIoK8sAPICoreV1HostPathVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1HostPathVolumeSource from json.
func (o *OptIoK8sAPICoreV1HostPathVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1HostPathVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1HostPathVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1HostPathVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ISCSIPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ISCSIPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ISCSIPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ISCSIVolumeSource as json.
func (o OptIoK8sAPICoreV1ISCSIVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ISCSIVolumeSource from json.
func (o *OptIoK8sAPICoreV1ISCSIVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ISCSIVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ISCSIVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ISCSIVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1Lifecycle as json.
func (o OptIoK8sAPICoreV1Lifecycle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Lifecycle from json.
func (o *OptIoK8sAPICoreV1Lifecycle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Lifecycle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1Lifecycle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1Lifecycle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefault as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefault) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefault from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefault) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefault to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1LimitRangeItemDefault)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeItemDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeItemDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemDefaultRequest as json.
func (o OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemDefaultRequest from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemDefaultRequest to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1LimitRangeItemDefaultRequest)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeItemDefaultRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMax as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMax) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMax from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMax) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMax to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1LimitRangeItemMax)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeItemMax) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeItemMax) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeItemMaxLimitRequestRatio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeItemMin as json.
func (o OptIoK8sAPICoreV1LimitRangeItemMin) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeItemMin from json.
func (o *OptIoK8sAPICoreV1LimitRangeItemMin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeItemMin to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1LimitRangeItemMin)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeItemMin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeItemMin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LimitRangeSpec as json.
func (o OptIoK8sAPICoreV1LimitRangeSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LimitRangeSpec from json.
func (o *OptIoK8sAPICoreV1LimitRangeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LimitRangeSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LimitRangeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LimitRangeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LoadBalancerStatus as json.
func (o OptIoK8sAPICoreV1LoadBalancerStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LoadBalancerStatus from json.
func (o *OptIoK8sAPICoreV1LoadBalancerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LoadBalancerStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LoadBalancerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LoadBalancerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LocalObjectReference as json.
func (o OptIoK8sAPICoreV1LocalObjectReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalObjectReference from json.
func (o *OptIoK8sAPICoreV1LocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LocalObjectReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LocalObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LocalObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1LocalVolumeSource as json.
func (o OptIoK8sAPICoreV1LocalVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1LocalVolumeSource from json.
func (o *OptIoK8sAPICoreV1LocalVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1LocalVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1LocalVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1LocalVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NFSVolumeSource as json.
func (o OptIoK8sAPICoreV1NFSVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NFSVolumeSource from json.
func (o *OptIoK8sAPICoreV1NFSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NFSVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NFSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NFSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NamespaceSpec as json.
func (o OptIoK8sAPICoreV1NamespaceSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceSpec from json.
func (o *OptIoK8sAPICoreV1NamespaceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NamespaceSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NamespaceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NamespaceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NamespaceStatus as json.
func (o OptIoK8sAPICoreV1NamespaceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NamespaceStatus from json.
func (o *OptIoK8sAPICoreV1NamespaceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NamespaceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NamespaceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NamespaceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeAffinity as json.
func (o OptIoK8sAPICoreV1NodeAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeAffinity from json.
func (o *OptIoK8sAPICoreV1NodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeConfigSource as json.
func (o OptIoK8sAPICoreV1NodeConfigSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigSource from json.
func (o *OptIoK8sAPICoreV1NodeConfigSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeConfigSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeConfigSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeConfigSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeConfigStatus as json.
func (o OptIoK8sAPICoreV1NodeConfigStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeConfigStatus from json.
func (o *OptIoK8sAPICoreV1NodeConfigStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeConfigStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeConfigStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeConfigStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeDaemonEndpoints as json.
func (o OptIoK8sAPICoreV1NodeDaemonEndpoints) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeDaemonEndpoints from json.
func (o *OptIoK8sAPICoreV1NodeDaemonEndpoints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeDaemonEndpoints to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeDaemonEndpoints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeDaemonEndpoints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeSelector as json.
func (o OptIoK8sAPICoreV1NodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSelector from json.
func (o *OptIoK8sAPICoreV1NodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeSpec as json.
func (o OptIoK8sAPICoreV1NodeSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSpec from json.
func (o *OptIoK8sAPICoreV1NodeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeStatus as json.
func (o OptIoK8sAPICoreV1NodeStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatus from json.
func (o *OptIoK8sAPICoreV1NodeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeStatusAllocatable as json.
func (o OptIoK8sAPICoreV1NodeStatusAllocatable) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusAllocatable from json.
func (o *OptIoK8sAPICoreV1NodeStatusAllocatable) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatusAllocatable to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1NodeStatusAllocatable)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeStatusAllocatable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeStatusAllocatable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeStatusCapacity as json.
func (o OptIoK8sAPICoreV1NodeStatusCapacity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeStatusCapacity from json.
func (o *OptIoK8sAPICoreV1NodeStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeStatusCapacity to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1NodeStatusCapacity)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeStatusCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeStatusCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1NodeSystemInfo as json.
func (o OptIoK8sAPICoreV1NodeSystemInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1NodeSystemInfo from json.
func (o *OptIoK8sAPICoreV1NodeSystemInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1NodeSystemInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1NodeSystemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1NodeSystemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ObjectFieldSelector as json.
func (o OptIoK8sAPICoreV1ObjectFieldSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectFieldSelector from json.
func (o *OptIoK8sAPICoreV1ObjectFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ObjectFieldSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ObjectFieldSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ObjectFieldSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ObjectReference as json.
func (o OptIoK8sAPICoreV1ObjectReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ObjectReference from json.
func (o *OptIoK8sAPICoreV1ObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ObjectReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeClaimSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeClaimSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeClaimStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeClaimStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1PersistentVolumeClaimStatusCapacity)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeClaimStatusCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimTemplate as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimTemplate from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeClaimTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource as json.
func (o OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeClaimVolumeSource from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeClaimVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpec as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpec from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeSpecCapacity as json.
func (o OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeSpecCapacity from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeSpecCapacity to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1PersistentVolumeSpecCapacity)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeSpecCapacity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PersistentVolumeStatus as json.
func (o OptIoK8sAPICoreV1PersistentVolumeStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PersistentVolumeStatus from json.
func (o *OptIoK8sAPICoreV1PersistentVolumeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PersistentVolumeStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PersistentVolumeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PersistentVolumeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PhotonPersistentDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PhotonPersistentDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodAffinity as json.
func (o OptIoK8sAPICoreV1PodAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAffinity from json.
func (o *OptIoK8sAPICoreV1PodAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodAntiAffinity as json.
func (o OptIoK8sAPICoreV1PodAntiAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodAntiAffinity from json.
func (o *OptIoK8sAPICoreV1PodAntiAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodAntiAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodAntiAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodAntiAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodDNSConfig as json.
func (o OptIoK8sAPICoreV1PodDNSConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodDNSConfig from json.
func (o *OptIoK8sAPICoreV1PodDNSConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodDNSConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodDNSConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodDNSConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodSecurityContext as json.
func (o OptIoK8sAPICoreV1PodSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSecurityContext from json.
func (o *OptIoK8sAPICoreV1PodSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodSpec as json.
func (o OptIoK8sAPICoreV1PodSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpec from json.
func (o *OptIoK8sAPICoreV1PodSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodSpecNodeSelector as json.
func (o OptIoK8sAPICoreV1PodSpecNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecNodeSelector from json.
func (o *OptIoK8sAPICoreV1PodSpecNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpecNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1PodSpecNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodSpecNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodSpecNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodSpecOverhead as json.
func (o OptIoK8sAPICoreV1PodSpecOverhead) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodSpecOverhead from json.
func (o *OptIoK8sAPICoreV1PodSpecOverhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodSpecOverhead to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1PodSpecOverhead)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodSpecOverhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodSpecOverhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodStatus as json.
func (o OptIoK8sAPICoreV1PodStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodStatus from json.
func (o *OptIoK8sAPICoreV1PodStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PodTemplateSpec as json.
func (o OptIoK8sAPICoreV1PodTemplateSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PodTemplateSpec from json.
func (o *OptIoK8sAPICoreV1PodTemplateSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PodTemplateSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PodTemplateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PodTemplateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1PortworxVolumeSource as json.
func (o OptIoK8sAPICoreV1PortworxVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1PortworxVolumeSource from json.
func (o *OptIoK8sAPICoreV1PortworxVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1PortworxVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1PortworxVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1PortworxVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1Probe as json.
func (o OptIoK8sAPICoreV1Probe) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1Probe from json.
func (o *OptIoK8sAPICoreV1Probe) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1Probe to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1Probe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1Probe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ProjectedVolumeSource as json.
func (o OptIoK8sAPICoreV1ProjectedVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ProjectedVolumeSource from json.
func (o *OptIoK8sAPICoreV1ProjectedVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ProjectedVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ProjectedVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ProjectedVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1QuobyteVolumeSource as json.
func (o OptIoK8sAPICoreV1QuobyteVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1QuobyteVolumeSource from json.
func (o *OptIoK8sAPICoreV1QuobyteVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1QuobyteVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1QuobyteVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1QuobyteVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1RBDPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1RBDPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1RBDPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1RBDPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1RBDVolumeSource as json.
func (o OptIoK8sAPICoreV1RBDVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1RBDVolumeSource from json.
func (o *OptIoK8sAPICoreV1RBDVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1RBDVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1RBDVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1RBDVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpec as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpec from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ReplicationControllerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ReplicationControllerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerSpecSelector as json.
func (o OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerSpecSelector from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerSpecSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ReplicationControllerSpecSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ReplicationControllerSpecSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ReplicationControllerSpecSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ReplicationControllerStatus as json.
func (o OptIoK8sAPICoreV1ReplicationControllerStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ReplicationControllerStatus from json.
func (o *OptIoK8sAPICoreV1ReplicationControllerStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ReplicationControllerStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ReplicationControllerStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ReplicationControllerStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceFieldSelector as json.
func (o OptIoK8sAPICoreV1ResourceFieldSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceFieldSelector from json.
func (o *OptIoK8sAPICoreV1ResourceFieldSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceFieldSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceFieldSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceFieldSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpec as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpec from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceQuotaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceQuotaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaSpecHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaSpecHard) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaSpecHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaSpecHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaSpecHard to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ResourceQuotaSpecHard)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceQuotaSpecHard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceQuotaSpecHard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatus as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatus from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceQuotaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceQuotaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusHard as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusHard) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusHard from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusHard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusHard to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ResourceQuotaStatusHard)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceQuotaStatusHard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceQuotaStatusHard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceQuotaStatusUsed as json.
func (o OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceQuotaStatusUsed from json.
func (o *OptIoK8sAPICoreV1ResourceQuotaStatusUsed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceQuotaStatusUsed to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ResourceQuotaStatusUsed)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceQuotaStatusUsed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceQuotaStatusUsed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceRequirements as json.
func (o OptIoK8sAPICoreV1ResourceRequirements) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirements from json.
func (o *OptIoK8sAPICoreV1ResourceRequirements) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirements to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceRequirements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceRequirements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsLimits as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsLimits) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsLimits from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsLimits) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsLimits to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ResourceRequirementsLimits)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceRequirementsLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceRequirementsLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ResourceRequirementsRequests as json.
func (o OptIoK8sAPICoreV1ResourceRequirementsRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ResourceRequirementsRequests from json.
func (o *OptIoK8sAPICoreV1ResourceRequirementsRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ResourceRequirementsRequests to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ResourceRequirementsRequests)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ResourceRequirementsRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ResourceRequirementsRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SELinuxOptions as json.
func (o OptIoK8sAPICoreV1SELinuxOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SELinuxOptions from json.
func (o *OptIoK8sAPICoreV1SELinuxOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SELinuxOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SELinuxOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SELinuxOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ScaleIOPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ScaleIOVolumeSource as json.
func (o OptIoK8sAPICoreV1ScaleIOVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScaleIOVolumeSource from json.
func (o *OptIoK8sAPICoreV1ScaleIOVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScaleIOVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ScaleIOVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ScaleIOVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ScopeSelector as json.
func (o OptIoK8sAPICoreV1ScopeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ScopeSelector from json.
func (o *OptIoK8sAPICoreV1ScopeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ScopeSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ScopeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ScopeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SeccompProfile as json.
func (o OptIoK8sAPICoreV1SeccompProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SeccompProfile from json.
func (o *OptIoK8sAPICoreV1SeccompProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SeccompProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SeccompProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SeccompProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretData as json.
func (o OptIoK8sAPICoreV1SecretData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretData from json.
func (o *OptIoK8sAPICoreV1SecretData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretData to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1SecretData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretEnvSource as json.
func (o OptIoK8sAPICoreV1SecretEnvSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretEnvSource from json.
func (o *OptIoK8sAPICoreV1SecretEnvSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretEnvSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretEnvSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretEnvSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretKeySelector as json.
func (o OptIoK8sAPICoreV1SecretKeySelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretKeySelector from json.
func (o *OptIoK8sAPICoreV1SecretKeySelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretKeySelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretKeySelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretKeySelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretProjection as json.
func (o OptIoK8sAPICoreV1SecretProjection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretProjection from json.
func (o *OptIoK8sAPICoreV1SecretProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretProjection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretReference as json.
func (o OptIoK8sAPICoreV1SecretReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretReference from json.
func (o *OptIoK8sAPICoreV1SecretReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretStringData as json.
func (o OptIoK8sAPICoreV1SecretStringData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretStringData from json.
func (o *OptIoK8sAPICoreV1SecretStringData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretStringData to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1SecretStringData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretStringData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretStringData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecretVolumeSource as json.
func (o OptIoK8sAPICoreV1SecretVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecretVolumeSource from json.
func (o *OptIoK8sAPICoreV1SecretVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecretVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecretVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecretVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SecurityContext as json.
func (o OptIoK8sAPICoreV1SecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SecurityContext from json.
func (o *OptIoK8sAPICoreV1SecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ServiceAccountTokenProjection as json.
func (o OptIoK8sAPICoreV1ServiceAccountTokenProjection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceAccountTokenProjection from json.
func (o *OptIoK8sAPICoreV1ServiceAccountTokenProjection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceAccountTokenProjection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ServiceAccountTokenProjection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ServiceAccountTokenProjection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ServiceSpec as json.
func (o OptIoK8sAPICoreV1ServiceSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpec from json.
func (o *OptIoK8sAPICoreV1ServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ServiceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ServiceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ServiceSpecSelector as json.
func (o OptIoK8sAPICoreV1ServiceSpecSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceSpecSelector from json.
func (o *OptIoK8sAPICoreV1ServiceSpecSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceSpecSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPICoreV1ServiceSpecSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ServiceSpecSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ServiceSpecSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1ServiceStatus as json.
func (o OptIoK8sAPICoreV1ServiceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1ServiceStatus from json.
func (o *OptIoK8sAPICoreV1ServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1ServiceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1ServiceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1ServiceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1SessionAffinityConfig as json.
func (o OptIoK8sAPICoreV1SessionAffinityConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1SessionAffinityConfig from json.
func (o *OptIoK8sAPICoreV1SessionAffinityConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1SessionAffinityConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1SessionAffinityConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1SessionAffinityConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1StorageOSPersistentVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSPersistentVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1StorageOSPersistentVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1StorageOSPersistentVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1StorageOSVolumeSource as json.
func (o OptIoK8sAPICoreV1StorageOSVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1StorageOSVolumeSource from json.
func (o *OptIoK8sAPICoreV1StorageOSVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1StorageOSVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1StorageOSVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1StorageOSVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1TCPSocketAction as json.
func (o OptIoK8sAPICoreV1TCPSocketAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TCPSocketAction from json.
func (o *OptIoK8sAPICoreV1TCPSocketAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1TCPSocketAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1TCPSocketAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1TCPSocketAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1TypedLocalObjectReference as json.
func (o OptIoK8sAPICoreV1TypedLocalObjectReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1TypedLocalObjectReference from json.
func (o *OptIoK8sAPICoreV1TypedLocalObjectReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1TypedLocalObjectReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1TypedLocalObjectReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1TypedLocalObjectReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1VolumeNodeAffinity as json.
func (o OptIoK8sAPICoreV1VolumeNodeAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VolumeNodeAffinity from json.
func (o *OptIoK8sAPICoreV1VolumeNodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1VolumeNodeAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1VolumeNodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1VolumeNodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource as json.
func (o OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1VsphereVirtualDiskVolumeSource from json.
func (o *OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1VsphereVirtualDiskVolumeSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPICoreV1WindowsSecurityContextOptions as json.
func (o OptIoK8sAPICoreV1WindowsSecurityContextOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPICoreV1WindowsSecurityContextOptions from json.
func (o *OptIoK8sAPICoreV1WindowsSecurityContextOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPICoreV1WindowsSecurityContextOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPICoreV1WindowsSecurityContextOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPICoreV1WindowsSecurityContextOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1EndpointConditions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointConditions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1EndpointConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1EndpointConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology as json.
func (o OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointDeprecatedTopology from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIDiscoveryV1EndpointDeprecatedTopology)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1EndpointDeprecatedTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1EndpointHints) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1EndpointHints to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1EndpointHints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1EndpointHints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointConditions as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointConditions from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointConditions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointConditions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1beta1EndpointConditions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1beta1EndpointConditions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointHints as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointHints) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointHints from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointHints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointHints to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1beta1EndpointHints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1beta1EndpointHints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIDiscoveryV1beta1EndpointTopology as json.
func (o OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIDiscoveryV1beta1EndpointTopology from json.
func (o *OptIoK8sAPIDiscoveryV1beta1EndpointTopology) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIDiscoveryV1beta1EndpointTopology to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIDiscoveryV1beta1EndpointTopology)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIDiscoveryV1beta1EndpointTopology) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIDiscoveryV1beta1EndpointTopology) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIEventsV1EventSeries as json.
func (o OptIoK8sAPIEventsV1EventSeries) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1EventSeries from json.
func (o *OptIoK8sAPIEventsV1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIEventsV1EventSeries to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIEventsV1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIEventsV1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIEventsV1beta1EventSeries as json.
func (o OptIoK8sAPIEventsV1beta1EventSeries) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIEventsV1beta1EventSeries from json.
func (o *OptIoK8sAPIEventsV1beta1EventSeries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIEventsV1beta1EventSeries to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIEventsV1beta1EventSeries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIEventsV1beta1EventSeries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1FlowDistinguisherMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1FlowSchemaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1GroupSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1GroupSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1GroupSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1LimitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1LimitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1LimitedPriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1PriorityLevelConfigurationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1QueuingConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1ServiceAccountSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta1UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta1UserSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta1UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta1UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta1UserSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta1UserSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta1UserSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2FlowDistinguisherMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2FlowSchemaStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2FlowSchemaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2GroupSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2GroupSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2GroupSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2GroupSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2GroupSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2GroupSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitResponse as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitResponse from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2LimitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2LimitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2LimitedPriorityLevelConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus as json.
func (o OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2PriorityLevelConfigurationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration as json.
func (o OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2QueuingConfiguration from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2QueuingConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2ServiceAccountSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2ServiceAccountSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIFlowcontrolV1beta2UserSubject as json.
func (o OptIoK8sAPIFlowcontrolV1beta2UserSubject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIFlowcontrolV1beta2UserSubject from json.
func (o *OptIoK8sAPIFlowcontrolV1beta2UserSubject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIFlowcontrolV1beta2UserSubject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIFlowcontrolV1beta2UserSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIFlowcontrolV1beta2UserSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1HTTPIngressRuleValue as json.
func (o OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1HTTPIngressRuleValue from json.
func (o *OptIoK8sAPINetworkingV1HTTPIngressRuleValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1HTTPIngressRuleValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1HTTPIngressRuleValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1HTTPIngressRuleValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IPBlock as json.
func (o OptIoK8sAPINetworkingV1IPBlock) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IPBlock from json.
func (o *OptIoK8sAPINetworkingV1IPBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IPBlock to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IPBlock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IPBlock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressBackend as json.
func (o OptIoK8sAPINetworkingV1IngressBackend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressBackend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressClassParametersReference as json.
func (o OptIoK8sAPINetworkingV1IngressClassParametersReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassParametersReference from json.
func (o *OptIoK8sAPINetworkingV1IngressClassParametersReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassParametersReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressClassParametersReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressClassParametersReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressClassSpec as json.
func (o OptIoK8sAPINetworkingV1IngressClassSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressClassSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressClassSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressClassSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressClassSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressClassSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressServiceBackend as json.
func (o OptIoK8sAPINetworkingV1IngressServiceBackend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressServiceBackend from json.
func (o *OptIoK8sAPINetworkingV1IngressServiceBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressServiceBackend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressServiceBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressServiceBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressSpec as json.
func (o OptIoK8sAPINetworkingV1IngressSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressSpec from json.
func (o *OptIoK8sAPINetworkingV1IngressSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1IngressStatus as json.
func (o OptIoK8sAPINetworkingV1IngressStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1IngressStatus from json.
func (o *OptIoK8sAPINetworkingV1IngressStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1IngressStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1IngressStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1IngressStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1NetworkPolicySpec as json.
func (o OptIoK8sAPINetworkingV1NetworkPolicySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1NetworkPolicySpec from json.
func (o *OptIoK8sAPINetworkingV1NetworkPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1NetworkPolicySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1NetworkPolicySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1NetworkPolicySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINetworkingV1ServiceBackendPort as json.
func (o OptIoK8sAPINetworkingV1ServiceBackendPort) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINetworkingV1ServiceBackendPort from json.
func (o *OptIoK8sAPINetworkingV1ServiceBackendPort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINetworkingV1ServiceBackendPort to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINetworkingV1ServiceBackendPort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINetworkingV1ServiceBackendPort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1Overhead as json.
func (o OptIoK8sAPINodeV1Overhead) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Overhead from json.
func (o *OptIoK8sAPINodeV1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1Overhead to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1OverheadPodFixed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1OverheadPodFixed to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1OverheadPodFixed)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1Scheduling as json.
func (o OptIoK8sAPINodeV1Scheduling) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1Scheduling from json.
func (o *OptIoK8sAPINodeV1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1Scheduling to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1SchedulingNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1SchedulingNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1alpha1Overhead as json.
func (o OptIoK8sAPINodeV1alpha1Overhead) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Overhead from json.
func (o *OptIoK8sAPINodeV1alpha1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1Overhead to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1alpha1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1alpha1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1alpha1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1alpha1OverheadPodFixed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1alpha1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1OverheadPodFixed to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1alpha1OverheadPodFixed)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1alpha1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1alpha1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1alpha1Scheduling as json.
func (o OptIoK8sAPINodeV1alpha1Scheduling) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1Scheduling from json.
func (o *OptIoK8sAPINodeV1alpha1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1Scheduling to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1alpha1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1alpha1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1alpha1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1alpha1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1alpha1SchedulingNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1alpha1SchedulingNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1alpha1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1beta1Overhead as json.
func (o OptIoK8sAPINodeV1beta1Overhead) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Overhead from json.
func (o *OptIoK8sAPINodeV1beta1Overhead) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1Overhead to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1beta1Overhead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1beta1Overhead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1beta1OverheadPodFixed as json.
func (o OptIoK8sAPINodeV1beta1OverheadPodFixed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1OverheadPodFixed from json.
func (o *OptIoK8sAPINodeV1beta1OverheadPodFixed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1OverheadPodFixed to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1beta1OverheadPodFixed)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1beta1OverheadPodFixed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1beta1OverheadPodFixed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1beta1Scheduling as json.
func (o OptIoK8sAPINodeV1beta1Scheduling) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1Scheduling from json.
func (o *OptIoK8sAPINodeV1beta1Scheduling) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1Scheduling to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1beta1Scheduling) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1beta1Scheduling) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPINodeV1beta1SchedulingNodeSelector as json.
func (o OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPINodeV1beta1SchedulingNodeSelector from json.
func (o *OptIoK8sAPINodeV1beta1SchedulingNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPINodeV1beta1SchedulingNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPINodeV1beta1SchedulingNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPINodeV1beta1SchedulingNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPINodeV1beta1SchedulingNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1PodDisruptionBudgetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1PodDisruptionBudgetStatusDisruptedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods as json.
func (o OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods from json.
func (o *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1PodDisruptionBudgetStatusDisruptedPods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec as json.
func (o OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1PodSecurityPolicySpec from json.
func (o *OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1PodSecurityPolicySpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1RunAsGroupStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions as json.
func (o OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions from json.
func (o *OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIPolicyV1beta1RuntimeClassStrategyOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIRbacV1AggregationRule as json.
func (o OptIoK8sAPIRbacV1AggregationRule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIRbacV1AggregationRule from json.
func (o *OptIoK8sAPIRbacV1AggregationRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIRbacV1AggregationRule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIRbacV1AggregationRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIRbacV1AggregationRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIStorageV1StorageClassParameters as json.
func (o OptIoK8sAPIStorageV1StorageClassParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1StorageClassParameters from json.
func (o *OptIoK8sAPIStorageV1StorageClassParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1StorageClassParameters to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIStorageV1StorageClassParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIStorageV1StorageClassParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIStorageV1StorageClassParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatus as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatus from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIStorageV1VolumeAttachmentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIStorageV1VolumeAttachmentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata as json.
func (o OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata from json.
func (o *OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata to nil")
	}
	o.Set = true
	o.Value = make(IoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIStorageV1VolumeAttachmentStatusAttachmentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIStorageV1VolumeError as json.
func (o OptIoK8sAPIStorageV1VolumeError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeError from json.
func (o *OptIoK8sAPIStorageV1VolumeError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIStorageV1VolumeError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIStorageV1VolumeError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sAPIStorageV1VolumeNodeResources as json.
func (o OptIoK8sAPIStorageV1VolumeNodeResources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sAPIStorageV1VolumeNodeResources from json.
func (o *OptIoK8sAPIStorageV1VolumeNodeResources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sAPIStorageV1VolumeNodeResources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sAPIStorageV1VolumeNodeResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sAPIStorageV1VolumeNodeResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceConversion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionNames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresourceScale) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceSubresources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceValidation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ExternalDocumentation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaProps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDefinitions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsDependencies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsPatternProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1JSONSchemaPropsProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion as json.
func (o OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion from json.
func (o *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookConversion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgAPIResourceQuantity as json.
func (o OptIoK8sApimachineryPkgAPIResourceQuantity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgAPIResourceQuantity from json.
func (o *OptIoK8sApimachineryPkgAPIResourceQuantity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgAPIResourceQuantity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgAPIResourceQuantity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgAPIResourceQuantity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery as json.
func (o OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1GroupVersionForDiscovery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelector as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelector from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1LabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1LabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1LabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ListMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ListMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ListMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ListMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ListMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1ListMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1ListMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1MicroTime as json.
func (o OptIoK8sApimachineryPkgApisMetaV1MicroTime) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1MicroTime from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1MicroTime) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1MicroTime to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1MicroTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1MicroTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMeta as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMeta from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1ObjectMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels as json.
func (o OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels to nil")
	}
	o.Set = true
	o.Value = make(IoK8sApimachineryPkgApisMetaV1ObjectMetaLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1ObjectMetaLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgApisMetaV1Time as json.
func (o OptIoK8sApimachineryPkgApisMetaV1Time) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgApisMetaV1Time from json.
func (o *OptIoK8sApimachineryPkgApisMetaV1Time) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgApisMetaV1Time to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgApisMetaV1Time) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgApisMetaV1Time) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sApimachineryPkgUtilIntstrIntOrString as json.
func (o OptIoK8sApimachineryPkgUtilIntstrIntOrString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sApimachineryPkgUtilIntstrIntOrString from json.
func (o *OptIoK8sApimachineryPkgUtilIntstrIntOrString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sApimachineryPkgUtilIntstrIntOrString to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sApimachineryPkgUtilIntstrIntOrString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sApimachineryPkgUtilIntstrIntOrString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sKubeAggregatorPkgApisApiregistrationV1APIServiceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference as json.
func (o OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference from json.
func (o *OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadCoreV1NamespacedPodLogOKApplicationJSON as json.
func (s ReadCoreV1NamespacedPodLogOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ReadCoreV1NamespacedPodLogOKApplicationJSON from json.
func (s *ReadCoreV1NamespacedPodLogOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadCoreV1NamespacedPodLogOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadCoreV1NamespacedPodLogOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadCoreV1NamespacedPodLogOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadCoreV1NamespacedPodLogOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
