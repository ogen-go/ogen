// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Balloon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Balloon) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("amount_mib")
		e.Int(s.AmountMib)
	}
	{
		e.FieldStart("deflate_on_oom")
		e.Bool(s.DeflateOnOom)
	}
	{
		if s.StatsPollingIntervalS.Set {
			e.FieldStart("stats_polling_interval_s")
			s.StatsPollingIntervalS.Encode(e)
		}
	}
}

var jsonFieldsNameOfBalloon = [3]string{
	0: "amount_mib",
	1: "deflate_on_oom",
	2: "stats_polling_interval_s",
}

// Decode decodes Balloon from json.
func (s *Balloon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Balloon to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount_mib":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AmountMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_mib\"")
			}
		case "deflate_on_oom":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.DeflateOnOom = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deflate_on_oom\"")
			}
		case "stats_polling_interval_s":
			if err := func() error {
				s.StatsPollingIntervalS.Reset()
				if err := s.StatsPollingIntervalS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats_polling_interval_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Balloon")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloon) {
					name = jsonFieldsNameOfBalloon[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Balloon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Balloon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalloonStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalloonStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_pages")
		e.Int(s.TargetPages)
	}
	{
		e.FieldStart("actual_pages")
		e.Int(s.ActualPages)
	}
	{
		e.FieldStart("target_mib")
		e.Int(s.TargetMib)
	}
	{
		e.FieldStart("actual_mib")
		e.Int(s.ActualMib)
	}
	{
		if s.SwapIn.Set {
			e.FieldStart("swap_in")
			s.SwapIn.Encode(e)
		}
	}
	{
		if s.SwapOut.Set {
			e.FieldStart("swap_out")
			s.SwapOut.Encode(e)
		}
	}
	{
		if s.MajorFaults.Set {
			e.FieldStart("major_faults")
			s.MajorFaults.Encode(e)
		}
	}
	{
		if s.MinorFaults.Set {
			e.FieldStart("minor_faults")
			s.MinorFaults.Encode(e)
		}
	}
	{
		if s.FreeMemory.Set {
			e.FieldStart("free_memory")
			s.FreeMemory.Encode(e)
		}
	}
	{
		if s.TotalMemory.Set {
			e.FieldStart("total_memory")
			s.TotalMemory.Encode(e)
		}
	}
	{
		if s.AvailableMemory.Set {
			e.FieldStart("available_memory")
			s.AvailableMemory.Encode(e)
		}
	}
	{
		if s.DiskCaches.Set {
			e.FieldStart("disk_caches")
			s.DiskCaches.Encode(e)
		}
	}
	{
		if s.HugetlbAllocations.Set {
			e.FieldStart("hugetlb_allocations")
			s.HugetlbAllocations.Encode(e)
		}
	}
	{
		if s.HugetlbFailures.Set {
			e.FieldStart("hugetlb_failures")
			s.HugetlbFailures.Encode(e)
		}
	}
}

var jsonFieldsNameOfBalloonStats = [14]string{
	0:  "target_pages",
	1:  "actual_pages",
	2:  "target_mib",
	3:  "actual_mib",
	4:  "swap_in",
	5:  "swap_out",
	6:  "major_faults",
	7:  "minor_faults",
	8:  "free_memory",
	9:  "total_memory",
	10: "available_memory",
	11: "disk_caches",
	12: "hugetlb_allocations",
	13: "hugetlb_failures",
}

// Decode decodes BalloonStats from json.
func (s *BalloonStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonStats to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_pages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TargetPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_pages\"")
			}
		case "actual_pages":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ActualPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actual_pages\"")
			}
		case "target_mib":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TargetMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_mib\"")
			}
		case "actual_mib":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ActualMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actual_mib\"")
			}
		case "swap_in":
			if err := func() error {
				s.SwapIn.Reset()
				if err := s.SwapIn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swap_in\"")
			}
		case "swap_out":
			if err := func() error {
				s.SwapOut.Reset()
				if err := s.SwapOut.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swap_out\"")
			}
		case "major_faults":
			if err := func() error {
				s.MajorFaults.Reset()
				if err := s.MajorFaults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major_faults\"")
			}
		case "minor_faults":
			if err := func() error {
				s.MinorFaults.Reset()
				if err := s.MinorFaults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minor_faults\"")
			}
		case "free_memory":
			if err := func() error {
				s.FreeMemory.Reset()
				if err := s.FreeMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_memory\"")
			}
		case "total_memory":
			if err := func() error {
				s.TotalMemory.Reset()
				if err := s.TotalMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_memory\"")
			}
		case "available_memory":
			if err := func() error {
				s.AvailableMemory.Reset()
				if err := s.AvailableMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_memory\"")
			}
		case "disk_caches":
			if err := func() error {
				s.DiskCaches.Reset()
				if err := s.DiskCaches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_caches\"")
			}
		case "hugetlb_allocations":
			if err := func() error {
				s.HugetlbAllocations.Reset()
				if err := s.HugetlbAllocations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hugetlb_allocations\"")
			}
		case "hugetlb_failures":
			if err := func() error {
				s.HugetlbFailures.Reset()
				if err := s.HugetlbFailures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hugetlb_failures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonStats) {
					name = jsonFieldsNameOfBalloonStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalloonStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalloonStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalloonStatsUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalloonStatsUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stats_polling_interval_s")
		e.Int(s.StatsPollingIntervalS)
	}
}

var jsonFieldsNameOfBalloonStatsUpdate = [1]string{
	0: "stats_polling_interval_s",
}

// Decode decodes BalloonStatsUpdate from json.
func (s *BalloonStatsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonStatsUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stats_polling_interval_s":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.StatsPollingIntervalS = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats_polling_interval_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonStatsUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonStatsUpdate) {
					name = jsonFieldsNameOfBalloonStatsUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalloonStatsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalloonStatsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BalloonUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BalloonUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("amount_mib")
		e.Int(s.AmountMib)
	}
}

var jsonFieldsNameOfBalloonUpdate = [1]string{
	0: "amount_mib",
}

// Decode decodes BalloonUpdate from json.
func (s *BalloonUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount_mib":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AmountMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_mib\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonUpdate) {
					name = jsonFieldsNameOfBalloonUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BalloonUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BalloonUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BootSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BootSource) encodeFields(e *jx.Encoder) {
	{
		if s.BootArgs.Set {
			e.FieldStart("boot_args")
			s.BootArgs.Encode(e)
		}
	}
	{
		if s.InitrdPath.Set {
			e.FieldStart("initrd_path")
			s.InitrdPath.Encode(e)
		}
	}
	{
		e.FieldStart("kernel_image_path")
		e.Str(s.KernelImagePath)
	}
}

var jsonFieldsNameOfBootSource = [3]string{
	0: "boot_args",
	1: "initrd_path",
	2: "kernel_image_path",
}

// Decode decodes BootSource from json.
func (s *BootSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BootSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boot_args":
			if err := func() error {
				s.BootArgs.Reset()
				if err := s.BootArgs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot_args\"")
			}
		case "initrd_path":
			if err := func() error {
				s.InitrdPath.Reset()
				if err := s.InitrdPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initrd_path\"")
			}
		case "kernel_image_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KernelImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kernel_image_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BootSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBootSource) {
					name = jsonFieldsNameOfBootSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BootSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BootSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CpuTemplate as json.
func (s CpuTemplate) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CpuTemplate from json.
func (s *CpuTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CpuTemplate to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CpuTemplate(v) {
	case CpuTemplateC3:
		*s = CpuTemplateC3
	case CpuTemplateT2:
		*s = CpuTemplateT2
	default:
		*s = CpuTemplate(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CpuTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CpuTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Drive) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Drive) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("drive_id")
		e.Str(s.DriveID)
	}
	{
		if s.CacheType.Set {
			e.FieldStart("cache_type")
			s.CacheType.Encode(e)
		}
	}
	{
		e.FieldStart("is_read_only")
		e.Bool(s.IsReadOnly)
	}
	{
		e.FieldStart("is_root_device")
		e.Bool(s.IsRootDevice)
	}
	{
		if s.Partuuid.Set {
			e.FieldStart("partuuid")
			s.Partuuid.Encode(e)
		}
	}
	{
		e.FieldStart("path_on_host")
		e.Str(s.PathOnHost)
	}
	{
		if s.RateLimiter.Set {
			e.FieldStart("rate_limiter")
			s.RateLimiter.Encode(e)
		}
	}
}

var jsonFieldsNameOfDrive = [7]string{
	0: "drive_id",
	1: "cache_type",
	2: "is_read_only",
	3: "is_root_device",
	4: "partuuid",
	5: "path_on_host",
	6: "rate_limiter",
}

// Decode decodes Drive from json.
func (s *Drive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Drive to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drive_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DriveID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drive_id\"")
			}
		case "cache_type":
			if err := func() error {
				s.CacheType.Reset()
				if err := s.CacheType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_type\"")
			}
		case "is_read_only":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_read_only\"")
			}
		case "is_root_device":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsRootDevice = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_root_device\"")
			}
		case "partuuid":
			if err := func() error {
				s.Partuuid.Reset()
				if err := s.Partuuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partuuid\"")
			}
		case "path_on_host":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PathOnHost = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path_on_host\"")
			}
		case "rate_limiter":
			if err := func() error {
				s.RateLimiter.Reset()
				if err := s.RateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Drive")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrive) {
					name = jsonFieldsNameOfDrive[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Drive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Drive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		if s.FaultMessage.Set {
			e.FieldStart("fault_message")
			s.FaultMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [1]string{
	0: "fault_message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fault_message":
			if err := func() error {
				s.FaultMessage.Reset()
				if err := s.FaultMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fault_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullVmConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullVmConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.BalloonDevice.Set {
			e.FieldStart("balloon_device")
			s.BalloonDevice.Encode(e)
		}
	}
	{
		if s.BlockDevices != nil {
			e.FieldStart("block_devices")
			e.ArrStart()
			for _, elem := range s.BlockDevices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BootSource.Set {
			e.FieldStart("boot_source")
			s.BootSource.Encode(e)
		}
	}
	{
		if s.Logger.Set {
			e.FieldStart("logger")
			s.Logger.Encode(e)
		}
	}
	{
		if s.MachineConfig.Set {
			e.FieldStart("machine_config")
			s.MachineConfig.Encode(e)
		}
	}
	{
		if s.Metrics.Set {
			e.FieldStart("metrics")
			s.Metrics.Encode(e)
		}
	}
	{
		if s.MmdsConfig.Set {
			e.FieldStart("mmds_config")
			s.MmdsConfig.Encode(e)
		}
	}
	{
		if s.NetDevices != nil {
			e.FieldStart("net_devices")
			e.ArrStart()
			for _, elem := range s.NetDevices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VsockDevice.Set {
			e.FieldStart("vsock_device")
			s.VsockDevice.Encode(e)
		}
	}
}

var jsonFieldsNameOfFullVmConfiguration = [9]string{
	0: "balloon_device",
	1: "block_devices",
	2: "boot_source",
	3: "logger",
	4: "machine_config",
	5: "metrics",
	6: "mmds_config",
	7: "net_devices",
	8: "vsock_device",
}

// Decode decodes FullVmConfiguration from json.
func (s *FullVmConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullVmConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "balloon_device":
			if err := func() error {
				s.BalloonDevice.Reset()
				if err := s.BalloonDevice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balloon_device\"")
			}
		case "block_devices":
			if err := func() error {
				s.BlockDevices = make([]Drive, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Drive
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BlockDevices = append(s.BlockDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_devices\"")
			}
		case "boot_source":
			if err := func() error {
				s.BootSource.Reset()
				if err := s.BootSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot_source\"")
			}
		case "logger":
			if err := func() error {
				s.Logger.Reset()
				if err := s.Logger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logger\"")
			}
		case "machine_config":
			if err := func() error {
				s.MachineConfig.Reset()
				if err := s.MachineConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machine_config\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics.Reset()
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "mmds_config":
			if err := func() error {
				s.MmdsConfig.Reset()
				if err := s.MmdsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mmds_config\"")
			}
		case "net_devices":
			if err := func() error {
				s.NetDevices = make([]NetworkInterface, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkInterface
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetDevices = append(s.NetDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"net_devices\"")
			}
		case "vsock_device":
			if err := func() error {
				s.VsockDevice.Reset()
				if err := s.VsockDevice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsock_device\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullVmConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullVmConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullVmConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceActionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceActionInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action_type")
		s.ActionType.Encode(e)
	}
}

var jsonFieldsNameOfInstanceActionInfo = [1]string{
	0: "action_type",
}

// Decode decodes InstanceActionInfo from json.
func (s *InstanceActionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceActionInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceActionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstanceActionInfo) {
					name = jsonFieldsNameOfInstanceActionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceActionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceActionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceActionInfoActionType as json.
func (s InstanceActionInfoActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstanceActionInfoActionType from json.
func (s *InstanceActionInfoActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceActionInfoActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceActionInfoActionType(v) {
	case InstanceActionInfoActionTypeFlushMetrics:
		*s = InstanceActionInfoActionTypeFlushMetrics
	case InstanceActionInfoActionTypeInstanceStart:
		*s = InstanceActionInfoActionTypeInstanceStart
	case InstanceActionInfoActionTypeSendCtrlAltDel:
		*s = InstanceActionInfoActionTypeSendCtrlAltDel
	default:
		*s = InstanceActionInfoActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstanceActionInfoActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceActionInfoActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("app_name")
		e.Str(s.AppName)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("vmm_version")
		e.Str(s.VmmVersion)
	}
}

var jsonFieldsNameOfInstanceInfo = [4]string{
	0: "app_name",
	1: "id",
	2: "state",
	3: "vmm_version",
}

// Decode decodes InstanceInfo from json.
func (s *InstanceInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AppName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "vmm_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VmmVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmm_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstanceInfo) {
					name = jsonFieldsNameOfInstanceInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceInfoState as json.
func (s InstanceInfoState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstanceInfoState from json.
func (s *InstanceInfoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceInfoState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceInfoState(v) {
	case InstanceInfoStateNotStarted:
		*s = InstanceInfoStateNotStarted
	case InstanceInfoStateRunning:
		*s = InstanceInfoStateRunning
	case InstanceInfoStatePaused:
		*s = InstanceInfoStatePaused
	default:
		*s = InstanceInfoState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstanceInfoState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceInfoState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Logger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Logger) encodeFields(e *jx.Encoder) {
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		e.FieldStart("log_path")
		e.Str(s.LogPath)
	}
	{
		if s.ShowLevel.Set {
			e.FieldStart("show_level")
			s.ShowLevel.Encode(e)
		}
	}
	{
		if s.ShowLogOrigin.Set {
			e.FieldStart("show_log_origin")
			s.ShowLogOrigin.Encode(e)
		}
	}
}

var jsonFieldsNameOfLogger = [4]string{
	0: "level",
	1: "log_path",
	2: "show_level",
	3: "show_log_origin",
}

// Decode decodes Logger from json.
func (s *Logger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Logger to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "log_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LogPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_path\"")
			}
		case "show_level":
			if err := func() error {
				s.ShowLevel.Reset()
				if err := s.ShowLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_level\"")
			}
		case "show_log_origin":
			if err := func() error {
				s.ShowLogOrigin.Reset()
				if err := s.ShowLogOrigin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_log_origin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Logger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogger) {
					name = jsonFieldsNameOfLogger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Logger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Logger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoggerLevel as json.
func (s LoggerLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LoggerLevel from json.
func (s *LoggerLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoggerLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LoggerLevel(v) {
	case LoggerLevelError:
		*s = LoggerLevelError
	case LoggerLevelWarning:
		*s = LoggerLevelWarning
	case LoggerLevelInfo:
		*s = LoggerLevelInfo
	case LoggerLevelDebug:
		*s = LoggerLevelDebug
	default:
		*s = LoggerLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LoggerLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoggerLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MachineConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MachineConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.CPUTemplate.Set {
			e.FieldStart("cpu_template")
			s.CPUTemplate.Encode(e)
		}
	}
	{
		e.FieldStart("ht_enabled")
		e.Bool(s.HtEnabled)
	}
	{
		e.FieldStart("mem_size_mib")
		e.Int(s.MemSizeMib)
	}
	{
		if s.TrackDirtyPages.Set {
			e.FieldStart("track_dirty_pages")
			s.TrackDirtyPages.Encode(e)
		}
	}
	{
		e.FieldStart("vcpu_count")
		e.Int(s.VcpuCount)
	}
}

var jsonFieldsNameOfMachineConfiguration = [5]string{
	0: "cpu_template",
	1: "ht_enabled",
	2: "mem_size_mib",
	3: "track_dirty_pages",
	4: "vcpu_count",
}

// Decode decodes MachineConfiguration from json.
func (s *MachineConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MachineConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu_template":
			if err := func() error {
				s.CPUTemplate.Reset()
				if err := s.CPUTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_template\"")
			}
		case "ht_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HtEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ht_enabled\"")
			}
		case "mem_size_mib":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MemSizeMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_size_mib\"")
			}
		case "track_dirty_pages":
			if err := func() error {
				s.TrackDirtyPages.Reset()
				if err := s.TrackDirtyPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track_dirty_pages\"")
			}
		case "vcpu_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.VcpuCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcpu_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MachineConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMachineConfiguration) {
					name = jsonFieldsNameOfMachineConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MachineConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MachineConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Metrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Metrics) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metrics_path")
		e.Str(s.MetricsPath)
	}
}

var jsonFieldsNameOfMetrics = [1]string{
	0: "metrics_path",
}

// Decode decodes Metrics from json.
func (s *Metrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Metrics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics_path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricsPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Metrics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMetrics) {
					name = jsonFieldsNameOfMetrics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Metrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Metrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MmdsConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MmdsConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Ipv4Address.Set {
			e.FieldStart("ipv4_address")
			s.Ipv4Address.Encode(e)
		}
	}
}

var jsonFieldsNameOfMmdsConfig = [1]string{
	0: "ipv4_address",
}

// Decode decodes MmdsConfig from json.
func (s *MmdsConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4_address":
			if err := func() error {
				s.Ipv4Address.Reset()
				if err := s.Ipv4Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MmdsConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MmdsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MmdsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MmdsGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MmdsGetOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfMmdsGetOK = [0]string{}

// Decode decodes MmdsGetOK from json.
func (s *MmdsGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode MmdsGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MmdsGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MmdsGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MmdsPatchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MmdsPatchReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfMmdsPatchReq = [0]string{}

// Decode decodes MmdsPatchReq from json.
func (s *MmdsPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode MmdsPatchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MmdsPatchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MmdsPatchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MmdsPutReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MmdsPutReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfMmdsPutReq = [0]string{}

// Decode decodes MmdsPutReq from json.
func (s *MmdsPutReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsPutReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode MmdsPutReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MmdsPutReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MmdsPutReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkInterface) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkInterface) encodeFields(e *jx.Encoder) {
	{
		if s.AllowMmdsRequests.Set {
			e.FieldStart("allow_mmds_requests")
			s.AllowMmdsRequests.Encode(e)
		}
	}
	{
		if s.GuestMAC.Set {
			e.FieldStart("guest_mac")
			s.GuestMAC.Encode(e)
		}
	}
	{
		e.FieldStart("host_dev_name")
		e.Str(s.HostDevName)
	}
	{
		e.FieldStart("iface_id")
		e.Str(s.IfaceID)
	}
	{
		if s.RxRateLimiter.Set {
			e.FieldStart("rx_rate_limiter")
			s.RxRateLimiter.Encode(e)
		}
	}
	{
		if s.TxRateLimiter.Set {
			e.FieldStart("tx_rate_limiter")
			s.TxRateLimiter.Encode(e)
		}
	}
}

var jsonFieldsNameOfNetworkInterface = [6]string{
	0: "allow_mmds_requests",
	1: "guest_mac",
	2: "host_dev_name",
	3: "iface_id",
	4: "rx_rate_limiter",
	5: "tx_rate_limiter",
}

// Decode decodes NetworkInterface from json.
func (s *NetworkInterface) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkInterface to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_mmds_requests":
			if err := func() error {
				s.AllowMmdsRequests.Reset()
				if err := s.AllowMmdsRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_mmds_requests\"")
			}
		case "guest_mac":
			if err := func() error {
				s.GuestMAC.Reset()
				if err := s.GuestMAC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guest_mac\"")
			}
		case "host_dev_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.HostDevName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_dev_name\"")
			}
		case "iface_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IfaceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iface_id\"")
			}
		case "rx_rate_limiter":
			if err := func() error {
				s.RxRateLimiter.Reset()
				if err := s.RxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx_rate_limiter\"")
			}
		case "tx_rate_limiter":
			if err := func() error {
				s.TxRateLimiter.Reset()
				if err := s.TxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx_rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkInterface")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkInterface) {
					name = jsonFieldsNameOfNetworkInterface[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkInterface) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkInterface) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Balloon as json.
func (o OptBalloon) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Balloon from json.
func (o *OptBalloon) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBalloon to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBalloon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBalloon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BootSource as json.
func (o OptBootSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BootSource from json.
func (o *OptBootSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBootSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBootSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBootSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CpuTemplate as json.
func (o OptCpuTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CpuTemplate from json.
func (o *OptCpuTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCpuTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCpuTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCpuTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Logger as json.
func (o OptLogger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Logger from json.
func (o *OptLogger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoggerLevel as json.
func (o OptLoggerLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LoggerLevel from json.
func (o *OptLoggerLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoggerLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoggerLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoggerLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MachineConfiguration as json.
func (o OptMachineConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MachineConfiguration from json.
func (o *OptMachineConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMachineConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMachineConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMachineConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Metrics as json.
func (o OptMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Metrics from json.
func (o *OptMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MmdsConfig as json.
func (o OptMmdsConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MmdsConfig from json.
func (o *OptMmdsConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMmdsConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMmdsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMmdsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimiter as json.
func (o OptRateLimiter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimiter from json.
func (o *OptRateLimiter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimiter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimiter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimiter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnapshotCreateParamsSnapshotType as json.
func (o OptSnapshotCreateParamsSnapshotType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SnapshotCreateParamsSnapshotType from json.
func (o *OptSnapshotCreateParamsSnapshotType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSnapshotCreateParamsSnapshotType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSnapshotCreateParamsSnapshotType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSnapshotCreateParamsSnapshotType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TokenBucket as json.
func (o OptTokenBucket) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TokenBucket from json.
func (o *OptTokenBucket) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTokenBucket to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTokenBucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTokenBucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Vsock as json.
func (o OptVsock) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Vsock from json.
func (o *OptVsock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsock to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVsock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVsock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartialDrive) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartialDrive) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("drive_id")
		e.Str(s.DriveID)
	}
	{
		if s.PathOnHost.Set {
			e.FieldStart("path_on_host")
			s.PathOnHost.Encode(e)
		}
	}
	{
		if s.RateLimiter.Set {
			e.FieldStart("rate_limiter")
			s.RateLimiter.Encode(e)
		}
	}
}

var jsonFieldsNameOfPartialDrive = [3]string{
	0: "drive_id",
	1: "path_on_host",
	2: "rate_limiter",
}

// Decode decodes PartialDrive from json.
func (s *PartialDrive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartialDrive to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drive_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DriveID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drive_id\"")
			}
		case "path_on_host":
			if err := func() error {
				s.PathOnHost.Reset()
				if err := s.PathOnHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path_on_host\"")
			}
		case "rate_limiter":
			if err := func() error {
				s.RateLimiter.Reset()
				if err := s.RateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartialDrive")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartialDrive) {
					name = jsonFieldsNameOfPartialDrive[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartialDrive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartialDrive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartialNetworkInterface) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartialNetworkInterface) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("iface_id")
		e.Str(s.IfaceID)
	}
	{
		if s.RxRateLimiter.Set {
			e.FieldStart("rx_rate_limiter")
			s.RxRateLimiter.Encode(e)
		}
	}
	{
		if s.TxRateLimiter.Set {
			e.FieldStart("tx_rate_limiter")
			s.TxRateLimiter.Encode(e)
		}
	}
}

var jsonFieldsNameOfPartialNetworkInterface = [3]string{
	0: "iface_id",
	1: "rx_rate_limiter",
	2: "tx_rate_limiter",
}

// Decode decodes PartialNetworkInterface from json.
func (s *PartialNetworkInterface) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartialNetworkInterface to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "iface_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IfaceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iface_id\"")
			}
		case "rx_rate_limiter":
			if err := func() error {
				s.RxRateLimiter.Reset()
				if err := s.RxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx_rate_limiter\"")
			}
		case "tx_rate_limiter":
			if err := func() error {
				s.TxRateLimiter.Reset()
				if err := s.TxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx_rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartialNetworkInterface")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartialNetworkInterface) {
					name = jsonFieldsNameOfPartialNetworkInterface[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartialNetworkInterface) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartialNetworkInterface) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimiter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimiter) encodeFields(e *jx.Encoder) {
	{
		if s.Bandwidth.Set {
			e.FieldStart("bandwidth")
			s.Bandwidth.Encode(e)
		}
	}
	{
		if s.Ops.Set {
			e.FieldStart("ops")
			s.Ops.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimiter = [2]string{
	0: "bandwidth",
	1: "ops",
}

// Decode decodes RateLimiter from json.
func (s *RateLimiter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimiter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bandwidth":
			if err := func() error {
				s.Bandwidth.Reset()
				if err := s.Bandwidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth\"")
			}
		case "ops":
			if err := func() error {
				s.Ops.Reset()
				if err := s.Ops.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimiter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimiter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimiter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnapshotCreateParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnapshotCreateParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mem_file_path")
		e.Str(s.MemFilePath)
	}
	{
		e.FieldStart("snapshot_path")
		e.Str(s.SnapshotPath)
	}
	{
		if s.SnapshotType.Set {
			e.FieldStart("snapshot_type")
			s.SnapshotType.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnapshotCreateParams = [4]string{
	0: "mem_file_path",
	1: "snapshot_path",
	2: "snapshot_type",
	3: "version",
}

// Decode decodes SnapshotCreateParams from json.
func (s *SnapshotCreateParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotCreateParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mem_file_path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MemFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_file_path\"")
			}
		case "snapshot_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SnapshotPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_path\"")
			}
		case "snapshot_type":
			if err := func() error {
				s.SnapshotType.Reset()
				if err := s.SnapshotType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_type\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnapshotCreateParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnapshotCreateParams) {
					name = jsonFieldsNameOfSnapshotCreateParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnapshotCreateParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnapshotCreateParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnapshotCreateParamsSnapshotType as json.
func (s SnapshotCreateParamsSnapshotType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SnapshotCreateParamsSnapshotType from json.
func (s *SnapshotCreateParamsSnapshotType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotCreateParamsSnapshotType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnapshotCreateParamsSnapshotType(v) {
	case SnapshotCreateParamsSnapshotTypeFull:
		*s = SnapshotCreateParamsSnapshotTypeFull
	case SnapshotCreateParamsSnapshotTypeDiff:
		*s = SnapshotCreateParamsSnapshotTypeDiff
	default:
		*s = SnapshotCreateParamsSnapshotType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SnapshotCreateParamsSnapshotType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnapshotCreateParamsSnapshotType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnapshotLoadParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnapshotLoadParams) encodeFields(e *jx.Encoder) {
	{
		if s.EnableDiffSnapshots.Set {
			e.FieldStart("enable_diff_snapshots")
			s.EnableDiffSnapshots.Encode(e)
		}
	}
	{
		e.FieldStart("mem_file_path")
		e.Str(s.MemFilePath)
	}
	{
		e.FieldStart("snapshot_path")
		e.Str(s.SnapshotPath)
	}
	{
		if s.ResumeVM.Set {
			e.FieldStart("resume_vm")
			s.ResumeVM.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnapshotLoadParams = [4]string{
	0: "enable_diff_snapshots",
	1: "mem_file_path",
	2: "snapshot_path",
	3: "resume_vm",
}

// Decode decodes SnapshotLoadParams from json.
func (s *SnapshotLoadParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotLoadParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enable_diff_snapshots":
			if err := func() error {
				s.EnableDiffSnapshots.Reset()
				if err := s.EnableDiffSnapshots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_diff_snapshots\"")
			}
		case "mem_file_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MemFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_file_path\"")
			}
		case "snapshot_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SnapshotPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_path\"")
			}
		case "resume_vm":
			if err := func() error {
				s.ResumeVM.Reset()
				if err := s.ResumeVM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resume_vm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnapshotLoadParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnapshotLoadParams) {
					name = jsonFieldsNameOfSnapshotLoadParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnapshotLoadParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnapshotLoadParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenBucket) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenBucket) encodeFields(e *jx.Encoder) {
	{
		if s.OneTimeBurst.Set {
			e.FieldStart("one_time_burst")
			s.OneTimeBurst.Encode(e)
		}
	}
	{
		e.FieldStart("refill_time")
		e.Int64(s.RefillTime)
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
}

var jsonFieldsNameOfTokenBucket = [3]string{
	0: "one_time_burst",
	1: "refill_time",
	2: "size",
}

// Decode decodes TokenBucket from json.
func (s *TokenBucket) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenBucket to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "one_time_burst":
			if err := func() error {
				s.OneTimeBurst.Reset()
				if err := s.OneTimeBurst.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"one_time_burst\"")
			}
		case "refill_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.RefillTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refill_time\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenBucket")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenBucket) {
					name = jsonFieldsNameOfTokenBucket[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenBucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenBucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VM) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VM) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfVM = [1]string{
	0: "state",
}

// Decode decodes VM from json.
func (s *VM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VM to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VM")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVM) {
					name = jsonFieldsNameOfVM[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMState as json.
func (s VMState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VMState from json.
func (s *VMState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VMState(v) {
	case VMStatePaused:
		*s = VMStatePaused
	case VMStateResumed:
		*s = VMStateResumed
	default:
		*s = VMState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VMState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vsock) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vsock) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("guest_cid")
		e.Int(s.GuestCid)
	}
	{
		e.FieldStart("uds_path")
		e.Str(s.UdsPath)
	}
	{
		e.FieldStart("vsock_id")
		e.Str(s.VsockID)
	}
}

var jsonFieldsNameOfVsock = [3]string{
	0: "guest_cid",
	1: "uds_path",
	2: "vsock_id",
}

// Decode decodes Vsock from json.
func (s *Vsock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vsock to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "guest_cid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.GuestCid = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guest_cid\"")
			}
		case "uds_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UdsPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uds_path\"")
			}
		case "vsock_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VsockID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsock_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vsock")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsock) {
					name = jsonFieldsNameOfVsock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vsock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vsock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
