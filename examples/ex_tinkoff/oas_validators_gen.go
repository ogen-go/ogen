// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/netip"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/metric/nonrecording"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// No-op definition for keeping imports.
var (
	_ = bytes.NewReader
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = io.Copy
	_ = math.Mod
	_ = big.Rat{}
	_ = bits.LeadingZeros64
	_ = net.IP{}
	_ = http.MethodGet
	_ = netip.Addr{}
	_ = url.URL{}
	_ = regexp.MustCompile
	_ = sort.Ints
	_ = strconv.ParseInt
	_ = strings.Builder{}
	_ = sync.Pool{}
	_ = time.Time{}

	_ = errors.Is
	_ = jx.Null
	_ = uuid.UUID{}
	_ = otel.GetTracerProvider
	_ = attribute.KeyValue{}
	_ = codes.Unset
	_ = metric.MeterConfig{}
	_ = syncint64.Counter(nil)
	_ = nonrecording.NewNoopMeterProvider
	_ = trace.TraceIDFromHex

	_ = conv.ToInt32
	_ = ht.NewRequest
	_ = json.Marshal
	_ = ogenerrors.SecurityError{}
	_ = otelogen.Version
	_ = uri.PathEncoder{}
	_ = validate.Int{}
)

func (s BrokerAccountType) Validate() error {
	switch s {
	case "Tinkoff":
		return nil
	case "TinkoffIis":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s Candle) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Interval.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "interval",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.O)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "o",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.C)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "c",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.H)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "h",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.L)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "l",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s CandleResolution) Validate() error {
	switch s {
	case "1min":
		return nil
	case "2min":
		return nil
	case "3min":
		return nil
	case "5min":
		return nil
	case "10min":
		return nil
	case "15min":
		return nil
	case "30min":
		return nil
	case "hour":
		return nil
	case "day":
		return nil
	case "week":
		return nil
	case "month":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s Candles) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Interval.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "interval",
			Error: err,
		})
	}
	if err := func() error {
		if s.Candles == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Candles {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "candles",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s CandlesResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Currencies) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Currencies == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Currencies {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currencies",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Currency) Validate() error {
	switch s {
	case "RUB":
		return nil
	case "USD":
		return nil
	case "EUR":
		return nil
	case "GBP":
		return nil
	case "HKD":
		return nil
	case "CHF":
		return nil
	case "JPY":
		return nil
	case "CNY":
		return nil
	case "TRY":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s CurrencyPosition) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Currency.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Balance)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "balance",
			Error: err,
		})
	}
	if err := func() error {
		if s.Blocked.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.Blocked.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "blocked",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s InstrumentType) Validate() error {
	switch s {
	case "Stock":
		return nil
	case "Currency":
		return nil
	case "Bond":
		return nil
	case "Etf":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s LimitOrderRequest) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Operation.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operation",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Price)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s LimitOrderResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MarketInstrument) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.MinPriceIncrement.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.MinPriceIncrement.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minPriceIncrement",
			Error: err,
		})
	}
	if err := func() error {
		if s.Currency.Set {
			if err := func() error {
				if err := s.Currency.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MarketInstrumentList) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Instruments == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Instruments {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "instruments",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MarketInstrumentListResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MarketOrderRequest) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Operation.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operation",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MarketOrderResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s MoneyAmount) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Currency.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Value)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "value",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Operation) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Trades {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "trades",
			Error: err,
		})
	}
	if err := func() error {
		if s.Commission.Set {
			if err := func() error {
				if err := s.Commission.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "commission",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Currency.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Payment)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payment",
			Error: err,
		})
	}
	if err := func() error {
		if s.Price.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.Price.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if err := func() error {
		if s.InstrumentType.Set {
			if err := func() error {
				if err := s.InstrumentType.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "instrumentType",
			Error: err,
		})
	}
	if err := func() error {
		if s.OperationType.Set {
			if err := func() error {
				if err := s.OperationType.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operationType",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OperationStatus) Validate() error {
	switch s {
	case "Done":
		return nil
	case "Decline":
		return nil
	case "Progress":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s OperationTrade) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Price)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OperationType) Validate() error {
	switch s {
	case "Buy":
		return nil
	case "Sell":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s OperationTypeWithCommission) Validate() error {
	switch s {
	case "Buy":
		return nil
	case "BuyCard":
		return nil
	case "Sell":
		return nil
	case "BrokerCommission":
		return nil
	case "ExchangeCommission":
		return nil
	case "ServiceCommission":
		return nil
	case "MarginCommission":
		return nil
	case "OtherCommission":
		return nil
	case "PayIn":
		return nil
	case "PayOut":
		return nil
	case "Tax":
		return nil
	case "TaxLucre":
		return nil
	case "TaxDividend":
		return nil
	case "TaxCoupon":
		return nil
	case "TaxBack":
		return nil
	case "Repayment":
		return nil
	case "PartRepayment":
		return nil
	case "Coupon":
		return nil
	case "Dividend":
		return nil
	case "SecurityIn":
		return nil
	case "SecurityOut":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s Operations) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Operations == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Operations {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operations",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OperationsResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s Order) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Operation.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operation",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Price)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OrderResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Price)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OrderStatus) Validate() error {
	switch s {
	case "New":
		return nil
	case "PartiallyFill":
		return nil
	case "Fill":
		return nil
	case "Cancelled":
		return nil
	case "Replaced":
		return nil
	case "PendingCancel":
		return nil
	case "Rejected":
		return nil
	case "PendingReplace":
		return nil
	case "PendingNew":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s OrderType) Validate() error {
	switch s {
	case "Limit":
		return nil
	case "Market":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s Orderbook) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Bids == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Bids {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "bids",
			Error: err,
		})
	}
	if err := func() error {
		if s.Asks == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Asks {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "asks",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.TradeStatus.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "tradeStatus",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.MinPriceIncrement)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minPriceIncrement",
			Error: err,
		})
	}
	if err := func() error {
		if s.FaceValue.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.FaceValue.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "faceValue",
			Error: err,
		})
	}
	if err := func() error {
		if s.LastPrice.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.LastPrice.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "lastPrice",
			Error: err,
		})
	}
	if err := func() error {
		if s.ClosePrice.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.ClosePrice.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "closePrice",
			Error: err,
		})
	}
	if err := func() error {
		if s.LimitUp.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.LimitUp.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "limitUp",
			Error: err,
		})
	}
	if err := func() error {
		if s.LimitDown.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.LimitDown.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "limitDown",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OrderbookResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s OrdersResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Payload == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Payload {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PlacedLimitOrder) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Operation.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operation",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if err := func() error {
		if s.Commission.Set {
			if err := func() error {
				if err := s.Commission.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "commission",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PlacedMarketOrder) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Operation.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "operation",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if err := func() error {
		if s.Commission.Set {
			if err := func() error {
				if err := s.Commission.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "commission",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s Portfolio) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Positions == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Positions {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "positions",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PortfolioCurrenciesResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PortfolioPosition) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.InstrumentType.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "instrumentType",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Balance)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "balance",
			Error: err,
		})
	}
	if err := func() error {
		if s.Blocked.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.Blocked.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "blocked",
			Error: err,
		})
	}
	if err := func() error {
		if s.ExpectedYield.Set {
			if err := func() error {
				if err := s.ExpectedYield.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "expectedYield",
			Error: err,
		})
	}
	if err := func() error {
		if s.AveragePositionPrice.Set {
			if err := func() error {
				if err := s.AveragePositionPrice.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "averagePositionPrice",
			Error: err,
		})
	}
	if err := func() error {
		if s.AveragePositionPriceNoNkd.Set {
			if err := func() error {
				if err := s.AveragePositionPriceNoNkd.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "averagePositionPriceNoNkd",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s PortfolioResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SandboxAccount) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.BrokerAccountType.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "brokerAccountType",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SandboxCurrency) Validate() error {
	switch s {
	case "RUB":
		return nil
	case "USD":
		return nil
	case "EUR":
		return nil
	case "GBP":
		return nil
	case "HKD":
		return nil
	case "CHF":
		return nil
	case "JPY":
		return nil
	case "CNY":
		return nil
	case "TRY":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s SandboxRegisterRequest) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.BrokerAccountType.Set {
			if err := func() error {
				if err := s.BrokerAccountType.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "brokerAccountType",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SandboxRegisterResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SandboxSetCurrencyBalanceRequest) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Currency.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Balance)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "balance",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SandboxSetPositionBalanceRequest) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Float{}).Validate(float64(s.Balance)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "balance",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SearchMarketInstrument) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.MinPriceIncrement.Set {
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(s.MinPriceIncrement.Value)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minPriceIncrement",
			Error: err,
		})
	}
	if err := func() error {
		if s.Currency.Set {
			if err := func() error {
				if err := s.Currency.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "currency",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s SearchMarketInstrumentResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s TradeStatus) Validate() error {
	switch s {
	case "NormalTrading":
		return nil
	case "NotAvailableForTrading":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s UserAccount) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.BrokerAccountType.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "brokerAccountType",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s UserAccounts) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Accounts == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Accounts {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "accounts",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s UserAccountsResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Payload.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "payload",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
