// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/ogen-go/ogen/validate"
)

// validateUniqueWorkflowStatus checks for duplicate items in a slice using hash-based detection.
func validateUniqueWorkflowStatus(items []WorkflowStatus) error {
	if len(items) <= 1 {
		return nil
	}

	// Hash bucket structure for O(n) duplicate detection
	type entry struct {
		item  WorkflowStatus
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	// Recover from depth limit panics during Equal() calls
	var depthErr error
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				depthErr = e
			} else {
				panic(r) // Re-panic if not a depth limit error
			}
		}
	}()

	// Check each item for duplicates
	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		// Check for duplicates in this hash bucket
		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		// No duplicate found, add to bucket
		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	if depthErr != nil {
		return depthErr
	}

	return nil
}

// validateUniqueStatusProperties checks for duplicate items in a slice using hash-based detection.
func validateUniqueStatusProperties(items []StatusProperties) error {
	if len(items) <= 1 {
		return nil
	}

	// Hash bucket structure for O(n) duplicate detection
	type entry struct {
		item  StatusProperties
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	// Recover from depth limit panics during Equal() calls
	var depthErr error
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				depthErr = e
			} else {
				panic(r) // Re-panic if not a depth limit error
			}
		}
	}()

	// Check each item for duplicates
	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		// Check for duplicates in this hash bucket
		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		// No duplicate found, add to bucket
		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	if depthErr != nil {
		return depthErr
	}

	return nil
}
