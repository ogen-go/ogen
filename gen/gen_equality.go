package gen

import (
	"fmt"
	"os"
	"strings"

	"github.com/go-faster/errors"
	"golang.org/x/tools/imports"

	"github.com/ogen-go/ogen/gen/ir"
)

// generateEqualityMethods generates Equal() and Hash() methods for all types
// that require them for complex uniqueItems validation.
// This is kept for backward compatibility but typically generateEqualityMethodsWithFS should be used.
func (g *Generator) generateEqualityMethods() error {
	return g.generateEqualityMethodsWithFS(nil, "api")
}

// generateEqualityMethodsWithFS generates Equal() and Hash() methods using a FileSystem
func (g *Generator) generateEqualityMethodsWithFS(fs FileSystem, pkgName string) error {
	for _, spec := range g.equalitySpecs {
		if err := g.generateEqualMethod(spec, pkgName, fs); err != nil {
			return errors.Wrapf(err, "generate Equal for %s", spec.TypeName)
		}
		if err := g.generateHashMethod(spec, pkgName, fs); err != nil {
			return errors.Wrapf(err, "generate Hash for %s", spec.TypeName)
		}
	}
	return nil
}

// generateEqualMethod generates an Equal() method for a type
func (g *Generator) generateEqualMethod(spec *ir.EqualityMethodSpec, pkgName string, fs FileSystem) error {
	var b strings.Builder

	// File header comment
	fmt.Fprintf(&b, "// Code generated by ogen, DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)

	// Method signature
	if spec.NeedsDepthTracking {
		fmt.Fprintf(&b, "// Equal compares two %s instances for equality.\n", spec.TypeName)
		fmt.Fprintf(&b, "// The depth parameter prevents infinite recursion on nested objects.\n")
		fmt.Fprintf(&b, "func (a %s) Equal(b %s, depth int) bool {\n", spec.TypeName, spec.TypeName)

		// Depth limit check
		fmt.Fprintf(&b, "\tif depth > %d {\n", spec.MaxDepth)
		fmt.Fprintf(&b, "\t\tpanic(&validate.DepthLimitError{\n")
		fmt.Fprintf(&b, "\t\t\tMaxDepth: %d,\n", spec.MaxDepth)
		fmt.Fprintf(&b, "\t\t\tTypeName: %q,\n", spec.TypeName)
		fmt.Fprintf(&b, "\t\t})\n")
		fmt.Fprintf(&b, "\t}\n\n")
	} else {
		fmt.Fprintf(&b, "// Equal compares two %s instances for equality.\n", spec.TypeName)
		fmt.Fprintf(&b, "func (a %s) Equal(b %s) bool {\n", spec.TypeName, spec.TypeName)
	}

	// Generate field comparisons
	for _, field := range spec.Fields {
		g.writeFieldComparison(&b, field, spec.NeedsDepthTracking)
	}

	fmt.Fprintf(&b, "\treturn true\n")
	fmt.Fprintf(&b, "}\n")

	// Write to file
	filename := fmt.Sprintf("oas_%s_equal_gen.go", snakeCase(spec.TypeName))
	return writeFormattedCode(fs, filename, []byte(b.String()))
}

// writeFieldComparison generates comparison code for a single field
func (g *Generator) writeFieldComparison(b *strings.Builder, field ir.FieldEqualitySpec, hasDepth bool) {
	switch field.FieldType {
	case ir.FieldTypePrimitive:
		// Simple equality check
		fmt.Fprintf(b, "\tif a.%s != b.%s {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeOptional:
		// Optional field comparison (OptT types)
		fmt.Fprintf(b, "\t// Compare optional field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Set != b.%s.Set {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif a.%s.Set {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif a.%s.Value != b.%s.Value {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNullable:
		// Nullable field comparison (NilT types)
		fmt.Fprintf(b, "\t// Compare nullable field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Null != b.%s.Null {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif !a.%s.Null {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif a.%s.Value != b.%s.Value {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypePointer:
		// Pointer field comparison
		fmt.Fprintf(b, "\t// Compare pointer field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif (a.%s == nil) != (b.%s == nil) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif a.%s != nil {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif *a.%s != *b.%s {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeArray:
		// Array field comparison
		fmt.Fprintf(b, "\t// Compare array field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif len(a.%s) != len(b.%s) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tfor i := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif a.%s[i] != b.%s[i] {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeMap:
		// Map field comparison
		fmt.Fprintf(b, "\t// Compare map field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif len(a.%s) != len(b.%s) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tfor k, v := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tbv, ok := b.%s[k]\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif !ok || v != bv {\n")
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNestedObject:
		// Nested object comparison (recursive Equal() call)
		fmt.Fprintf(b, "\t// Compare nested object: %s\n", field.FieldName)
		if hasDepth {
			fmt.Fprintf(b, "\tif !a.%s.Equal(b.%s, depth+1) {\n", field.FieldName, field.FieldName)
		} else {
			fmt.Fprintf(b, "\tif !a.%s.Equal(b.%s) {\n", field.FieldName, field.FieldName)
		}
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
	}
}

// generateHashMethod generates a Hash() method for a type
func (g *Generator) generateHashMethod(spec *ir.EqualityMethodSpec, pkgName string, fs FileSystem) error {
	var b strings.Builder

	// File header comment
	fmt.Fprintf(&b, "// Code generated by ogen, DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)

	// Imports
	fmt.Fprintf(&b, "import (\n")
	fmt.Fprintf(&b, "\t\"encoding/binary\"\n")
	fmt.Fprintf(&b, "\t\"fmt\"\n")
	fmt.Fprintf(&b, "\t\"hash/fnv\"\n")
	fmt.Fprintf(&b, "\t\"sort\"\n")
	fmt.Fprintf(&b, ")\n\n")

	// Method signature
	fmt.Fprintf(&b, "// Hash computes a hash value for %s using FNV-1a.\n", spec.TypeName)
	fmt.Fprintf(&b, "// Equal objects must produce equal hashes.\n")
	fmt.Fprintf(&b, "func (a %s) Hash() uint64 {\n", spec.TypeName)

	// Initialize hash
	fmt.Fprintf(&b, "\th := fnv.New64a()\n\n")

	// Hash each field
	for _, field := range spec.Fields {
		// Convert FieldEqualitySpec to FieldHashSpec
		hashField := ir.FieldHashSpec{
			FieldName: field.FieldName,
			FieldType: field.FieldType,
			GoType:    field.GoType,
			IsNested:  field.IsNested,
		}
		g.writeFieldHash(&b, hashField)
	}

	fmt.Fprintf(&b, "\treturn h.Sum64()\n")
	fmt.Fprintf(&b, "}\n")

	// Write to file
	filename := fmt.Sprintf("oas_%s_hash_gen.go", snakeCase(spec.TypeName))
	return writeFormattedCode(fs, filename, []byte(b.String()))
}

// writeFieldHash generates hashing code for a single field
func (g *Generator) writeFieldHash(b *strings.Builder, field ir.FieldHashSpec) {
	switch field.FieldType {
	case ir.FieldTypePrimitive:
		// Hash primitive field
		fmt.Fprintf(b, "\t// Hash primitive field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s)))\n", field.FieldName)

	case ir.FieldTypeOptional:
		// Hash optional field (presence + value)
		fmt.Fprintf(b, "\t// Hash optional field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Set {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s.Value)))\n", field.FieldName)
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNullable:
		// Hash nullable field
		fmt.Fprintf(b, "\t// Hash nullable field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Null {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s.Value)))\n", field.FieldName)
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypePointer:
		// Hash pointer field
		fmt.Fprintf(b, "\t// Hash pointer field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s != nil {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", *a.%s)))\n", field.FieldName)
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeArray:
		// Hash array field
		fmt.Fprintf(b, "\t// Hash array field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tfor _, item := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", item)))\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeMap:
		// Hash map field (sorted keys for deterministic hash)
		fmt.Fprintf(b, "\t// Hash map field: %s (sorted keys)\n", field.FieldName)
		fmt.Fprintf(b, "\tkeys%s := make([]string, 0, len(a.%s))\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\tfor k := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tkeys%s = append(keys%s, k)\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tsort.Strings(keys%s)\n", field.FieldName)
		fmt.Fprintf(b, "\tfor _, k := range keys%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte(k))\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s[k])))\n", field.FieldName)
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNestedObject:
		// Hash nested object (incorporate its Hash() result)
		fmt.Fprintf(b, "\t// Hash nested object: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tnestedHash%s := a.%s.Hash()\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\tbinary.Write(h, binary.LittleEndian, nestedHash%s)\n", field.FieldName)
	}
}

// writeFormattedCode formats and writes code to a file using FileSystem
func writeFormattedCode(fs FileSystem, filename string, content []byte) error {
	// Format with goimports
	formatted, err := imports.Process(filename, content, nil)
	if err != nil {
		// If formatting fails, return error (don't write malformed code)
		return errors.Wrap(err, "format code")
	}

	// Write to file using FileSystem interface
	if fs != nil {
		return fs.WriteFile(filename, formatted)
	}

	// Fallback to os.WriteFile for testing
	return os.WriteFile(filename, formatted, 0644)
}

// snakeCase converts PascalCase to snake_case
func snakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
