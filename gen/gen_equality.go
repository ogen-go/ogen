package gen

import (
	"fmt"
	"os"
	"strings"

	"github.com/go-faster/errors"
	"golang.org/x/tools/imports"

	"github.com/ogen-go/ogen/gen/ir"
)

// generateEqualityMethodsWithFS generates Equal() and Hash() methods using a FileSystem
func (g *Generator) generateEqualityMethodsWithFS(fs FileSystem, pkgName string) error {
	for _, spec := range g.equalitySpecs {
		if err := g.generateEqualMethod(spec, pkgName, fs); err != nil {
			return errors.Wrapf(err, "generate Equal for %s", spec.TypeName)
		}
		if err := g.generateHashMethod(spec, pkgName, fs); err != nil {
			return errors.Wrapf(err, "generate Hash for %s", spec.TypeName)
		}
	}
	return nil
}

// generateEqualMethod generates an Equal() method for a type
func (g *Generator) generateEqualMethod(spec *ir.EqualityMethodSpec, pkgName string, fs FileSystem) error {
	var b strings.Builder

	// File header comment
	fmt.Fprintf(&b, "// Code generated by ogen, DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)

	// Method signature
	if spec.NeedsDepthTracking {
		fmt.Fprintf(&b, "// Equal compares two %s instances for equality.\n", spec.TypeName)
		fmt.Fprintf(&b, "// The depth parameter prevents infinite recursion on nested objects.\n")
		fmt.Fprintf(&b, "func (a %s) Equal(b %s, depth int) bool {\n", spec.TypeName, spec.TypeName)

		// Depth limit check
		fmt.Fprintf(&b, "\tif depth > %d {\n", spec.MaxDepth)
		fmt.Fprintf(&b, "\t\tpanic(&validate.DepthLimitError{\n")
		fmt.Fprintf(&b, "\t\t\tMaxDepth: %d,\n", spec.MaxDepth)
		fmt.Fprintf(&b, "\t\t\tTypeName: %q,\n", spec.TypeName)
		fmt.Fprintf(&b, "\t\t})\n")
		fmt.Fprintf(&b, "\t}\n\n")
	} else {
		fmt.Fprintf(&b, "// Equal compares two %s instances for equality.\n", spec.TypeName)
		fmt.Fprintf(&b, "func (a %s) Equal(b %s) bool {\n", spec.TypeName, spec.TypeName)
	}

	// Generate field comparisons
	for _, field := range spec.Fields {
		g.writeFieldComparison(&b, field, spec.NeedsDepthTracking)
	}

	fmt.Fprintf(&b, "\treturn true\n")
	fmt.Fprintf(&b, "}\n")

	// Write to file
	filename := fmt.Sprintf("oas_%s_equal_gen.go", snakeCase(spec.TypeName))
	return writeFormattedCode(fs, filename, []byte(b.String()))
}

// writeFieldComparison generates comparison code for a single field
func (g *Generator) writeFieldComparison(b *strings.Builder, field ir.FieldEqualitySpec, hasDepth bool) {
	switch field.FieldType {
	case ir.FieldTypePrimitive:
		// Byte slices need bytes.Equal()
		if field.IsByteSlice {
			fmt.Fprintf(b, "\t// Compare byte slice field: %s\n", field.FieldName)
			fmt.Fprintf(b, "\tif !bytes.Equal(a.%s, b.%s) {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\treturn false\n")
			fmt.Fprintf(b, "\t}\n")
		} else {
			// Simple equality check
			fmt.Fprintf(b, "\tif a.%s != b.%s {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\treturn false\n")
			fmt.Fprintf(b, "\t}\n")
		}

	case ir.FieldTypeOptional:
		// Optional field comparison (OptT types)
		fmt.Fprintf(b, "\t// Compare optional field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Set != b.%s.Set {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif a.%s.Set {\n", field.FieldName)
		switch {
		case field.IsNested:
			// Optional wrapper around nested object - call Equal()
			if hasDepth {
				fmt.Fprintf(b, "\t\tif !a.%s.Value.Equal(b.%s.Value, depth+1) {\n", field.FieldName, field.FieldName)
			} else {
				fmt.Fprintf(b, "\t\tif !a.%s.Value.Equal(b.%s.Value) {\n", field.FieldName, field.FieldName)
			}
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		case field.IsMap:
			// Optional wrapper around map - need custom comparison
			g.writeMapComparison(b, fmt.Sprintf("a.%s.Value", field.FieldName), fmt.Sprintf("b.%s.Value", field.FieldName), "\t\t")
		case field.IsArray:
			// Optional wrapper around array - need iteration
			aArray := fmt.Sprintf("a.%s.Value", field.FieldName)
			bArray := fmt.Sprintf("b.%s.Value", field.FieldName)
			g.writeArrayComparisonWithNullable(b, aArray, bArray, "\t\t",
				field.IsArrayOfStructs, field.IsArrayOfNullable, hasDepth)
		default:
			// Optional wrapper around primitive - use !=
			fmt.Fprintf(b, "\t\tif a.%s.Value != b.%s.Value {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		}
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNullable:
		// Nullable field comparison (NilT types)
		fmt.Fprintf(b, "\t// Compare nullable field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Null != b.%s.Null {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif !a.%s.Null {\n", field.FieldName)
		switch {
		case field.IsNested:
			// Nullable wrapper around nested object - call Equal()
			if hasDepth {
				fmt.Fprintf(b, "\t\tif !a.%s.Value.Equal(b.%s.Value, depth+1) {\n", field.FieldName, field.FieldName)
			} else {
				fmt.Fprintf(b, "\t\tif !a.%s.Value.Equal(b.%s.Value) {\n", field.FieldName, field.FieldName)
			}
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		case field.IsMap:
			// Nullable wrapper around map - need custom comparison
			g.writeMapComparison(b, fmt.Sprintf("a.%s.Value", field.FieldName), fmt.Sprintf("b.%s.Value", field.FieldName), "\t\t")
		case field.IsArray:
			// Nullable wrapper around array - need iteration
			aArray := fmt.Sprintf("a.%s.Value", field.FieldName)
			bArray := fmt.Sprintf("b.%s.Value", field.FieldName)
			g.writeArrayComparisonWithNullable(b, aArray, bArray, "\t\t",
				field.IsArrayOfStructs, field.IsArrayOfNullable, hasDepth)
		default:
			// Nullable wrapper around primitive - use !=
			fmt.Fprintf(b, "\t\tif a.%s.Value != b.%s.Value {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		}
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypePointer:
		// Pointer field comparison
		fmt.Fprintf(b, "\t// Compare pointer field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif (a.%s == nil) != (b.%s == nil) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tif a.%s != nil {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif *a.%s != *b.%s {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeArray:
		// Array field comparison
		fmt.Fprintf(b, "\t// Compare array field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif len(a.%s) != len(b.%s) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tfor i := range a.%s {\n", field.FieldName)
		// Check if array elements are nullable wrappers
		switch {
		case field.IsArrayOfNullable:
			// Nullable wrapper elements - compare Null flag then Value
			fmt.Fprintf(b, "\t\tif a.%s[i].Null != b.%s[i].Null {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
			fmt.Fprintf(b, "\t\tif !a.%s[i].Null {\n", field.FieldName)
			// Check if the wrapped value is a struct (needs Equal()) or primitive (use !=)
			if field.IsArrayOfStructs {
				// Value is a struct - call Equal()
				if hasDepth {
					fmt.Fprintf(b, "\t\t\tif !a.%s[i].Value.Equal(b.%s[i].Value, depth+1) {\n", field.FieldName, field.FieldName)
				} else {
					fmt.Fprintf(b, "\t\t\tif !a.%s[i].Value.Equal(b.%s[i].Value) {\n", field.FieldName, field.FieldName)
				}
			} else {
				// Value is a primitive - use !=
				fmt.Fprintf(b, "\t\t\tif a.%s[i].Value != b.%s[i].Value {\n", field.FieldName, field.FieldName)
			}
			fmt.Fprintf(b, "\t\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t\t}\n")
			fmt.Fprintf(b, "\t\t}\n")
		case field.IsArrayOfStructs:
			// Struct elements - call Equal()
			if hasDepth {
				fmt.Fprintf(b, "\t\tif !a.%s[i].Equal(b.%s[i], depth+1) {\n", field.FieldName, field.FieldName)
			} else {
				fmt.Fprintf(b, "\t\tif !a.%s[i].Equal(b.%s[i]) {\n", field.FieldName, field.FieldName)
			}
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		default:
			// Primitive elements can use !=
			fmt.Fprintf(b, "\t\tif a.%s[i] != b.%s[i] {\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\t\treturn false\n")
			fmt.Fprintf(b, "\t\t}\n")
		}
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeMap:
		// Map field comparison
		fmt.Fprintf(b, "\t// Compare map field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif len(a.%s) != len(b.%s) {\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tfor k, v := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tbv, ok := b.%s[k]\n", field.FieldName)
		fmt.Fprintf(b, "\t\tif !ok || v != bv {\n")
		fmt.Fprintf(b, "\t\t\treturn false\n")
		fmt.Fprintf(b, "\t\t}\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNestedObject:
		// Nested object comparison (recursive Equal() call)
		fmt.Fprintf(b, "\t// Compare nested object: %s\n", field.FieldName)
		if hasDepth {
			fmt.Fprintf(b, "\tif !a.%s.Equal(b.%s, depth+1) {\n", field.FieldName, field.FieldName)
		} else {
			fmt.Fprintf(b, "\tif !a.%s.Equal(b.%s) {\n", field.FieldName, field.FieldName)
		}
		fmt.Fprintf(b, "\t\treturn false\n")
		fmt.Fprintf(b, "\t}\n")
	}
}

// generateHashMethod generates a Hash() method for a type
func (g *Generator) generateHashMethod(spec *ir.EqualityMethodSpec, pkgName string, fs FileSystem) error {
	var b strings.Builder

	// File header comment
	fmt.Fprintf(&b, "// Code generated by ogen, DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)

	// Imports
	fmt.Fprintf(&b, "import (\n")
	fmt.Fprintf(&b, "\t\"encoding/binary\"\n")
	fmt.Fprintf(&b, "\t\"fmt\"\n")
	fmt.Fprintf(&b, "\t\"hash/fnv\"\n")
	fmt.Fprintf(&b, "\t\"sort\"\n")
	fmt.Fprintf(&b, ")\n\n")

	// Method signature
	fmt.Fprintf(&b, "// Hash computes a hash value for %s using FNV-1a.\n", spec.TypeName)
	fmt.Fprintf(&b, "// Equal objects must produce equal hashes.\n")
	fmt.Fprintf(&b, "func (a %s) Hash() uint64 {\n", spec.TypeName)

	// Initialize hash
	fmt.Fprintf(&b, "\th := fnv.New64a()\n\n")

	// Hash each field
	for _, field := range spec.Fields {
		// Convert FieldEqualitySpec to FieldHashSpec
		hashField := ir.FieldHashSpec{
			FieldName: field.FieldName,
			FieldType: field.FieldType,
			GoType:    field.GoType,
			IsNested:  field.IsNested,
		}
		g.writeFieldHash(&b, hashField)
	}

	fmt.Fprintf(&b, "\treturn h.Sum64()\n")
	fmt.Fprintf(&b, "}\n")

	// Write to file
	filename := fmt.Sprintf("oas_%s_hash_gen.go", snakeCase(spec.TypeName))
	return writeFormattedCode(fs, filename, []byte(b.String()))
}

// writeFieldHash generates hashing code for a single field
func (g *Generator) writeFieldHash(b *strings.Builder, field ir.FieldHashSpec) {
	switch field.FieldType {
	case ir.FieldTypePrimitive:
		// Hash primitive field
		fmt.Fprintf(b, "\t// Hash primitive field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s)))\n", field.FieldName)

	case ir.FieldTypeOptional:
		// Hash optional field (presence + value)
		fmt.Fprintf(b, "\t// Hash optional field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Set {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		if field.IsNested {
			// Optional wrapper around nested object - call Hash()
			fmt.Fprintf(b, "\t\tnestedHash%s := a.%s.Value.Hash()\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\tbinary.Write(h, binary.LittleEndian, nestedHash%s)\n", field.FieldName)
		} else {
			// Optional wrapper around primitive - format value
			fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s.Value)))\n", field.FieldName)
		}
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNullable:
		// Hash nullable field
		fmt.Fprintf(b, "\t// Hash nullable field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s.Null {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		if field.IsNested {
			// Nullable wrapper around nested object - call Hash()
			fmt.Fprintf(b, "\t\tnestedHash%s := a.%s.Value.Hash()\n", field.FieldName, field.FieldName)
			fmt.Fprintf(b, "\t\tbinary.Write(h, binary.LittleEndian, nestedHash%s)\n", field.FieldName)
		} else {
			// Nullable wrapper around primitive - format value
			fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s.Value)))\n", field.FieldName)
		}
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypePointer:
		// Hash pointer field
		fmt.Fprintf(b, "\t// Hash pointer field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tif a.%s != nil {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte{1})\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", *a.%s)))\n", field.FieldName)
		fmt.Fprintf(b, "\t} else {\n")
		fmt.Fprintf(b, "\t\th.Write([]byte{0})\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeArray:
		// Hash array field
		fmt.Fprintf(b, "\t// Hash array field: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tfor _, item := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", item)))\n")
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeMap:
		// Hash map field (sorted keys for deterministic hash)
		fmt.Fprintf(b, "\t// Hash map field: %s (sorted keys)\n", field.FieldName)
		fmt.Fprintf(b, "\tkeys%s := make([]string, 0, len(a.%s))\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\tfor k := range a.%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\tkeys%s = append(keys%s, k)\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "\tsort.Strings(keys%s)\n", field.FieldName)
		fmt.Fprintf(b, "\tfor _, k := range keys%s {\n", field.FieldName)
		fmt.Fprintf(b, "\t\th.Write([]byte(k))\n")
		fmt.Fprintf(b, "\t\th.Write([]byte(fmt.Sprintf(\"%%v\", a.%s[k])))\n", field.FieldName)
		fmt.Fprintf(b, "\t}\n")

	case ir.FieldTypeNestedObject:
		// Hash nested object (incorporate its Hash() result)
		fmt.Fprintf(b, "\t// Hash nested object: %s\n", field.FieldName)
		fmt.Fprintf(b, "\tnestedHash%s := a.%s.Hash()\n", field.FieldName, field.FieldName)
		fmt.Fprintf(b, "\tbinary.Write(h, binary.LittleEndian, nestedHash%s)\n", field.FieldName)
	}
}

// writeFormattedCode formats and writes code to a file using FileSystem
func writeFormattedCode(fs FileSystem, filename string, content []byte) error {
	// Format with goimports
	formatted, err := imports.Process(filename, content, nil)
	if err != nil {
		// If formatting fails, return error (don't write malformed code)
		return errors.Wrap(err, "format code")
	}

	// Write to file using FileSystem interface
	if fs != nil {
		return fs.WriteFile(filename, formatted)
	}

	// Fallback to os.WriteFile for testing
	return os.WriteFile(filename, formatted, 0644)
}

// snakeCase converts PascalCase to snake_case
func snakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// writeMapComparison generates map comparison code
func (g *Generator) writeMapComparison(b *strings.Builder, aMap, bMap, indent string) {
	fmt.Fprintf(b, "%sif len(%s) != len(%s) {\n", indent, aMap, bMap)
	fmt.Fprintf(b, "%s\treturn false\n", indent)
	fmt.Fprintf(b, "%s}\n", indent)
	fmt.Fprintf(b, "%sfor k, v := range %s {\n", indent, aMap)
	fmt.Fprintf(b, "%s\tif bv, ok := %s[k]; !ok || v != bv {\n", indent, bMap)
	fmt.Fprintf(b, "%s\t\treturn false\n", indent)
	fmt.Fprintf(b, "%s\t}\n", indent)
	fmt.Fprintf(b, "%s}\n", indent)
}

// writeArrayComparison generates array comparison code
func (g *Generator) writeArrayComparison(b *strings.Builder, aArray, bArray, indent string, isArrayOfStructs, hasDepth bool) {
	g.writeArrayComparisonWithNullable(b, aArray, bArray, indent, isArrayOfStructs, false, hasDepth)
}

// writeArrayComparisonWithNullable generates array comparison code with nullable support
func (g *Generator) writeArrayComparisonWithNullable(
	b *strings.Builder, aArray, bArray, indent string,
	isArrayOfStructs, isArrayOfNullable, hasDepth bool,
) {
	fmt.Fprintf(b, "%sif len(%s) != len(%s) {\n", indent, aArray, bArray)
	fmt.Fprintf(b, "%s\treturn false\n", indent)
	fmt.Fprintf(b, "%s}\n", indent)
	fmt.Fprintf(b, "%sfor i := range %s {\n", indent, aArray)
	switch {
	case isArrayOfNullable:
		// Nullable wrapper elements - compare Null flag then Value
		fmt.Fprintf(b, "%s\tif %s[i].Null != %s[i].Null {\n", indent, aArray, bArray)
		fmt.Fprintf(b, "%s\t\treturn false\n", indent)
		fmt.Fprintf(b, "%s\t}\n", indent)
		fmt.Fprintf(b, "%s\tif !%s[i].Null {\n", indent, aArray)
		// Check if the wrapped value is a struct (needs Equal()) or primitive (use !=)
		if isArrayOfStructs {
			// Value is a struct - call Equal()
			if hasDepth {
				fmt.Fprintf(b, "%s\t\tif !%s[i].Value.Equal(%s[i].Value, depth+1) {\n", indent, aArray, bArray)
			} else {
				fmt.Fprintf(b, "%s\t\tif !%s[i].Value.Equal(%s[i].Value) {\n", indent, aArray, bArray)
			}
		} else {
			// Value is a primitive - use !=
			fmt.Fprintf(b, "%s\t\tif %s[i].Value != %s[i].Value {\n", indent, aArray, bArray)
		}
		fmt.Fprintf(b, "%s\t\t\treturn false\n", indent)
		fmt.Fprintf(b, "%s\t\t}\n", indent)
		fmt.Fprintf(b, "%s\t}\n", indent)
	case isArrayOfStructs:
		// Array elements are structs - call Equal()
		if hasDepth {
			fmt.Fprintf(b, "%s\tif !%s[i].Equal(%s[i], depth+1) {\n", indent, aArray, bArray)
		} else {
			fmt.Fprintf(b, "%s\tif !%s[i].Equal(%s[i]) {\n", indent, aArray, bArray)
		}
		fmt.Fprintf(b, "%s\t\treturn false\n", indent)
		fmt.Fprintf(b, "%s\t}\n", indent)
	default:
		// Primitive elements can use !=
		fmt.Fprintf(b, "%s\tif %s[i] != %s[i] {\n", indent, aArray, bArray)
		fmt.Fprintf(b, "%s\t\treturn false\n", indent)
		fmt.Fprintf(b, "%s\t}\n", indent)
	}
	fmt.Fprintf(b, "%s}\n", indent)
}
