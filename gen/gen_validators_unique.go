package gen

import (
	"fmt"
	"os"
	"strings"

	"github.com/go-faster/errors"
	"golang.org/x/tools/imports"

	"github.com/ogen-go/ogen/gen/ir"
)

// generateUniqueValidators generates validateUnique[TypeName]() functions
// for arrays of complex types that require hash-based duplicate detection.
func (g *Generator) generateUniqueValidators(fs FileSystem, pkgName string) error {
	if len(g.equalitySpecs) == 0 {
		return nil // No complex types requiring unique validation
	}

	var b strings.Builder

	// Package and imports
	fmt.Fprintf(&b, "// Code generated by ogen, DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)
	fmt.Fprintf(&b, "import (\n")
	fmt.Fprintf(&b, "\t\"github.com/ogen-go/ogen/validate\"\n")
	fmt.Fprintf(&b, ")\n\n")

	// Generate a validateUnique function for each type with Equal/Hash
	for _, spec := range g.equalitySpecs {
		if err := g.writeValidateUnique(&b, spec); err != nil {
			return errors.Wrapf(err, "generate validateUnique for %s", spec.TypeName)
		}
	}

	// Format and write
	filename := fmt.Sprintf("%s_validators_unique_gen.go", snakeCase(pkgName))
	return g.writeFormattedFile(fs, filename, b.String())
}

// writeValidateUnique generates a single validateUnique[TypeName]() function
func (g *Generator) writeValidateUnique(b *strings.Builder, spec *ir.EqualityMethodSpec) error {
	typeName := spec.TypeName

	fmt.Fprintf(b, "// validateUnique%s checks for duplicate items in a slice using hash-based detection.\n", typeName)
	fmt.Fprintf(b, "func validateUnique%s(items []%s) (err error) {\n", typeName, typeName)

	// Early return for empty or single-element arrays
	fmt.Fprintf(b, "\tif len(items) <= 1 {\n")
	fmt.Fprintf(b, "\t\treturn nil\n")
	fmt.Fprintf(b, "\t}\n\n")

	// Depth limit error recovery - use named return value
	fmt.Fprintf(b, "\t// Recover from depth limit panics during Equal() calls\n")
	fmt.Fprintf(b, "\tdefer func() {\n")
	fmt.Fprintf(b, "\t\tif r := recover(); r != nil {\n")
	fmt.Fprintf(b, "\t\t\tif e, ok := r.(*validate.DepthLimitError); ok {\n")
	fmt.Fprintf(b, "\t\t\t\terr = e\n")
	fmt.Fprintf(b, "\t\t\t} else {\n")
	fmt.Fprintf(b, "\t\t\t\tpanic(r) // Re-panic if not a depth limit error\n")
	fmt.Fprintf(b, "\t\t\t}\n")
	fmt.Fprintf(b, "\t\t}\n")
	fmt.Fprintf(b, "\t}()\n\n")

	// Hash bucket structure: map[uint64][]entry
	fmt.Fprintf(b, "\t// Hash bucket structure for O(n) duplicate detection\n")
	fmt.Fprintf(b, "\ttype entry struct {\n")
	fmt.Fprintf(b, "\t\titem  %s\n", typeName)
	fmt.Fprintf(b, "\t\tindex int\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tbuckets := make(map[uint64][]entry, len(items))\n\n")

	// Hash-based duplicate detection loop
	fmt.Fprintf(b, "\t// Check each item for duplicates\n")
	fmt.Fprintf(b, "\tfor i, item := range items {\n")
	fmt.Fprintf(b, "\t\thash := item.Hash()\n")
	fmt.Fprintf(b, "\t\tbucket := buckets[hash]\n\n")

	fmt.Fprintf(b, "\t\t// Check for duplicates in this hash bucket\n")
	fmt.Fprintf(b, "\t\tfor _, existing := range bucket {\n")

	// Equal() call with depth parameter if needed
	if spec.NeedsDepthTracking {
		fmt.Fprintf(b, "\t\t\tif item.Equal(existing.item, 0) {\n")
	} else {
		fmt.Fprintf(b, "\t\t\tif item.Equal(existing.item) {\n")
	}

	fmt.Fprintf(b, "\t\t\t\treturn &validate.DuplicateItemsError{\n")
	fmt.Fprintf(b, "\t\t\t\t\tIndices: []int{existing.index, i},\n")
	fmt.Fprintf(b, "\t\t\t\t}\n")
	fmt.Fprintf(b, "\t\t\t}\n")
	fmt.Fprintf(b, "\t\t}\n\n")

	fmt.Fprintf(b, "\t\t// No duplicate found, add to bucket\n")
	fmt.Fprintf(b, "\t\tbuckets[hash] = append(bucket, entry{item: item, index: i})\n")
	fmt.Fprintf(b, "\t}\n\n")

	fmt.Fprintf(b, "\treturn nil\n")
	fmt.Fprintf(b, "}\n\n")

	return nil
}

// writeFormattedFile formats and writes generated code to a file
func (g *Generator) writeFormattedFile(fs FileSystem, filename, content string) error {
	// Format with goimports
	formatted, err := imports.Process(filename, []byte(content), nil)
	if err != nil {
		// If formatting fails, return the unformatted code with the error
		return errors.Wrapf(err, "format %s", filename)
	}

	if fs != nil {
		return fs.WriteFile(filename, formatted)
	}

	// Fallback to os.WriteFile for testing
	return os.WriteFile(filename, formatted, 0644)
}
